/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkems"] = self["webpackChunkems"] || []).push([["vendors-node_modules_helia_block-brokers_dist_src_index_js"],{

/***/ "./node_modules/@vascosantos/moving-average/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vascosantos/moving-average/index.js ***!
  \***********************************************************/
/***/ ((module, exports) => {

eval("\n\nconst exp = Math.exp\n\nexports =\nmodule.exports =\nfunction MovingAverage (timespan) {\n  if (typeof timespan !== 'number') { throw new Error('must provide a timespan to the moving average constructor') }\n\n  if (timespan <= 0) { throw new Error('must provide a timespan > 0 to the moving average constructor') }\n\n  let ma     // moving average\n  let v = 0  // variance\n  let d = 0  // deviation\n  let f = 0  // forecast\n\n  let previousTime\n\n  let ret = {}\n\n  function alpha (t, pt) {\n    return 1 - (exp(-(t - pt) / timespan))\n  }\n\n  ret.push =\n  function push (time, value) {\n    if (previousTime) {\n      // calculate moving average\n      const a = alpha(time, previousTime)\n      const diff = value - ma\n      const incr = a * diff\n      ma = a * value + (1 - a) * ma\n      // calculate variance & deviation\n      v = (1 - a) * (v + diff * incr)\n      d = Math.sqrt(v)\n      // calculate forecast\n      f = ma + a * diff\n    } else {\n      ma = value\n    }\n    previousTime = time\n  }\n\n  // Exponential Moving Average\n\n  ret.movingAverage =\n  function movingAverage () {\n    return ma\n  }\n\n  // Variance\n  ret.variance =\n  function variance () {\n    return v\n  }\n\n  ret.deviation =\n  function deviation () {\n    return d\n  }\n\n  ret.forecast =\n  function forecast () {\n    return f\n  }\n\n  return ret\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/@vascosantos/moving-average/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/retimer/retimer.js":
/*!*****************************************!*\
  !*** ./node_modules/retimer/retimer.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst getTime = __webpack_require__(/*! ./time */ \"./node_modules/retimer/time-browser.js\")\n\nclass Retimer {\n  constructor (callback, timeout, args) {\n    const that = this\n\n    this._started = getTime()\n    this._rescheduled = 0\n    this._scheduled = timeout\n    this._args = args\n    this._triggered = false\n\n    this._timerWrapper = () => {\n      if (that._rescheduled > 0) {\n        that._scheduled = that._rescheduled - (getTime() - that._started)\n        that._schedule(that._scheduled)\n      } else {\n        that._triggered = true\n        callback.apply(null, that._args)\n      }\n    }\n\n    this._timer = setTimeout(this._timerWrapper, timeout)\n  }\n\n  reschedule (timeout) {\n    if (!timeout) {\n      timeout = this._scheduled\n    }\n    const now = getTime()\n    if ((now + timeout) - (this._started + this._scheduled) < 0) {\n      clearTimeout(this._timer)\n      this._schedule(timeout)\n    } else if (!this._triggered) {\n      this._started = now\n      this._rescheduled = timeout\n    } else {\n      this._schedule(timeout)\n    }\n  }\n\n  _schedule (timeout) {\n    this._triggered = false\n    this._started = getTime()\n    this._rescheduled = 0\n    this._scheduled = timeout\n    this._timer = setTimeout(this._timerWrapper, timeout)\n  }\n\n  clear () {\n    clearTimeout(this._timer)\n  }\n}\n\nfunction retimer () {\n  if (typeof arguments[0] !== 'function') {\n    throw new Error('callback needed')\n  }\n\n  if (typeof arguments[1] !== 'number') {\n    throw new Error('timeout needed')\n  }\n\n  let args\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2)\n\n    /* eslint-disable no-var */\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2]\n    }\n  }\n\n  return new Retimer(arguments[0], arguments[1], args)\n}\n\nmodule.exports = retimer\n\n\n//# sourceURL=webpack://ems/./node_modules/retimer/retimer.js?");

/***/ }),

/***/ "./node_modules/retimer/time-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/retimer/time-browser.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function getTime () {\n  return Date.now()\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/retimer/time-browser.js?");

/***/ }),

/***/ "./node_modules/timeout-abort-controller/index.js":
/*!********************************************************!*\
  !*** ./node_modules/timeout-abort-controller/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { AbortController } = globalThis\n\n// @ts-expect-error no types\nconst retimer = __webpack_require__(/*! retimer */ \"./node_modules/retimer/retimer.js\")\n\nclass TimeoutController extends AbortController {\n  /**\n   * @constructor\n   * @param {number} ms milliseconds\n   */\n  constructor (ms) {\n    super()\n    this._ms = ms\n    this._timer = retimer(() => this.abort(), ms)\n    // Patch for safari not supported extending built in classes\n    Object.setPrototypeOf(this, TimeoutController.prototype)\n  }\n\n  /**\n   * Aborts the controller and clears the timer\n   */\n  abort () {\n    this._timer.clear()\n    return super.abort()\n  }\n\n  /**\n   * Clears the timer\n   */\n  clear () {\n    this._timer.clear()\n  }\n\n  /**\n   * Resets the timer\n   */\n  reset () {\n    this._timer.clear()\n    this._timer = retimer(() => this.abort(), this._ms)\n  }\n}\n\nmodule.exports = {\n  TimeoutController\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/timeout-abort-controller/index.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/decode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/decode.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/decode.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/encode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/encode.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/encode.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n    encode: __webpack_require__(/*! ./encode.js */ \"./node_modules/varint-decoder/node_modules/varint/encode.js\")\n  , decode: __webpack_require__(/*! ./decode.js */ \"./node_modules/varint-decoder/node_modules/varint/decode.js\")\n  , encodingLength: __webpack_require__(/*! ./length.js */ \"./node_modules/varint-decoder/node_modules/varint/length.js\")\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/index.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/length.js":
/*!*******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/length.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/length.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/varint-decoder/src/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst varint = __webpack_require__(/*! varint */ \"./node_modules/varint-decoder/node_modules/varint/index.js\")\n\nmodule.exports = (buf) => {\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('arg needs to be a Uint8Array')\n  }\n\n  const result = []\n\n  while (buf.length > 0) {\n    const num = varint.decode(buf)\n    result.push(num)\n    buf = buf.slice(varint.decode.bytes)\n  }\n\n  return result\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/src/index.js?");

/***/ }),

/***/ "./node_modules/varint/decode.js":
/*!***************************************!*\
  !*** ./node_modules/varint/decode.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/decode.js?");

/***/ }),

/***/ "./node_modules/varint/encode.js":
/*!***************************************!*\
  !*** ./node_modules/varint/encode.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/encode.js?");

/***/ }),

/***/ "./node_modules/varint/index.js":
/*!**************************************!*\
  !*** ./node_modules/varint/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n    encode: __webpack_require__(/*! ./encode.js */ \"./node_modules/varint/encode.js\")\n  , decode: __webpack_require__(/*! ./decode.js */ \"./node_modules/varint/decode.js\")\n  , encodingLength: __webpack_require__(/*! ./length.js */ \"./node_modules/varint/length.js\")\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/index.js?");

/***/ }),

/***/ "./node_modules/varint/length.js":
/*!***************************************!*\
  !*** ./node_modules/varint/length.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/length.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/bitswap.js":
/*!***************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/bitswap.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitswap: () => (/* binding */ bitswap)\n/* harmony export */ });\n/* harmony import */ var ipfs_bitswap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-bitswap */ \"./node_modules/ipfs-bitswap/dist/src/index.js\");\n\nclass BitswapBlockBroker {\n    bitswap;\n    started;\n    constructor(components, init = {}) {\n        const { libp2p, blockstore, hashers } = components;\n        this.bitswap = (0,ipfs_bitswap__WEBPACK_IMPORTED_MODULE_0__.createBitswap)(libp2p, blockstore, {\n            hashLoader: {\n                getHasher: async (codecOrName) => {\n                    let hasher;\n                    if (typeof codecOrName === 'string') {\n                        hasher = Object.values(hashers).find(hasher => {\n                            return hasher.name === codecOrName;\n                        });\n                    }\n                    else {\n                        hasher = hashers[codecOrName];\n                    }\n                    if (hasher != null) {\n                        return hasher;\n                    }\n                    throw new Error(`Could not load hasher for code/name \"${codecOrName}\"`);\n                }\n            },\n            ...init\n        });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await this.bitswap.start();\n        this.started = true;\n    }\n    async stop() {\n        await this.bitswap.stop();\n        this.started = false;\n    }\n    announce(cid, block, options) {\n        this.bitswap.notify(cid, block, options);\n    }\n    async retrieve(cid, { validateFn, ...options } = {}) {\n        return this.bitswap.want(cid, options);\n    }\n}\n/**\n * A helper factory for users who want to override Helia `blockBrokers` but\n * still want to use the default `BitswapBlockBroker`.\n */\nfunction bitswap(init = {}) {\n    return (components) => new BitswapBlockBroker(components, init);\n}\n//# sourceMappingURL=bitswap.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/bitswap.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitswap: () => (/* reexport safe */ _bitswap_js__WEBPACK_IMPORTED_MODULE_0__.bitswap),\n/* harmony export */   trustlessGateway: () => (/* reexport safe */ _trustless_gateway_index_js__WEBPACK_IMPORTED_MODULE_1__.trustlessGateway)\n/* harmony export */ });\n/* harmony import */ var _bitswap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitswap.js */ \"./node_modules/@helia/block-brokers/dist/src/bitswap.js\");\n/* harmony import */ var _trustless_gateway_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trustless-gateway/index.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrustlessGatewayBlockBroker: () => (/* binding */ TrustlessGatewayBlockBroker)\n/* harmony export */ });\n/* harmony import */ var _trustless_gateway_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trustless-gateway.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js\");\n\n\n/**\n * A class that accepts a list of trustless gateways that are queried\n * for blocks.\n */\nclass TrustlessGatewayBlockBroker {\n    gateways;\n    log;\n    constructor(components, init = {}) {\n        this.log = components.logger.forComponent('helia:trustless-gateway-block-broker');\n        this.gateways = (init.gateways ?? _index_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TRUSTLESS_GATEWAYS)\n            .map((gatewayOrUrl) => {\n            return new _trustless_gateway_js__WEBPACK_IMPORTED_MODULE_0__.TrustlessGateway(gatewayOrUrl);\n        });\n    }\n    async retrieve(cid, options = {}) {\n        // Loop through the gateways until we get a block or run out of gateways\n        // TODO: switch to toSorted when support is better\n        const sortedGateways = this.gateways.sort((a, b) => b.reliability() - a.reliability());\n        const aggregateErrors = [];\n        for (const gateway of sortedGateways) {\n            this.log('getting block for %c from %s', cid, gateway.url);\n            try {\n                const block = await gateway.getRawBlock(cid, options.signal);\n                this.log.trace('got block for %c from %s', cid, gateway.url);\n                try {\n                    await options.validateFn?.(block);\n                }\n                catch (err) {\n                    this.log.error('failed to validate block for %c from %s', cid, gateway.url, err);\n                    gateway.incrementInvalidBlocks();\n                    throw new Error(`unable to validate block for CID ${cid} from gateway ${gateway.url}`);\n                }\n                return block;\n            }\n            catch (err) {\n                this.log.error('failed to get block for %c from %s', cid, gateway.url, err);\n                if (err instanceof Error) {\n                    aggregateErrors.push(err);\n                }\n                else {\n                    aggregateErrors.push(new Error(`unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));\n                }\n                // if signal was aborted, exit the loop\n                if (options.signal?.aborted === true) {\n                    this.log.trace('request aborted while fetching raw block for CID %c from gateway %s', cid, gateway.url);\n                    break;\n                }\n            }\n        }\n        throw new AggregateError(aggregateErrors, `unable to fetch raw block for CID ${cid} from any gateway`);\n    }\n}\n//# sourceMappingURL=broker.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TRUSTLESS_GATEWAYS: () => (/* binding */ DEFAULT_TRUSTLESS_GATEWAYS),\n/* harmony export */   trustlessGateway: () => (/* binding */ trustlessGateway)\n/* harmony export */ });\n/* harmony import */ var _broker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broker.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js\");\n\nconst DEFAULT_TRUSTLESS_GATEWAYS = [\n    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/\n    'https://trustless-gateway.link',\n    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/\n    'https://cloudflare-ipfs.com',\n    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/\n    'https://4everland.io'\n];\nfunction trustlessGateway(init = {}) {\n    return (components) => new _broker_js__WEBPACK_IMPORTED_MODULE_0__.TrustlessGatewayBlockBroker(components, init);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrustlessGateway: () => (/* binding */ TrustlessGateway)\n/* harmony export */ });\n/**\n * A `TrustlessGateway` keeps track of the number of attempts, errors, and\n * successes for a given gateway url so that we can prioritize gateways that\n * have been more reliable in the past, and ensure that requests are distributed\n * across all gateways within a given `TrustlessGatewayBlockBroker` instance.\n */\nclass TrustlessGateway {\n    url;\n    /**\n     * The number of times this gateway has been attempted to be used to fetch a\n     * block. This includes successful, errored, and aborted attempts. By counting\n     * even aborted attempts, slow gateways that are out-raced by others will be\n     * considered less reliable.\n     */\n    #attempts = 0;\n    /**\n     * The number of times this gateway has errored while attempting to fetch a\n     * block. This includes `response.ok === false` and any other errors that\n     * throw while attempting to fetch a block. This does not include aborted\n     * attempts.\n     */\n    #errors = 0;\n    /**\n     * The number of times this gateway has returned an invalid block. A gateway\n     * that returns the wrong blocks for a CID should be considered for removal\n     * from the list of gateways to fetch blocks from.\n     */\n    #invalidBlocks = 0;\n    /**\n     * The number of times this gateway has successfully fetched a block.\n     */\n    #successes = 0;\n    constructor(url) {\n        this.url = url instanceof URL ? url : new URL(url);\n    }\n    /**\n     * Fetch a raw block from `this.url` following the specification defined at\n     * https://specs.ipfs.tech/http-gateways/trustless-gateway/\n     */\n    async getRawBlock(cid, signal) {\n        const gwUrl = this.url;\n        gwUrl.pathname = `/ipfs/${cid.toString()}`;\n        // necessary as not every gateway supports dag-cbor, but every should support\n        // sending raw block as-is\n        gwUrl.search = '?format=raw';\n        if (signal?.aborted === true) {\n            throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);\n        }\n        try {\n            this.#attempts++;\n            const res = await fetch(gwUrl.toString(), {\n                signal,\n                headers: {\n                    // also set header, just in case ?format= is filtered out by some\n                    // reverse proxy\n                    Accept: 'application/vnd.ipld.raw'\n                },\n                cache: 'force-cache'\n            });\n            if (!res.ok) {\n                this.#errors++;\n                throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);\n            }\n            this.#successes++;\n            return new Uint8Array(await res.arrayBuffer());\n        }\n        catch (cause) {\n            // @ts-expect-error - TS thinks signal?.aborted can only be false now\n            // because it was checked for true above.\n            if (signal?.aborted === true) {\n                throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);\n            }\n            this.#errors++;\n            throw new Error(`unable to fetch raw block for CID ${cid}`);\n        }\n    }\n    /**\n     * Encapsulate the logic for determining whether a gateway is considered\n     * reliable, for prioritization. This is based on the number of successful attempts made\n     * and the number of errors encountered.\n     *\n     * Unused gateways have 100% reliability; They will be prioritized over\n     * gateways with a 100% success rate to ensure that we attempt all gateways.\n     */\n    reliability() {\n        /**\n         * if we have never tried to use this gateway, it is considered the most\n         * reliable until we determine otherwise (prioritize unused gateways)\n         */\n        if (this.#attempts === 0) {\n            return 1;\n        }\n        if (this.#invalidBlocks > 0) {\n            // this gateway may not be trustworthy..\n            return -Infinity;\n        }\n        /**\n         * We have attempted the gateway, so we need to calculate the reliability\n         * based on the number of attempts, errors, and successes. Gateways that\n         * return a single error should drop their reliability score more than a\n         * single success increases it.\n         *\n         * Play around with the below reliability function at https://www.desmos.com/calculator/d6hfhf5ukm\n         */\n        return this.#successes / (this.#attempts + (this.#errors * 3));\n    }\n    /**\n     * Increment the number of invalid blocks returned by this gateway.\n     */\n    incrementInvalidBlocks() {\n        this.#invalidBlocks++;\n    }\n}\n//# sourceMappingURL=trustless-gateway.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/tracked-map.js":
/*!************************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/tracked-map.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trackedMap: () => (/* binding */ trackedMap)\n/* harmony export */ });\nclass TrackedMap extends Map {\n    metric;\n    constructor(init) {\n        super();\n        const { name, metrics } = init;\n        this.metric = metrics.registerMetric(name);\n        this.updateComponentMetric();\n    }\n    set(key, value) {\n        super.set(key, value);\n        this.updateComponentMetric();\n        return this;\n    }\n    delete(key) {\n        const deleted = super.delete(key);\n        this.updateComponentMetric();\n        return deleted;\n    }\n    clear() {\n        super.clear();\n        this.updateComponentMetric();\n    }\n    updateComponentMetric() {\n        this.metric.update(this.size);\n    }\n}\nfunction trackedMap(config) {\n    const { name, metrics } = config;\n    let map;\n    if (metrics != null) {\n        map = new TrackedMap({ name, metrics });\n    }\n    else {\n        map = new Map();\n    }\n    return map;\n}\n//# sourceMappingURL=tracked-map.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/tracked-map.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/bitswap.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/bitswap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBitswap: () => (/* binding */ DefaultBitswap)\n/* harmony export */ });\n/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! any-signal */ \"./node_modules/any-signal/dist/src/index.js\");\n/* harmony import */ var it_foreach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-foreach */ \"./node_modules/it-foreach/dist/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _decision_engine_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./decision-engine/index.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network.js */ \"./node_modules/ipfs-bitswap/dist/src/network.js\");\n/* harmony import */ var _notifications_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./notifications.js */ \"./node_modules/ipfs-bitswap/dist/src/notifications.js\");\n/* harmony import */ var _stats_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stats/index.js */ \"./node_modules/ipfs-bitswap/dist/src/stats/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _want_manager_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./want-manager/index.js */ \"./node_modules/ipfs-bitswap/dist/src/want-manager/index.js\");\n\n\n\n\n\n\n\n\n\nconst hashLoader = {\n    async getHasher() {\n        throw new Error('Not implemented');\n    }\n};\nconst defaultOptions = {\n    maxInboundStreams: 1024,\n    maxOutboundStreams: 1024,\n    incomingStreamTimeout: 30000,\n    hashLoader,\n    statsEnabled: false,\n    statsComputeThrottleTimeout: 1000,\n    statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = [\n    'blocksReceived',\n    'dataReceived',\n    'dupBlksReceived',\n    'dupDataReceived',\n    'blocksSent',\n    'dataSent',\n    'providesBufferLength',\n    'wantListLength',\n    'peerCount'\n];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n */\nclass DefaultBitswap {\n    _libp2p;\n    _log;\n    stats;\n    network;\n    blockstore;\n    engine;\n    wm;\n    notifications;\n    started;\n    constructor(libp2p, blockstore, options = {}) {\n        this._libp2p = libp2p;\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.logger)(this.peerId);\n        options = Object.assign({}, defaultOptions, options);\n        // stats\n        this.stats = new _stats_index_js__WEBPACK_IMPORTED_MODULE_4__.Stats(libp2p, statsKeys, {\n            enabled: options.statsEnabled,\n            computeThrottleTimeout: options.statsComputeThrottleTimeout,\n            computeThrottleMaxQueueSize: options.statsComputeThrottleMaxQueueSize\n        });\n        // the network delivers messages\n        this.network = new _network_js__WEBPACK_IMPORTED_MODULE_5__.Network(libp2p, this, this.stats, {\n            hashLoader: options.hashLoader,\n            maxInboundStreams: options.maxInboundStreams,\n            maxOutboundStreams: options.maxOutboundStreams,\n            incomingStreamTimeout: options.incomingStreamTimeout\n        });\n        // local database\n        this.blockstore = blockstore;\n        this.engine = new _decision_engine_index_js__WEBPACK_IMPORTED_MODULE_6__.DecisionEngine(this.peerId, blockstore, this.network, this.stats, libp2p);\n        // handle message sending\n        this.wm = new _want_manager_index_js__WEBPACK_IMPORTED_MODULE_7__.WantManager(this.peerId, this.network, this.stats, libp2p);\n        this.notifications = new _notifications_js__WEBPACK_IMPORTED_MODULE_8__.Notifications(this.peerId);\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    get peerId() {\n        return this._libp2p.peerId;\n    }\n    /**\n     * handle messages received through the network\n     */\n    async _receiveMessage(peerId, incoming) {\n        try {\n            // Note: this allows the engine to respond to any wants in the message.\n            // Processing of the blocks in the message happens below, after the\n            // blocks have been added to the blockstore.\n            await this.engine.messageReceived(peerId, incoming);\n        }\n        catch (err) {\n            // Log instead of throwing an error so as to process as much as\n            // possible of the message. Currently `messageReceived` does not\n            // throw any errors, but this could change in the future.\n            this._log('failed to receive message', incoming);\n        }\n        if (incoming.blocks.size === 0) {\n            return;\n        }\n        /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n        const received = [];\n        for (const [cidStr, data] of incoming.blocks.entries()) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.parse(cidStr);\n            received.push({\n                wasWanted: this.wm.wantlist.contains(cid),\n                cid,\n                data\n            });\n        }\n        // quickly send out cancels, reduces chances of duplicate block receives\n        this.wm.cancelWants(received\n            .filter(({ wasWanted }) => wasWanted)\n            .map(({ cid }) => cid));\n        await Promise.all(received.map(async ({ cid, wasWanted, data }) => { await this._handleReceivedBlock(peerId, cid, data, wasWanted); }));\n    }\n    async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n        this._log('received block');\n        const has = await this.blockstore.has(cid);\n        this._updateReceiveCounters(peerId.toString(), cid, data, has);\n        if (!wasWanted) {\n            return;\n        }\n        await this.put(cid, data);\n    }\n    _updateReceiveCounters(peerIdStr, cid, data, exists) {\n        this.stats.push(peerIdStr, 'blocksReceived', 1);\n        this.stats.push(peerIdStr, 'dataReceived', data.length);\n        if (exists) {\n            this.stats.push(peerIdStr, 'dupBlksReceived', 1);\n            this.stats.push(peerIdStr, 'dupDataReceived', data.length);\n        }\n    }\n    /**\n     * handle errors on the receiving channel\n     */\n    _receiveError(err) {\n        this._log.error('ReceiveError', err);\n    }\n    /**\n     * handle new peers\n     */\n    _onPeerConnected(peerId) {\n        this.wm.connected(peerId);\n    }\n    /**\n     * handle peers being disconnected\n     */\n    _onPeerDisconnected(peerId) {\n        this.wm.disconnected(peerId);\n        this.engine.peerDisconnected(peerId);\n        this.stats.disconnected(peerId);\n    }\n    enableStats() {\n        this.stats.enable();\n    }\n    disableStats() {\n        this.stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     */\n    wantlistForPeer(peerId, _options) {\n        return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     */\n    ledgerForPeer(peerId) {\n        return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     */\n    async want(cid, options = {}) {\n        const fetchFromNetwork = async (cid, options) => {\n            // add it to the want list - n.b. later we will abort the AbortSignal\n            // so no need to remove the blocks from the wantlist after we have it\n            this.wm.wantBlocks([cid], options);\n            return this.notifications.wantBlock(cid, options);\n        };\n        let promptedNetwork = false;\n        const loadOrFetchFromNetwork = async (cid, options) => {\n            try {\n                // have to await here as we want to handle ERR_NOT_FOUND\n                const block = await this.blockstore.get(cid, options);\n                return block;\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n                if (!promptedNetwork) {\n                    promptedNetwork = true;\n                    this.network.findAndConnect(cid, options)\n                        .catch((err) => { this._log.error(err); });\n                }\n                // we don't have the block locally so fetch it from the network\n                return await fetchFromNetwork(cid, options);\n            }\n        };\n        // depending on implementation it's possible for blocks to come in while\n        // we do the async operations to get them from the blockstore leading to\n        // a race condition, so register for incoming block notifications as well\n        // as trying to get it from the datastore\n        const controller = new AbortController();\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_0__.anySignal)([controller.signal, options.signal]);\n        try {\n            const block = await Promise.race([\n                this.notifications.wantBlock(cid, {\n                    ...options,\n                    signal\n                }),\n                loadOrFetchFromNetwork(cid, {\n                    ...options,\n                    signal\n                })\n            ]);\n            return block;\n        }\n        finally {\n            // since we have the block we can now abort any outstanding attempts to\n            // fetch it\n            controller.abort();\n            signal.clear();\n        }\n    }\n    /**\n     * Removes the given CIDs from the wantlist independent of any ref counts.\n     *\n     * This will cause all outstanding promises for a given block to reject.\n     *\n     * If you want to cancel the want for a block without doing that, pass an\n     * AbortSignal in to `.get` or `.getMany` and abort it.\n     */\n    unwant(cids) {\n        const cidsArray = Array.isArray(cids) ? cids : [cids];\n        this.wm.unwantBlocks(cidsArray);\n        cidsArray.forEach((cid) => { this.notifications.unwantBlock(cid); });\n    }\n    /**\n     * Removes the given keys from the want list. This may cause pending promises\n     * for blocks to never resolve.  If you wish these promises to abort instead\n     * call `unwant(cids)` instead.\n     */\n    cancelWants(cids) {\n        this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     */\n    async put(cid, block, _options) {\n        await this.blockstore.put(cid, block);\n        this.notify(cid, block);\n    }\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     */\n    async *putMany(source, options) {\n        yield* this.blockstore.putMany((0,it_foreach__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(source, ({ cid, block }) => {\n            this.notify(cid, block);\n        }), options);\n    }\n    /**\n     * Sends notifications about the arrival of a block\n     */\n    notify(cid, block, options = {}) {\n        this.notifications.hasBlock(cid, block);\n        this.engine.receivedBlocks([{ cid, block }]);\n        // Note: Don't wait for provide to finish before returning\n        this.network.provide(cid, options).catch((err) => {\n            this._log.error('Failed to provide: %s', err.message);\n        });\n    }\n    /**\n     * Get the current list of wants\n     */\n    getWantlist() {\n        return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners\n     */\n    get peers() {\n        return this.engine.peers();\n    }\n    /**\n     * Start the bitswap node\n     */\n    async start() {\n        this.wm.start();\n        await this.network.start();\n        this.engine.start();\n        this.started = true;\n    }\n    /**\n     * Stop the bitswap node\n     */\n    async stop() {\n        this.stats.stop();\n        this.wm.stop();\n        await this.network.stop();\n        this.engine.stop();\n        this.started = false;\n    }\n}\n//# sourceMappingURL=bitswap.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/bitswap.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasBlockTimeout: () => (/* binding */ hasBlockTimeout),\n/* harmony export */   kMaxPriority: () => (/* binding */ kMaxPriority),\n/* harmony export */   maxListeners: () => (/* binding */ maxListeners),\n/* harmony export */   maxProvidersPerRequest: () => (/* binding */ maxProvidersPerRequest),\n/* harmony export */   provideTimeout: () => (/* binding */ provideTimeout),\n/* harmony export */   providerRequestTimeout: () => (/* binding */ providerRequestTimeout),\n/* harmony export */   wantlistSendDebounceMs: () => (/* binding */ wantlistSendDebounceMs)\n/* harmony export */ });\nconst SECOND = 1000;\nconst maxProvidersPerRequest = 3;\nconst providerRequestTimeout = 10 * SECOND;\nconst hasBlockTimeout = 15 * SECOND;\nconst provideTimeout = 15 * SECOND;\nconst kMaxPriority = Math.pow(2, 31) - 1;\nconst maxListeners = 1000;\nconst wantlistSendDebounceMs = 1;\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/constants.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecisionEngine: () => (/* binding */ DecisionEngine)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _wantlist_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../wantlist/index.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/index.js\");\n/* harmony import */ var _ledger_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ledger.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js\");\n/* harmony import */ var _req_queue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./req-queue.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js\");\n/* harmony import */ var _task_merger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./task-merger.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js\");\n\n\n\n\n\n\n\n\n\nconst WantType = _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.WantType;\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024;\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\nclass DecisionEngine {\n    _log;\n    blockstore;\n    network;\n    _stats;\n    _opts;\n    ledgerMap;\n    _running;\n    _requestQueue;\n    constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.logger)(peerId, 'engine');\n        this.blockstore = blockstore;\n        this.network = network;\n        this._stats = stats;\n        this._opts = this._processOpts(opts);\n        // A list of of ledgers by their partner id\n        this.ledgerMap = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_4__.trackedMap)({\n            name: 'ipfs_bitswap_ledger_map',\n            metrics: libp2p.metrics\n        });\n        this._running = false;\n        // Queue of want-have / want-block per peer\n        this._requestQueue = new _req_queue_js__WEBPACK_IMPORTED_MODULE_5__.RequestQueue(_task_merger_js__WEBPACK_IMPORTED_MODULE_6__.DefaultTaskMerger);\n    }\n    _processOpts(opts) {\n        return {\n            maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n            targetMessageSize: TARGET_MESSAGE_SIZE,\n            ...opts\n        };\n    }\n    _scheduleProcessTasks() {\n        setTimeout(() => {\n            this._processTasks().catch(err => {\n                this._log.error('error processing stats', err);\n            });\n        });\n    }\n    /**\n     * Pull tasks off the request queue and send a message to the corresponding\n     * peer\n     */\n    async _processTasks() {\n        if (!this._running) {\n            return;\n        }\n        const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);\n        if (tasks.length === 0) {\n            return;\n        }\n        // Create a new message\n        const msg = new _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage(false);\n        // Amount of data in the request queue still waiting to be popped\n        msg.setPendingBytes(pendingSize);\n        // Split out want-blocks, want-haves and DONT_HAVEs\n        const blockCids = [];\n        const blockTasks = new Map();\n        for (const task of tasks) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(task.topic);\n            if (task.data.haveBlock) {\n                if (task.data.isWantBlock) {\n                    blockCids.push(cid);\n                    blockTasks.set(task.topic, task.data);\n                }\n                else {\n                    // Add HAVES to the message\n                    msg.addHave(cid);\n                }\n            }\n            else {\n                // Add DONT_HAVEs to the message\n                msg.addDontHave(cid);\n            }\n        }\n        const blocks = await this._getBlocks(blockCids);\n        for (const [topic, taskData] of blockTasks) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(topic);\n            const blk = blocks.get(topic);\n            // If the block was found (it has not been removed)\n            if (blk != null) {\n                // Add the block to the message\n                msg.addBlock(cid, blk);\n            }\n            else {\n                // The block was not found. If the client requested DONT_HAVE,\n                // add DONT_HAVE to the message.\n                if (taskData.sendDontHave) {\n                    msg.addDontHave(cid);\n                }\n            }\n        }\n        // If there's nothing in the message, bail out\n        if (msg.empty) {\n            (peerId != null) && this._requestQueue.tasksDone(peerId, tasks);\n            // Trigger the next round of task processing\n            this._scheduleProcessTasks();\n            return;\n        }\n        try {\n            // Send the message\n            (peerId != null) && await this.network.sendMessage(peerId, msg);\n            // Peform sent message accounting\n            for (const [cidStr, block] of blocks.entries()) {\n                (peerId != null) && this.messageSent(peerId, multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(cidStr), block);\n            }\n        }\n        catch (err) {\n            this._log.error(err);\n        }\n        // Free the tasks up from the request queue\n        (peerId != null) && this._requestQueue.tasksDone(peerId, tasks);\n        // Trigger the next round of task processing\n        this._scheduleProcessTasks();\n    }\n    wantlistForPeer(peerId) {\n        const peerIdStr = peerId.toString();\n        const ledger = this.ledgerMap.get(peerIdStr);\n        return (ledger != null) ? ledger.wantlist.sortedEntries() : new Map();\n    }\n    ledgerForPeer(peerId) {\n        const peerIdStr = peerId.toString();\n        const ledger = this.ledgerMap.get(peerIdStr);\n        if (ledger == null) {\n            return undefined;\n        }\n        return {\n            peer: ledger.partner,\n            value: ledger.debtRatio(),\n            sent: ledger.accounting.bytesSent,\n            recv: ledger.accounting.bytesRecv,\n            exchanged: ledger.exchangeCount\n        };\n    }\n    peers() {\n        return Array.from(this.ledgerMap.values()).map((l) => l.partner);\n    }\n    /**\n     * Receive blocks either from an incoming message from the network, or from\n     * blocks being added by the client on the localhost (eg IPFS add)\n     */\n    receivedBlocks(blocks) {\n        if (blocks.length === 0) {\n            return;\n        }\n        // For each connected peer, check if it wants the block we received\n        for (const ledger of this.ledgerMap.values()) {\n            for (const { cid, block } of blocks) {\n                // Filter out blocks that we don't want\n                const want = ledger.wantlistContains(cid);\n                if (want == null) {\n                    continue;\n                }\n                // If the block is small enough, just send the block, even if the\n                // client asked for a HAVE\n                const blockSize = block.length;\n                const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n                let entrySize = blockSize;\n                if (!isWantBlock) {\n                    entrySize = _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.blockPresenceSize(want.cid);\n                }\n                this._requestQueue.pushTasks(ledger.partner, [{\n                        topic: want.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc),\n                        priority: want.priority,\n                        size: entrySize,\n                        data: {\n                            blockSize,\n                            isWantBlock,\n                            haveBlock: true,\n                            sendDontHave: false\n                        }\n                    }]);\n            }\n        }\n        this._scheduleProcessTasks();\n    }\n    /**\n     * Handle incoming messages\n     */\n    async messageReceived(peerId, msg) {\n        const ledger = this._findOrCreate(peerId);\n        if (msg.empty) {\n            return;\n        }\n        // If the message has a full wantlist, clear the current wantlist\n        if (msg.full) {\n            ledger.wantlist = new _wantlist_index_js__WEBPACK_IMPORTED_MODULE_7__.Wantlist();\n        }\n        // Record the amount of block data received\n        this._updateBlockAccounting(msg.blocks, ledger);\n        if (msg.wantlist.size === 0) {\n            this._scheduleProcessTasks();\n            return;\n        }\n        // Clear cancelled wants and add new wants to the ledger\n        const cancels = [];\n        const wants = [];\n        msg.wantlist.forEach((entry) => {\n            if (entry.cancel) {\n                ledger.cancelWant(entry.cid);\n                cancels.push(entry.cid);\n            }\n            else {\n                ledger.wants(entry.cid, entry.priority, entry.wantType);\n                wants.push(entry);\n            }\n        });\n        this._cancelWants(peerId, cancels);\n        await this._addWants(peerId, wants);\n        this._scheduleProcessTasks();\n    }\n    _cancelWants(peerId, cids) {\n        for (const c of cids) {\n            this._requestQueue.remove(c.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc), peerId);\n        }\n    }\n    async _addWants(peerId, wants) {\n        // Get the size of each wanted block\n        const blockSizes = await this._getBlockSizes(wants.map(w => w.cid));\n        const tasks = [];\n        for (const want of wants) {\n            const id = want.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n            const blockSize = blockSizes.get(id);\n            // If the block was not found\n            if (blockSize == null) {\n                // Only add the task to the queue if the requester wants a DONT_HAVE\n                if (want.sendDontHave) {\n                    tasks.push({\n                        topic: id,\n                        priority: want.priority,\n                        size: _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.blockPresenceSize(want.cid),\n                        data: {\n                            isWantBlock: want.wantType === WantType.Block,\n                            blockSize: 0,\n                            haveBlock: false,\n                            sendDontHave: want.sendDontHave\n                        }\n                    });\n                }\n            }\n            else {\n                // The block was found, add it to the queue\n                // If the block is small enough, just send the block, even if the\n                // client asked for a HAVE\n                const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n                // entrySize is the amount of space the entry takes up in the\n                // message we send to the recipient. If we're sending a block, the\n                // entrySize is the size of the block. Otherwise it's the size of\n                // a block presence entry.\n                let entrySize = blockSize;\n                if (!isWantBlock) {\n                    entrySize = _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.blockPresenceSize(want.cid);\n                }\n                tasks.push({\n                    topic: id,\n                    priority: want.priority,\n                    size: entrySize,\n                    data: {\n                        isWantBlock,\n                        blockSize,\n                        haveBlock: true,\n                        sendDontHave: want.sendDontHave\n                    }\n                });\n            }\n            this._requestQueue.pushTasks(peerId, tasks);\n        }\n    }\n    _sendAsBlock(wantType, blockSize) {\n        return wantType === WantType.Block ||\n            blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n    }\n    async _getBlockSizes(cids) {\n        const blocks = await this._getBlocks(cids);\n        return new Map([...blocks].map(([k, v]) => [k, v.length]));\n    }\n    async _getBlocks(cids) {\n        const res = new Map();\n        await Promise.all(cids.map(async (cid) => {\n            try {\n                const block = await this.blockstore.get(cid);\n                res.set(cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc), block);\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    this._log.error('failed to query blockstore for %s: %s', cid, err);\n                }\n            }\n        }));\n        return res;\n    }\n    _updateBlockAccounting(blocksMap, ledger) {\n        for (const block of blocksMap.values()) {\n            this._log('got block (%s bytes)', block.length);\n            ledger.receivedBytes(block.length);\n        }\n    }\n    /**\n     * Clear up all accounting things after message was sent\n     */\n    messageSent(peerId, cid, block) {\n        const ledger = this._findOrCreate(peerId);\n        ledger.sentBytes(block.length);\n        ledger.wantlist.remove(cid);\n    }\n    numBytesSentTo(peerId) {\n        return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n    numBytesReceivedFrom(peerId) {\n        return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n    peerDisconnected(peerId) {\n        this.ledgerMap.delete(peerId.toString());\n    }\n    _findOrCreate(peerId) {\n        const peerIdStr = peerId.toString();\n        const ledger = this.ledgerMap.get(peerIdStr);\n        if (ledger != null) {\n            return ledger;\n        }\n        const l = new _ledger_js__WEBPACK_IMPORTED_MODULE_8__.Ledger(peerId);\n        this.ledgerMap.set(peerIdStr, l);\n        if (this._stats != null) {\n            this._stats.push(peerIdStr, 'peerCount', 1);\n        }\n        return l;\n    }\n    start() {\n        this._running = true;\n    }\n    stop() {\n        this._running = false;\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ledger: () => (/* binding */ Ledger)\n/* harmony export */ });\n/* harmony import */ var _wantlist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wantlist/index.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/index.js\");\n\nclass Ledger {\n    partner;\n    wantlist;\n    exchangeCount;\n    accounting;\n    lastExchange;\n    constructor(peerId) {\n        this.partner = peerId;\n        this.wantlist = new _wantlist_index_js__WEBPACK_IMPORTED_MODULE_0__.Wantlist();\n        this.exchangeCount = 0;\n        this.accounting = {\n            bytesSent: 0,\n            bytesRecv: 0\n        };\n    }\n    sentBytes(n) {\n        this.exchangeCount++;\n        this.lastExchange = (new Date()).getTime();\n        this.accounting.bytesSent += n;\n    }\n    receivedBytes(n) {\n        this.exchangeCount++;\n        this.lastExchange = (new Date()).getTime();\n        this.accounting.bytesRecv += n;\n    }\n    wants(cid, priority, wantType) {\n        this.wantlist.add(cid, priority, wantType);\n    }\n    /**\n     * @param {CID} cid\n     * @returns {void}\n     */\n    cancelWant(cid) {\n        this.wantlist.remove(cid);\n    }\n    wantlistContains(cid) {\n        return this.wantlist.get(cid);\n    }\n    debtRatio() {\n        return (this.accounting.bytesSent / (this.accounting.bytesRecv + 1)); // +1 is to prevent division by zero\n    }\n}\n//# sourceMappingURL=ledger.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RequestQueue: () => (/* binding */ RequestQueue)\n/* harmony export */ });\n/* harmony import */ var _utils_sorted_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/sorted-map.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js\");\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n */\nconst DefaultTaskMerger = {\n    hasNewInfo() {\n        return false;\n    },\n    merge() { }\n};\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\nclass RequestQueue {\n    _taskMerger;\n    _byPeer;\n    constructor(taskMerger = DefaultTaskMerger) {\n        this._taskMerger = taskMerger;\n        this._byPeer = new _utils_sorted_map_js__WEBPACK_IMPORTED_MODULE_0__.SortedMap([], PeerTasks.compare);\n    }\n    /**\n     * Push tasks onto the queue for the given peer\n     */\n    pushTasks(peerId, tasks) {\n        let peerTasks = this._byPeer.get(peerId.toString());\n        if (peerTasks == null) {\n            peerTasks = new PeerTasks(peerId, this._taskMerger);\n        }\n        peerTasks.pushTasks(tasks);\n        this._byPeer.set(peerId.toString(), peerTasks);\n    }\n    /**\n     * Choose the peer with the least active work (or if all have the same active\n     * work, the most pending tasks) and pop off the highest priority tasks until\n     * the total size is at least targetMinBytes.\n     * This puts the popped tasks into the \"active\" state, meaning they are\n     * actively being processed (and cannot be modified).\n     */\n    popTasks(targetMinBytes) {\n        // Get the queue of tasks for the best peer and pop off tasks up to\n        // targetMinBytes\n        const peerTasks = this._head();\n        if (peerTasks === undefined) {\n            return { tasks: [], pendingSize: 0 };\n        }\n        const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);\n        if (tasks.length === 0) {\n            return { tasks, pendingSize };\n        }\n        const peerId = peerTasks.peerId;\n        if (peerTasks.isIdle()) {\n            // If there are no more tasks for the peer, free up its memory\n            this._byPeer.delete(peerId.toString());\n        }\n        else {\n            // If there are still tasks remaining, update the sort order of peerTasks\n            // (because it depends on the number of pending tasks)\n            this._byPeer.update(0);\n        }\n        return {\n            peerId, tasks, pendingSize\n        };\n    }\n    _head() {\n        // Shortcut\n        if (this._byPeer.size === 0) {\n            return undefined;\n        }\n        // eslint-disable-next-line no-unreachable-loop\n        for (const [, v] of this._byPeer) {\n            return v;\n        }\n        return undefined;\n    }\n    /**\n     * Remove the task with the given topic for the given peer.\n     */\n    remove(topic, peerId) {\n        const peerTasks = this._byPeer.get(peerId.toString());\n        peerTasks?.remove(topic);\n    }\n    /**\n     * Called when the tasks for the given peer complete.\n     */\n    tasksDone(peerId, tasks) {\n        const peerTasks = this._byPeer.get(peerId.toString());\n        if (peerTasks == null) {\n            return;\n        }\n        const i = this._byPeer.indexOf(peerId.toString());\n        for (const task of tasks) {\n            peerTasks.taskDone(task);\n        }\n        // Marking the tasks as done takes them out of the \"active\" state, and the\n        // sort order depends on the size of the active tasks, so we need to update\n        // the order.\n        this._byPeer.update(i);\n    }\n}\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\nclass PeerTasks {\n    peerId;\n    _taskMerger;\n    _activeTotalSize;\n    _pending;\n    _active;\n    constructor(peerId, taskMerger) {\n        this.peerId = peerId;\n        this._taskMerger = taskMerger;\n        this._activeTotalSize = 0;\n        this._pending = new PendingTasks();\n        this._active = new Set();\n    }\n    /**\n     * Push tasks onto the queue\n     */\n    pushTasks(tasks) {\n        for (const t of tasks) {\n            this._pushTask(t);\n        }\n    }\n    _pushTask(task) {\n        // If the new task doesn't add any more information over what we\n        // already have in the active queue, then we can skip the new task\n        if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n            return;\n        }\n        // If there is already a non-active (pending) task with this topic\n        const existingTask = this._pending.get(task.topic);\n        if (existingTask != null) {\n            // If the new task has a higher priority than the old task,\n            if (task.priority > existingTask.priority) {\n                // Update the priority and the task's position in the queue\n                this._pending.updatePriority(task.topic, task.priority);\n            }\n            // Merge the information from the new task into the existing task\n            this._taskMerger.merge(task, existingTask);\n            // A task with the topic exists, so we don't need to add\n            // the new task to the queue\n            return;\n        }\n        // Push the new task onto the queue\n        this._pending.add(task);\n    }\n    /**\n     * Indicates whether the new task adds any more information over tasks that are\n     * already in the active task queue\n     */\n    _taskHasMoreInfoThanActiveTasks(task) {\n        const tasksWithTopic = [];\n        for (const activeTask of this._active) {\n            if (activeTask.topic === task.topic) {\n                tasksWithTopic.push(activeTask);\n            }\n        }\n        // No tasks with that topic, so the new task adds information\n        if (tasksWithTopic.length === 0) {\n            return true;\n        }\n        return this._taskMerger.hasNewInfo(task, tasksWithTopic);\n    }\n    /**\n     * Pop tasks off the queue such that the total size is at least targetMinBytes\n     */\n    popTasks(targetMinBytes) {\n        let size = 0;\n        const tasks = [];\n        // Keep popping tasks until we get up to targetMinBytes (or one item over\n        // targetMinBytes)\n        const pendingTasks = this._pending.tasks();\n        for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n            const task = pendingTasks[i];\n            tasks.push(task);\n            size += task.size;\n            // Move tasks from pending to active\n            this._pending.delete(task.topic);\n            this._activeTotalSize += task.size;\n            this._active.add(task);\n        }\n        return {\n            tasks, pendingSize: this._pending.totalSize\n        };\n    }\n    /**\n     * Called when a task completes.\n     * Note: must be the same reference as returned from popTasks.\n     */\n    taskDone(task) {\n        if (this._active.has(task)) {\n            this._activeTotalSize -= task.size;\n            this._active.delete(task);\n        }\n    }\n    /**\n     * Remove pending tasks with the given topic\n     */\n    remove(topic) {\n        this._pending.delete(topic);\n    }\n    /**\n     * No work to be done, this PeerTasks object can be freed.\n     */\n    isIdle() {\n        return this._pending.length === 0 && this._active.size === 0;\n    }\n    /**\n     * Compare PeerTasks\n     */\n    static compare(a, b) {\n        // Move peers with no pending tasks to the back of the queue\n        if (a[1]._pending.length === 0) {\n            return 1;\n        }\n        if (b[1]._pending.length === 0) {\n            return -1;\n        }\n        // If the amount of active work is the same\n        if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n            // Choose the peer with the most pending work\n            return b[1]._pending.length - a[1]._pending.length;\n        }\n        // Choose the peer with the least amount of active work (\"keep peers busy\")\n        return a[1]._activeTotalSize - b[1]._activeTotalSize;\n    }\n}\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\nclass PendingTasks {\n    _tasks;\n    constructor() {\n        this._tasks = new _utils_sorted_map_js__WEBPACK_IMPORTED_MODULE_0__.SortedMap([], this._compare);\n    }\n    get length() {\n        return this._tasks.size;\n    }\n    /**\n     * Sum of the size of all pending tasks\n     **/\n    get totalSize() {\n        return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);\n    }\n    get(topic) {\n        return this._tasks?.get(topic)?.task;\n    }\n    add(task) {\n        this._tasks.set(task.topic, {\n            created: Date.now(),\n            task\n        });\n    }\n    delete(topic) {\n        this._tasks.delete(topic);\n    }\n    // All pending tasks, in priority order\n    tasks() {\n        return [...this._tasks.values()].map(i => i.task);\n    }\n    /**\n     * Update the priority of the task with the given topic, and update the order\n     **/\n    updatePriority(topic, priority) {\n        const obj = this._tasks.get(topic);\n        if (obj == null) {\n            return;\n        }\n        const i = this._tasks.indexOf(topic);\n        obj.task.priority = priority;\n        this._tasks.update(i);\n    }\n    /**\n     * Sort by priority desc then FIFO\n     */\n    _compare(a, b) {\n        if (a[1].task.priority === b[1].task.priority) {\n            // FIFO\n            return a[1].created - b[1].created;\n        }\n        // Priority high -> low\n        return b[1].task.priority - a[1].task.priority;\n    }\n}\n//# sourceMappingURL=req-queue.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultTaskMerger: () => (/* binding */ DefaultTaskMerger)\n/* harmony export */ });\nconst DefaultTaskMerger = {\n    /**\n     * Indicates whether the given task has newer information than the active\n     * tasks with the same topic.\n     *\n     * @param {Task} task\n     * @param {Task[]} tasksWithTopic\n     * @returns {boolean}\n     */\n    hasNewInfo(task, tasksWithTopic) {\n        let haveBlock = false;\n        let isWantBlock = false;\n        for (const existing of tasksWithTopic) {\n            if (existing.data.haveBlock) {\n                haveBlock = true;\n            }\n            if (existing.data.isWantBlock) {\n                isWantBlock = true;\n            }\n        }\n        // If there is no active want-block and the new task is a want-block,\n        // the new task is better\n        if (!isWantBlock && task.data.isWantBlock) {\n            return true;\n        }\n        // If we didn't have the block, and the new task indicates that we now\n        // do have the block, then we must also have size information for the\n        // block, so the new task has new information.\n        if (!haveBlock && task.data.haveBlock) {\n            return true;\n        }\n        return false;\n    },\n    /**\n     * Merge the information from the given task into the existing task (with the\n     * same topic)\n     */\n    merge(newTask, existingTask) {\n        // The merge function ignores the topic and priority as these don't change.\n        //\n        // We may receive new information about a want before the want has been\n        // popped from the queue in the following scenarios:\n        //\n        // - Replace want type:\n        //   1. Client sends want-have CID1\n        //   2. Client sends want-block CID1\n        //   In this case we should replace want-have with want-block, including\n        //   updating the task size to be the block size.\n        //\n        // - Replace DONT_HAVE with want:\n        //   1. Client sends want-have CID1 or want-block CID1\n        //   2. Local node doesn't have block for CID1\n        //   3. Local node receives block for CID1 from peer\n        //   In this case we should replace DONT_HAVE with the want, including\n        //   updating the task size and block size.\n        const taskData = newTask.data;\n        const existingData = existingTask.data;\n        // If we didn't have block size information (because we didn't have the\n        // block) and we receive the block from a peer, update the task with the\n        // new block size\n        if (!existingData.haveBlock && taskData.haveBlock) {\n            existingData.haveBlock = taskData.haveBlock;\n            existingData.blockSize = taskData.blockSize;\n        }\n        // If replacing a want-have with a want-block\n        if (!existingData.isWantBlock && taskData.isWantBlock) {\n            // Change the type from want-have to want-block\n            existingData.isWantBlock = true;\n            // If the want-have was a DONT_HAVE, or the want-block has a size\n            if (!existingData.haveBlock || taskData.haveBlock) {\n                // Update the entry size\n                existingData.haveBlock = taskData.haveBlock;\n                existingTask.size = newTask.size;\n            }\n        }\n        // If the task is a want-block, make sure the entry size is equal\n        // to the block size (because we will send the whole block)\n        if (existingData.isWantBlock && existingData.haveBlock) {\n            existingTask.size = existingData.blockSize;\n        }\n    }\n};\n//# sourceMappingURL=task-merger.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBitswap: () => (/* binding */ createBitswap)\n/* harmony export */ });\n/* harmony import */ var _bitswap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitswap.js */ \"./node_modules/ipfs-bitswap/dist/src/bitswap.js\");\n/**\n * @packageDocumentation\n *\n * This module implements the [Bitswap protocol](https://docs.ipfs.tech/concepts/bitswap/) in TypeScript.\n */\n\nconst createBitswap = (libp2p, blockstore, options = {}) => {\n    return new _bitswap_js__WEBPACK_IMPORTED_MODULE_0__.DefaultBitswap(libp2p, blockstore, options);\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/message/entry.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/message/entry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitswapMessageEntry: () => (/* binding */ BitswapMessageEntry)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _wantlist_entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wantlist/entry.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js\");\n\n\nclass BitswapMessageEntry {\n    entry;\n    cancel;\n    sendDontHave;\n    constructor(cid, priority, wantType, cancel, sendDontHave) {\n        this.entry = new _wantlist_entry_js__WEBPACK_IMPORTED_MODULE_1__.WantListEntry(cid, priority, wantType);\n        this.cancel = Boolean(cancel);\n        this.sendDontHave = Boolean(sendDontHave);\n    }\n    get cid() {\n        return this.entry.cid;\n    }\n    set cid(cid) {\n        this.entry.cid = cid;\n    }\n    get priority() {\n        return this.entry.priority;\n    }\n    set priority(val) {\n        this.entry.priority = val;\n    }\n    get wantType() {\n        return this.entry.wantType;\n    }\n    set wantType(val) {\n        this.entry.wantType = val;\n    }\n    get [Symbol.toStringTag]() {\n        const cidStr = this.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;\n    }\n    equals(other) {\n        return (this.cancel === other.cancel) &&\n            (this.sendDontHave === other.sendDontHave) &&\n            (this.wantType === other.wantType) &&\n            this.entry.equals(other.entry);\n    }\n}\n//# sourceMappingURL=entry.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/message/entry.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/message/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/message/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitswapMessage: () => (/* binding */ BitswapMessage)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var varint_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! varint-decoder */ \"./node_modules/varint-decoder/src/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _utils_varint_encoder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/varint-encoder.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entry.js */ \"./node_modules/ipfs-bitswap/dist/src/message/entry.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message.js */ \"./node_modules/ipfs-bitswap/dist/src/message/message.js\");\n\n\n\n\n// @ts-expect-error no types\n\n\n\n\n\nclass BitswapMessage {\n    static Entry = _entry_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessageEntry;\n    static WantType = {\n        Block: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.Wantlist.WantType.Block,\n        Have: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.Wantlist.WantType.Have\n    };\n    static BlockPresenceType = {\n        Have: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.BlockPresenceType.Have,\n        DontHave: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.BlockPresenceType.DontHave\n    };\n    static deserialize = async (raw, hashLoader) => {\n        const decoded = _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.decode(raw);\n        const isFull = decoded.wantlist?.full === true;\n        const msg = new BitswapMessage(isFull);\n        decoded.wantlist?.entries.forEach((entry) => {\n            if (entry.block == null) {\n                return;\n            }\n            // note: entry.block is the CID here\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(entry.block);\n            msg.addEntry(cid, entry.priority ?? 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n        });\n        decoded.blockPresences.forEach((blockPresence) => {\n            if (blockPresence.cid == null) {\n                return;\n            }\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(blockPresence.cid);\n            if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                msg.addHave(cid);\n            }\n            else {\n                msg.addDontHave(cid);\n            }\n        });\n        // Bitswap 1.0.0\n        // decoded.blocks are just the byte arrays\n        if (decoded.blocks.length > 0) {\n            await Promise.all(decoded.blocks.map(async (b) => {\n                const hash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(b);\n                const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.createV0(hash);\n                msg.addBlock(cid, b);\n            }));\n            return msg;\n        }\n        // Bitswap 1.1.0\n        if (decoded.payload.length > 0) {\n            await Promise.all(decoded.payload.map(async (p) => {\n                if (p.prefix == null || p.data == null) {\n                    return;\n                }\n                const values = varint_decoder__WEBPACK_IMPORTED_MODULE_3__(p.prefix);\n                const cidVersion = values[0];\n                const multicodec = values[1];\n                const hashAlg = values[2];\n                const hasher = hashAlg === multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.code ? multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256 : await hashLoader?.getHasher(hashAlg);\n                if (hasher == null) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG');\n                }\n                // const hashLen = values[3] // We haven't need to use this so far\n                const hash = await hasher.digest(p.data);\n                const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.create(cidVersion, multicodec, hash);\n                msg.addBlock(cid, p.data);\n            }));\n            msg.setPendingBytes(decoded.pendingBytes);\n            return msg;\n        }\n        return msg;\n    };\n    static blockPresenceSize = (cid) => {\n        // It's ok if this is not exactly right: it's used to estimate the size of\n        // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n        // plenty of padding under the maximum message size.\n        // (It's more important for this to be fast).\n        return cid.bytes.length + 1;\n    };\n    full;\n    wantlist;\n    blocks;\n    blockPresences;\n    pendingBytes;\n    constructor(full) {\n        this.full = full;\n        this.wantlist = new Map();\n        this.blocks = new Map();\n        this.blockPresences = new Map();\n        this.pendingBytes = 0;\n    }\n    get empty() {\n        return this.blocks.size === 0 &&\n            this.wantlist.size === 0 &&\n            this.blockPresences.size === 0;\n    }\n    addEntry(cid, priority, wantType, cancel, sendDontHave) {\n        if (wantType == null) {\n            wantType = BitswapMessage.WantType.Block;\n        }\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        const entry = this.wantlist.get(cidStr);\n        if (entry != null) {\n            // Only change priority if want is of the same type\n            if (entry.wantType === wantType) {\n                entry.priority = priority;\n            }\n            // Only change from \"dont cancel\" to \"do cancel\"\n            if (cancel === true) {\n                entry.cancel = Boolean(cancel);\n            }\n            // Only change from \"dont send\" to \"do send\" DONT_HAVE\n            if (sendDontHave === true) {\n                entry.sendDontHave = Boolean(sendDontHave);\n            }\n            // want-block overrides existing want-have\n            if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n                entry.wantType = wantType;\n            }\n        }\n        else {\n            this.wantlist.set(cidStr, new _entry_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));\n        }\n    }\n    addBlock(cid, block) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        this.blocks.set(cidStr, block);\n    }\n    addHave(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        if (!this.blockPresences.has(cidStr)) {\n            this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n        }\n    }\n    addDontHave(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        if (!this.blockPresences.has(cidStr)) {\n            this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n        }\n    }\n    cancel(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        this.wantlist.delete(cidStr);\n        this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n    setPendingBytes(size) {\n        this.pendingBytes = size;\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     */\n    serializeToBitswap100() {\n        return _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.encode({\n            wantlist: {\n                entries: Array.from(this.wantlist.values()).map((entry) => {\n                    return {\n                        block: entry.cid.bytes, // cid\n                        priority: Number(entry.priority),\n                        cancel: Boolean(entry.cancel),\n                        wantType: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.Wantlist.WantType.Block,\n                        sendDontHave: false\n                    };\n                }),\n                full: Boolean(this.full)\n            },\n            blocks: Array.from(this.blocks.values())\n        });\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     */\n    serializeToBitswap110() {\n        const msg = {\n            wantlist: {\n                entries: Array.from(this.wantlist.values()).map((entry) => {\n                    return {\n                        block: entry.cid.bytes, // cid\n                        priority: Number(entry.priority),\n                        wantType: entry.wantType,\n                        cancel: Boolean(entry.cancel),\n                        sendDontHave: Boolean(entry.sendDontHave)\n                    };\n                }),\n                full: Boolean(this.full)\n            },\n            blockPresences: [],\n            payload: [],\n            pendingBytes: this.pendingBytes,\n            blocks: []\n        };\n        for (const [cidStr, data] of this.blocks.entries()) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(cidStr);\n            const version = cid.version;\n            const codec = cid.code;\n            const multihash = cid.multihash.code;\n            const digestLength = cid.multihash.digest.length;\n            const prefix = (0,_utils_varint_encoder_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])([\n                version, codec, multihash, digestLength\n            ]);\n            msg.payload.push({\n                prefix,\n                data\n            });\n        }\n        for (const [cidStr, bpType] of this.blockPresences) {\n            msg.blockPresences.push({\n                cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(cidStr).bytes,\n                type: bpType\n            });\n        }\n        if (this.pendingBytes > 0) {\n            msg.pendingBytes = this.pendingBytes;\n        }\n        return _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.encode(msg);\n    }\n    equals(other) {\n        if (this.full !== other.full ||\n            this.pendingBytes !== other.pendingBytes ||\n            !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.isMapEqual)(this.wantlist, other.wantlist) ||\n            !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.isMapEqual)(this.blocks, other.blocks) ||\n            // @TODO - Is this a bug ?\n            // @ts-expect-error - isMap equals map values to be objects not numbers\n            !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.isMapEqual)(this.blockPresences, other.blockPresences)) {\n            return false;\n        }\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        const list = Array.from(this.wantlist.keys());\n        const blocks = Array.from(this.blocks.keys());\n        return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/message/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/message/message.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/message/message.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Message: () => (/* binding */ Message)\n/* harmony export */ });\n/* harmony import */ var protons_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protons-runtime */ \"./node_modules/protons-runtime/dist/src/index.js\");\n/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nvar Message;\n(function (Message) {\n    let Wantlist;\n    (function (Wantlist) {\n        let WantType;\n        (function (WantType) {\n            WantType[\"Block\"] = \"Block\";\n            WantType[\"Have\"] = \"Have\";\n        })(WantType = Wantlist.WantType || (Wantlist.WantType = {}));\n        let __WantTypeValues;\n        (function (__WantTypeValues) {\n            __WantTypeValues[__WantTypeValues[\"Block\"] = 0] = \"Block\";\n            __WantTypeValues[__WantTypeValues[\"Have\"] = 1] = \"Have\";\n        })(__WantTypeValues || (__WantTypeValues = {}));\n        (function (WantType) {\n            WantType.codec = () => {\n                return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__WantTypeValues);\n            };\n        })(WantType = Wantlist.WantType || (Wantlist.WantType = {}));\n        let Entry;\n        (function (Entry) {\n            let _codec;\n            Entry.codec = () => {\n                if (_codec == null) {\n                    _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                        if (opts.lengthDelimited !== false) {\n                            w.fork();\n                        }\n                        if ((obj.block != null && obj.block.byteLength > 0)) {\n                            w.uint32(10);\n                            w.bytes(obj.block);\n                        }\n                        if ((obj.priority != null && obj.priority !== 0)) {\n                            w.uint32(16);\n                            w.int32(obj.priority);\n                        }\n                        if ((obj.cancel != null && obj.cancel !== false)) {\n                            w.uint32(24);\n                            w.bool(obj.cancel);\n                        }\n                        if (obj.wantType != null && __WantTypeValues[obj.wantType] !== 0) {\n                            w.uint32(32);\n                            Message.Wantlist.WantType.codec().encode(obj.wantType, w);\n                        }\n                        if ((obj.sendDontHave != null && obj.sendDontHave !== false)) {\n                            w.uint32(40);\n                            w.bool(obj.sendDontHave);\n                        }\n                        if (opts.lengthDelimited !== false) {\n                            w.ldelim();\n                        }\n                    }, (reader, length) => {\n                        const obj = {\n                            block: new Uint8Array(0),\n                            priority: 0,\n                            cancel: false,\n                            wantType: WantType.Block,\n                            sendDontHave: false\n                        };\n                        const end = length == null ? reader.len : reader.pos + length;\n                        while (reader.pos < end) {\n                            const tag = reader.uint32();\n                            switch (tag >>> 3) {\n                                case 1:\n                                    obj.block = reader.bytes();\n                                    break;\n                                case 2:\n                                    obj.priority = reader.int32();\n                                    break;\n                                case 3:\n                                    obj.cancel = reader.bool();\n                                    break;\n                                case 4:\n                                    obj.wantType = Message.Wantlist.WantType.codec().decode(reader);\n                                    break;\n                                case 5:\n                                    obj.sendDontHave = reader.bool();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                            }\n                        }\n                        return obj;\n                    });\n                }\n                return _codec;\n            };\n            Entry.encode = (obj) => {\n                return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Entry.codec());\n            };\n            Entry.decode = (buf) => {\n                return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Entry.codec());\n            };\n        })(Entry = Wantlist.Entry || (Wantlist.Entry = {}));\n        let _codec;\n        Wantlist.codec = () => {\n            if (_codec == null) {\n                _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if (obj.entries != null) {\n                        for (const value of obj.entries) {\n                            w.uint32(10);\n                            Message.Wantlist.Entry.codec().encode(value, w);\n                        }\n                    }\n                    if ((obj.full != null && obj.full !== false)) {\n                        w.uint32(16);\n                        w.bool(obj.full);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        entries: [],\n                        full: false\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.entries.push(Message.Wantlist.Entry.codec().decode(reader, reader.uint32()));\n                                break;\n                            case 2:\n                                obj.full = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Wantlist.encode = (obj) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Wantlist.codec());\n        };\n        Wantlist.decode = (buf) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Wantlist.codec());\n        };\n    })(Wantlist = Message.Wantlist || (Message.Wantlist = {}));\n    let Block;\n    (function (Block) {\n        let _codec;\n        Block.codec = () => {\n            if (_codec == null) {\n                _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.prefix != null && obj.prefix.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.prefix);\n                    }\n                    if ((obj.data != null && obj.data.byteLength > 0)) {\n                        w.uint32(18);\n                        w.bytes(obj.data);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        prefix: new Uint8Array(0),\n                        data: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.prefix = reader.bytes();\n                                break;\n                            case 2:\n                                obj.data = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Block.encode = (obj) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Block.codec());\n        };\n        Block.decode = (buf) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Block.codec());\n        };\n    })(Block = Message.Block || (Message.Block = {}));\n    let BlockPresenceType;\n    (function (BlockPresenceType) {\n        BlockPresenceType[\"Have\"] = \"Have\";\n        BlockPresenceType[\"DontHave\"] = \"DontHave\";\n    })(BlockPresenceType = Message.BlockPresenceType || (Message.BlockPresenceType = {}));\n    let __BlockPresenceTypeValues;\n    (function (__BlockPresenceTypeValues) {\n        __BlockPresenceTypeValues[__BlockPresenceTypeValues[\"Have\"] = 0] = \"Have\";\n        __BlockPresenceTypeValues[__BlockPresenceTypeValues[\"DontHave\"] = 1] = \"DontHave\";\n    })(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));\n    (function (BlockPresenceType) {\n        BlockPresenceType.codec = () => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__BlockPresenceTypeValues);\n        };\n    })(BlockPresenceType = Message.BlockPresenceType || (Message.BlockPresenceType = {}));\n    let BlockPresence;\n    (function (BlockPresence) {\n        let _codec;\n        BlockPresence.codec = () => {\n            if (_codec == null) {\n                _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.cid != null && obj.cid.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.cid);\n                    }\n                    if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {\n                        w.uint32(16);\n                        Message.BlockPresenceType.codec().encode(obj.type, w);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        cid: new Uint8Array(0),\n                        type: BlockPresenceType.Have\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.cid = reader.bytes();\n                                break;\n                            case 2:\n                                obj.type = Message.BlockPresenceType.codec().decode(reader);\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        BlockPresence.encode = (obj) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, BlockPresence.codec());\n        };\n        BlockPresence.decode = (buf) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, BlockPresence.codec());\n        };\n    })(BlockPresence = Message.BlockPresence || (Message.BlockPresence = {}));\n    let _codec;\n    Message.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.wantlist != null) {\n                    w.uint32(10);\n                    Message.Wantlist.codec().encode(obj.wantlist, w);\n                }\n                if (obj.blocks != null) {\n                    for (const value of obj.blocks) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (obj.payload != null) {\n                    for (const value of obj.payload) {\n                        w.uint32(26);\n                        Message.Block.codec().encode(value, w);\n                    }\n                }\n                if (obj.blockPresences != null) {\n                    for (const value of obj.blockPresences) {\n                        w.uint32(34);\n                        Message.BlockPresence.codec().encode(value, w);\n                    }\n                }\n                if ((obj.pendingBytes != null && obj.pendingBytes !== 0)) {\n                    w.uint32(40);\n                    w.int32(obj.pendingBytes);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    blocks: [],\n                    payload: [],\n                    blockPresences: [],\n                    pendingBytes: 0\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.wantlist = Message.Wantlist.codec().decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            obj.blocks.push(reader.bytes());\n                            break;\n                        case 3:\n                            obj.payload.push(Message.Block.codec().decode(reader, reader.uint32()));\n                            break;\n                        case 4:\n                            obj.blockPresences.push(Message.BlockPresence.codec().decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            obj.pendingBytes = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Message.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Message.codec());\n    };\n    Message.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Message.codec());\n    };\n})(Message || (Message = {}));\n//# sourceMappingURL=message.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/message/message.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/network.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/network.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_length_prefixed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-length-prefixed */ \"./node_modules/it-length-prefixed/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var it_take__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-take */ \"./node_modules/it-take/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var timeout_abort_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! timeout-abort-controller */ \"./node_modules/timeout-abort-controller/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\nconst DEFAULT_MAX_INBOUND_STREAMS = 1024;\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 1024;\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000;\nclass Network {\n    _log;\n    _libp2p;\n    _bitswap;\n    _protocols;\n    _stats;\n    _running;\n    _hashLoader;\n    _maxInboundStreams;\n    _maxOutboundStreams;\n    _incomingStreamTimeout;\n    _registrarIds;\n    constructor(libp2p, bitswap, stats, options = {}) {\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.logger)(libp2p.peerId, 'network');\n        this._libp2p = libp2p;\n        this._bitswap = bitswap;\n        this._protocols = [BITSWAP100];\n        if (options.b100Only !== true) {\n            // Latest bitswap first\n            this._protocols.unshift(BITSWAP110);\n            this._protocols.unshift(BITSWAP120);\n        }\n        this._stats = stats;\n        this._running = false;\n        // bind event listeners\n        this._onPeerConnect = this._onPeerConnect.bind(this);\n        this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n        this._onConnection = this._onConnection.bind(this);\n        this._hashLoader = options.hashLoader ?? {\n            async getHasher() {\n                throw new Error('Not implemented');\n            }\n        };\n        this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;\n        this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n        this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;\n    }\n    async start() {\n        this._running = true;\n        await this._libp2p.handle(this._protocols, this._onConnection, {\n            maxInboundStreams: this._maxInboundStreams,\n            maxOutboundStreams: this._maxOutboundStreams\n        });\n        // register protocol with topology\n        const topology = {\n            onConnect: this._onPeerConnect,\n            onDisconnect: this._onPeerDisconnect\n        };\n        /** @type {string[]} */\n        this._registrarIds = [];\n        for (const protocol of this._protocols) {\n            this._registrarIds.push(await this._libp2p.register(protocol, topology));\n        }\n        // All existing connections are like new ones for us\n        this._libp2p.getConnections().forEach(conn => {\n            this._onPeerConnect(conn.remotePeer);\n        });\n    }\n    async stop() {\n        this._running = false;\n        // Unhandle both, libp2p doesn't care if it's not already handled\n        await this._libp2p.unhandle(this._protocols);\n        // unregister protocol and handlers\n        if (this._registrarIds != null) {\n            for (const id of this._registrarIds) {\n                this._libp2p.unregister(id);\n            }\n            this._registrarIds = [];\n        }\n    }\n    /**\n     * Handles both types of incoming bitswap messages\n     */\n    _onConnection(info) {\n        if (!this._running) {\n            return;\n        }\n        const { stream, connection } = info;\n        const controller = new timeout_abort_controller__WEBPACK_IMPORTED_MODULE_6__.TimeoutController(this._incomingStreamTimeout);\n        Promise.resolve().then(async () => {\n            this._log('incoming new bitswap %s connection from %p', stream.protocol, connection.remotePeer);\n            const abortListener = () => {\n                stream.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('Incoming Bitswap stream timed out', 'ERR_TIMEOUT'));\n            };\n            let signal = AbortSignal.timeout(this._incomingStreamTimeout);\n            signal.addEventListener('abort', abortListener);\n            await (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)(stream, (source) => it_length_prefixed__WEBPACK_IMPORTED_MODULE_1__.decode(source), async (source) => {\n                for await (const data of source) {\n                    try {\n                        const message = await _message_index_js__WEBPACK_IMPORTED_MODULE_9__.BitswapMessage.deserialize(data.subarray(), this._hashLoader);\n                        await this._bitswap._receiveMessage(connection.remotePeer, message);\n                    }\n                    catch (err) {\n                        this._bitswap._receiveError(err);\n                        break;\n                    }\n                    // we have received some data so reset the timeout controller\n                    signal.removeEventListener('abort', abortListener);\n                    signal = AbortSignal.timeout(this._incomingStreamTimeout);\n                    signal.addEventListener('abort', abortListener);\n                }\n            });\n            await stream.close({\n                signal\n            });\n        })\n            .catch(err => {\n            this._log(err);\n            stream.abort(err);\n        })\n            .finally(() => {\n            controller.clear();\n        });\n    }\n    _onPeerConnect(peerId) {\n        this._bitswap._onPeerConnected(peerId);\n    }\n    _onPeerDisconnect(peerId) {\n        this._bitswap._onPeerDisconnected(peerId);\n    }\n    /**\n     * Find providers given a `cid`.\n     */\n    findProviders(cid, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:find-providers', cid));\n        return this._libp2p.contentRouting.findProviders(cid, options);\n    }\n    /**\n     * Find the providers of a given `cid` and connect to them.\n     */\n    async findAndConnect(cid, options) {\n        await (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,it_take__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,it_map__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.findProviders(cid, options), async (provider) => this.connectTo(provider.id, options)\n            .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err);\n        })), _constants_js__WEBPACK_IMPORTED_MODULE_10__.maxProvidersPerRequest))\n            .catch(err => {\n            this._log.error(err);\n        });\n    }\n    /**\n     * Tell the network we can provide content for the passed CID\n     */\n    async provide(cid, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:provide', cid));\n        await this._libp2p.contentRouting.provide(cid, options);\n    }\n    /**\n     * Connect to the given peer\n     * Send the given msg (instance of Message) to the given peer\n     */\n    async sendMessage(peer, msg, options = {}) {\n        if (!this._running)\n            throw new Error('network isn\\'t running');\n        const stringId = peer.toString();\n        this._log('sendMessage to %s', stringId, msg);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:send-wantlist', peer));\n        await this._writeMessage(peer, msg, options);\n        this._updateSentStats(peer, msg.blocks);\n    }\n    /**\n     * Connects to another peer\n     */\n    async connectTo(peer, options = {}) {\n        if (!this._running) {\n            throw new Error('network isn\\'t running');\n        }\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:dial', peer));\n        return this._libp2p.dial(peer, options);\n    }\n    _updateSentStats(peer, blocks) {\n        const peerId = peer.toString();\n        if (this._stats != null) {\n            for (const block of blocks.values()) {\n                this._stats.push(peerId, 'dataSent', block.length);\n            }\n            this._stats.push(peerId, 'blocksSent', blocks.size);\n        }\n    }\n    async _writeMessage(peerId, msg, options = {}) {\n        const stream = await this._libp2p.dialProtocol(peerId, [BITSWAP120, BITSWAP110, BITSWAP100]);\n        try {\n            /** @type {Uint8Array} */\n            let serialized;\n            switch (stream.protocol) {\n                case BITSWAP100:\n                    serialized = msg.serializeToBitswap100();\n                    break;\n                case BITSWAP110:\n                case BITSWAP120:\n                    serialized = msg.serializeToBitswap110();\n                    break;\n                default:\n                    throw new Error(`Unknown protocol: ${stream.protocol}`);\n            }\n            await (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)([serialized], (source) => it_length_prefixed__WEBPACK_IMPORTED_MODULE_1__.encode(source), stream);\n            await stream.close();\n        }\n        catch (err) {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:send-wantlist:error', { peer: peerId, error: err }));\n            this._log(err);\n            stream.abort(err);\n        }\n    }\n}\n//# sourceMappingURL=network.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/network.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/notifications.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/notifications.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Notifications: () => (/* binding */ Notifications)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n\n\n\n\n\nconst unwantEvent = (cid) => `unwant:${(0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(cid.multihash.bytes, 'base64')}`;\nconst blockEvent = (cid) => `block:${(0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(cid.multihash.bytes, 'base64')}`;\nclass Notifications extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    _log;\n    /**\n     * Internal module used to track events about incoming blocks,\n     * wants and unwants.\n     */\n    constructor(peerId) {\n        super();\n        this.setMaxListeners(_constants_js__WEBPACK_IMPORTED_MODULE_3__.maxListeners);\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.logger)(peerId, 'notif');\n    }\n    /**\n     * Signal the system that we received `block`.\n     */\n    hasBlock(cid, block) {\n        const event = blockEvent(cid);\n        this._log(event);\n        this.emit(event, block);\n    }\n    /**\n     * Signal the system that we are waiting to receive the\n     * block associated with the given `cid`.\n     * Returns a Promise that resolves to the block when it is received,\n     * or undefined when the block is unwanted.\n     */\n    async wantBlock(cid, options = {}) {\n        if (cid == null) {\n            throw new Error('Not a valid cid');\n        }\n        const blockEvt = blockEvent(cid);\n        const unwantEvt = unwantEvent(cid);\n        this._log(`wantBlock:${cid}`);\n        return new Promise((resolve, reject) => {\n            const onUnwant = () => {\n                this.removeListener(blockEvt, onBlock);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_1__.CustomProgressEvent('bitswap:want-block:unwant', cid));\n                reject(new Error(`Block for ${cid} unwanted`));\n            };\n            const onBlock = (data) => {\n                this.removeListener(unwantEvt, onUnwant);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_1__.CustomProgressEvent('bitswap:want-block:block', cid));\n                resolve(data);\n            };\n            this.once(unwantEvt, onUnwant);\n            this.once(blockEvt, onBlock);\n            options.signal?.addEventListener('abort', () => {\n                this.removeListener(blockEvt, onBlock);\n                this.removeListener(unwantEvt, onUnwant);\n                reject(new Error(`Want for ${cid} aborted`));\n            });\n        });\n    }\n    /**\n     * Signal that the block is not wanted anymore\n     */\n    unwantBlock(cid) {\n        const event = unwantEvent(cid);\n        this._log(event);\n        this.emit(event);\n    }\n}\n//# sourceMappingURL=notifications.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/notifications.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/stats/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/stats/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stats: () => (/* binding */ Stats)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stat.js */ \"./node_modules/ipfs-bitswap/dist/src/stats/stat.js\");\n\n\n\nconst defaultOptions = {\n    enabled: false,\n    computeThrottleTimeout: 1000,\n    computeThrottleMaxQueueSize: 1000,\n    movingAverageIntervals: [\n        60 * 1000, // 1 minute\n        5 * 60 * 1000, // 5 minutes\n        15 * 60 * 1000 // 15 minutes\n    ]\n};\nclass Stats extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    _initialCounters;\n    _options;\n    _enabled;\n    _global;\n    _peers;\n    constructor(libp2p, initialCounters = [], _options = defaultOptions) {\n        super();\n        const options = Object.assign({}, defaultOptions, _options);\n        if (typeof options.computeThrottleTimeout !== 'number') {\n            throw new Error('need computeThrottleTimeout');\n        }\n        if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n            throw new Error('need computeThrottleMaxQueueSize');\n        }\n        this._initialCounters = initialCounters;\n        this._options = options;\n        this._enabled = this._options.enabled;\n        this._global = new _stat_js__WEBPACK_IMPORTED_MODULE_1__.Stat(initialCounters, options);\n        this._global.on('update', (stats) => this.emit('update', stats));\n        this._peers = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_2__.trackedMap)({\n            name: 'ipfs_bitswap_stats_peers',\n            metrics: libp2p.metrics\n        });\n    }\n    enable() {\n        this._enabled = true;\n        this._options.enabled = true;\n        this._global.enable();\n    }\n    disable() {\n        this._enabled = false;\n        this._options.enabled = false;\n        this._global.disable();\n    }\n    stop() {\n        this._enabled = false;\n        this._global.stop();\n        for (const peerStat of this._peers) {\n            peerStat[1].stop();\n        }\n    }\n    get snapshot() {\n        return this._global.snapshot;\n    }\n    get movingAverages() {\n        return this._global.movingAverages;\n    }\n    forPeer(peerId) {\n        const peerIdStr = peerId.toString();\n        return this._peers.get(peerIdStr);\n    }\n    push(peer, counter, inc) {\n        if (this._enabled) {\n            this._global.push(counter, inc);\n            if (peer != null) {\n                let peerStats = this._peers.get(peer);\n                if (peerStats == null) {\n                    peerStats = new _stat_js__WEBPACK_IMPORTED_MODULE_1__.Stat(this._initialCounters, this._options);\n                    this._peers.set(peer, peerStats);\n                }\n                peerStats.push(counter, inc);\n            }\n        }\n    }\n    disconnected(peer) {\n        const peerId = peer.toString();\n        const peerStats = this._peers.get(peerId);\n        if (peerStats != null) {\n            peerStats.stop();\n            this._peers.delete(peerId);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/stats/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/stats/stat.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/stats/stat.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stat: () => (/* binding */ Stat)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var _vascosantos_moving_average__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vascosantos/moving-average */ \"./node_modules/@vascosantos/moving-average/index.js\");\n\n\nclass Stat extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    _options;\n    _queue;\n    _stats;\n    _frequencyLastTime;\n    _frequencyAccumulators;\n    _movingAverages;\n    _enabled;\n    _timeout;\n    constructor(initialCounters, options) {\n        super();\n        this._options = options;\n        this._queue = [];\n        this._stats = {};\n        this._frequencyLastTime = Date.now();\n        this._frequencyAccumulators = {};\n        this._movingAverages = {};\n        this._update = this._update.bind(this);\n        initialCounters.forEach((key) => {\n            this._stats[key] = BigInt(0);\n            this._movingAverages[key] = {};\n            this._options.movingAverageIntervals.forEach((interval) => {\n                const ma = this._movingAverages[key][interval] = _vascosantos_moving_average__WEBPACK_IMPORTED_MODULE_1__(interval);\n                ma.push(this._frequencyLastTime, 0);\n            });\n        });\n        this._enabled = this._options.enabled;\n    }\n    enable() {\n        this._enabled = true;\n    }\n    disable() {\n        this._enabled = false;\n    }\n    stop() {\n        if (this._timeout != null) {\n            clearTimeout(this._timeout);\n        }\n    }\n    get snapshot() {\n        return Object.assign({}, this._stats);\n    }\n    get movingAverages() {\n        return Object.assign({}, this._movingAverages);\n    }\n    push(counter, inc) {\n        if (this._enabled) {\n            this._queue.push([counter, inc, Date.now()]);\n            this._resetComputeTimeout();\n        }\n    }\n    _resetComputeTimeout() {\n        if (this._timeout != null) {\n            clearTimeout(this._timeout);\n        }\n        this._timeout = setTimeout(this._update, this._nextTimeout());\n    }\n    _nextTimeout() {\n        // calculate the need for an update, depending on the queue length\n        const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n        return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n    }\n    _update() {\n        this._timeout = undefined;\n        if (this._queue.length > 0) {\n            let last;\n            while (this._queue.length > 0) {\n                const op = last = this._queue.shift();\n                (op != null) && this._applyOp(op);\n            }\n            (last != null) && this._updateFrequency(last[2]); // contains timestamp of last op\n            this.emit('update', this._stats);\n        }\n    }\n    _updateFrequency(latestTime) {\n        const timeDiff = latestTime - this._frequencyLastTime;\n        if (timeDiff > 0) {\n            Object.keys(this._stats).forEach((key) => {\n                this._updateFrequencyFor(key, timeDiff, latestTime);\n            });\n        }\n        this._frequencyLastTime = latestTime;\n    }\n    _updateFrequencyFor(key, timeDiffMS, latestTime) {\n        const count = this._frequencyAccumulators[key] ?? 0;\n        this._frequencyAccumulators[key] = 0;\n        const hz = (count / timeDiffMS) * 1000;\n        let movingAverages = this._movingAverages[key];\n        if (movingAverages == null) {\n            movingAverages = this._movingAverages[key] = {};\n        }\n        this._options.movingAverageIntervals.forEach((movingAverageInterval) => {\n            let movingAverage = movingAverages[movingAverageInterval];\n            if (movingAverage == null) {\n                movingAverage = movingAverages[movingAverageInterval] = _vascosantos_moving_average__WEBPACK_IMPORTED_MODULE_1__(movingAverageInterval);\n            }\n            movingAverage.push(latestTime, hz);\n        });\n    }\n    _applyOp(op) {\n        const key = op[0];\n        const inc = op[1];\n        if (typeof inc !== 'number') {\n            throw new Error(`invalid increment number: ${inc}`);\n        }\n        if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n            this._stats[key] = BigInt(0);\n        }\n        this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);\n        if (this._frequencyAccumulators[key] == null) {\n            this._frequencyAccumulators[key] = 0;\n        }\n        this._frequencyAccumulators[key] += inc;\n    }\n}\n//# sourceMappingURL=stat.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/stats/stat.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   includesWith: () => (/* binding */ includesWith),\n/* harmony export */   isMapEqual: () => (/* binding */ isMapEqual),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   pullAllWith: () => (/* binding */ pullAllWith),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   uniqWith: () => (/* binding */ uniqWith)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var _message_entry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message/entry.js */ \"./node_modules/ipfs-bitswap/dist/src/message/entry.js\");\n\n\n\n/**\n * Creates a logger for the given subsystem\n */\nconst logger = (id, subsystem) => {\n    const name = ['bitswap'];\n    if (subsystem != null) {\n        name.push(subsystem);\n    }\n    if (id != null) {\n        name.push(`${id.toString().slice(0, 8)}`);\n    }\n    return (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_1__.logger)(name.join(':'));\n};\nconst includesWith = (pred, x, list) => {\n    let idx = 0;\n    const len = list.length;\n    while (idx < len) {\n        if (pred(x, list[idx])) {\n            return true;\n        }\n        idx += 1;\n    }\n    return false;\n};\nconst uniqWith = (pred, list) => {\n    let idx = 0;\n    const len = list.length;\n    const result = [];\n    let item;\n    while (idx < len) {\n        item = list[idx];\n        if (!includesWith(pred, item, result)) {\n            result[result.length] = item;\n        }\n        idx += 1;\n    }\n    return result;\n};\nconst groupBy = (pred, list) => {\n    // @ts-expect-error cannot use {} as record with these key types?\n    const output = {};\n    return list.reduce((acc, v) => {\n        const k = pred(v);\n        if (acc[k] != null) {\n            acc[k].push(v);\n        }\n        else {\n            acc[k] = [v];\n        }\n        return acc;\n    }, output);\n};\nconst pullAllWith = (pred, list, values) => {\n    return list.filter(i => {\n        return !includesWith(pred, i, values);\n    });\n};\nconst sortBy = (fn, list) => {\n    return Array.prototype.slice.call(list, 0).sort((a, b) => {\n        const aa = fn(a);\n        const bb = fn(b);\n        return aa < bb ? -1 : aa > bb ? 1 : 0;\n    });\n};\n/**\n * Is equal for Maps of BitswapMessageEntry or Uint8Arrays\n */\nconst isMapEqual = (a, b) => {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, valueA] of a) {\n        const valueB = b.get(key);\n        if (valueB === undefined) {\n            return false;\n        }\n        // TODO: revisit this\n        // Support Blocks\n        if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_0__.equals)(valueA, valueB)) {\n            return false;\n        }\n        // Support BitswapMessageEntry\n        if (valueA instanceof _message_entry_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessageEntry && valueB instanceof _message_entry_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessageEntry && !valueA.equals(valueB)) {\n            return false;\n        }\n    }\n    return true;\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/utils/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SortedMap: () => (/* binding */ SortedMap)\n/* harmony export */ });\n/**\n * SortedMap is a Map whose iterator order can be defined by the user\n */\nclass SortedMap extends Map {\n    _cmp;\n    _keys;\n    constructor(entries, cmp) {\n        super();\n        this._cmp = cmp ?? this._defaultSort;\n        this._keys = [];\n        for (const [k, v] of entries ?? []) {\n            this.set(k, v);\n        }\n    }\n    /**\n     * Call update to update the position of the key when it should change.\n     * For example if the compare function sorts by the priority field, and the\n     * priority changes, call update.\n     * Call indexOf() to get the index _before_ the change happens.\n     */\n    update(i) {\n        if (i < 0 || i >= this._keys.length) {\n            return;\n        }\n        const k = this._keys[i];\n        this._keys.splice(i, 1);\n        const newIdx = this._find(k);\n        this._keys.splice(newIdx, 0, k);\n    }\n    set(k, v) {\n        // If the key is already in the map, remove it from the ordering and\n        // re-insert it below\n        if (this.has(k)) {\n            const i = this.indexOf(k);\n            this._keys.splice(i, 1);\n        }\n        // Update / insert the k/v into the map\n        super.set(k, v);\n        // Find the correct position of the newly inserted k/v in the order\n        const i = this._find(k);\n        this._keys.splice(i, 0, k);\n        return this;\n    }\n    clear() {\n        super.clear();\n        this._keys = [];\n    }\n    delete(k) {\n        if (!this.has(k)) {\n            return false;\n        }\n        const i = this.indexOf(k);\n        this._keys.splice(i, 1);\n        return super.delete(k);\n    }\n    indexOf(k) {\n        if (!this.has(k)) {\n            return -1;\n        }\n        const i = this._find(k);\n        if (this._keys[i] === k) {\n            return i;\n        }\n        // There may be more than one key with the same ordering\n        // eg { k1: <priority 5>, k2: <priority 5> }\n        // so scan outwards until the key matches\n        for (let j = 1; j < this._keys.length; j++) {\n            if (this._keys[i + j] === k)\n                return i + j;\n            if (this._keys[i - j] === k)\n                return i - j;\n        }\n        return -1; // should never happen for existing key\n    }\n    _find(k) {\n        let lower = 0;\n        let upper = this._keys.length;\n        while (lower < upper) {\n            const pivot = (lower + upper) >>> 1; // lower + (upper - lower) / 2\n            const cmp = this._kCmp(this._keys[pivot], k);\n            // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n            if (cmp < 0) { // pivot < k\n                lower = pivot + 1;\n            }\n            else if (cmp > 0) { // pivot > k\n                upper = pivot;\n            }\n            else { // pivot == k\n                return pivot;\n            }\n        }\n        return lower;\n    }\n    *keys() {\n        for (const k of this._keys) {\n            yield k;\n        }\n        return undefined;\n    }\n    *values() {\n        for (const k of this._keys) {\n            // @ts-expect-error - return of `this.get(k)` is `Value|undefined` which is\n            // incompatible with `Value`. Typechecker can't that this contains values\n            // for all the `_keys`. ts(2322)\n            yield this.get(k);\n        }\n        return undefined;\n    }\n    *entries() {\n        for (const k of this._keys) {\n            // @ts-expect-error - return of `this.get(k)` is `Value|undefined` which is\n            // incompatible with `Value`. Typechecker can't that this contains values\n            // for all the `_keys`. ts(2322)\n            yield [k, this.get(k)];\n        }\n        return undefined;\n    }\n    *[Symbol.iterator]() {\n        yield* this.entries();\n    }\n    // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void\n    forEach(cb, thisArg = this) {\n        if (cb == null) {\n            return;\n        }\n        for (const k of this._keys) {\n            const val = this.get(k);\n            if (val == null) {\n                throw new Error('Value cannot be undefined');\n            }\n            cb.apply(thisArg, [[k, val]]);\n        }\n    }\n    _defaultSort(a, b) {\n        if (a[0] < b[0])\n            return -1;\n        if (b[0] < a[0])\n            return 1;\n        return 0;\n    }\n    _kCmp(a, b) {\n        return this._cmp(\n        // @ts-expect-error - get may return undefined\n        [a, this.get(a)], [b, this.get(b)]);\n    }\n}\n//# sourceMappingURL=sorted-map.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! varint */ \"./node_modules/varint/index.js\");\n\nfunction varintEncoder(buf) {\n    let out = new Uint8Array(buf.reduce((acc, curr) => {\n        // @ts-expect-error types are wrong\n        return acc + varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(curr); // eslint-disable-line @typescript-eslint/restrict-plus-operands\n    }, 0));\n    let offset = 0;\n    for (const num of buf) {\n        out = varint__WEBPACK_IMPORTED_MODULE_0__.encode(num, out, offset);\n        // @ts-expect-error types are wrong\n        offset += varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(num); // eslint-disable-line @typescript-eslint/restrict-plus-operands\n    }\n    return out;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (varintEncoder);\n//# sourceMappingURL=varint-encoder.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/want-manager/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/want-manager/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WantManager: () => (/* binding */ WantManager)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _wantlist_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wantlist/index.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/index.js\");\n/* harmony import */ var _msg_queue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./msg-queue.js */ \"./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js\");\n\n\n\n\n\n\n\nclass WantManager {\n    peers;\n    wantlist;\n    network;\n    _peerId;\n    _log;\n    constructor(peerId, network, stats, libp2p) {\n        this.peers = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_1__.trackedMap)({\n            name: 'ipfs_bitswap_want_manager_peers',\n            metrics: libp2p.metrics\n        });\n        this.wantlist = new _wantlist_index_js__WEBPACK_IMPORTED_MODULE_2__.Wantlist(stats, libp2p);\n        this.network = network;\n        this._peerId = peerId;\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.logger)(peerId, 'want');\n    }\n    _addEntries(cids, cancel, force, options = {}) {\n        const entries = cids.map((cid, i) => {\n            return new _message_index_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessage.Entry(cid, _constants_js__WEBPACK_IMPORTED_MODULE_5__.kMaxPriority - i, _message_index_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessage.WantType.Block, cancel);\n        });\n        entries.forEach((e) => {\n            // add changes to our wantlist\n            if (e.cancel) {\n                if (force === true) {\n                    this.wantlist.removeForce(e.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc));\n                }\n                else {\n                    this.wantlist.remove(e.cid);\n                }\n            }\n            else {\n                this._log('adding to wantlist');\n                // TODO: Figure out the wantType\n                // @ts-expect-error - requires wantType\n                this.wantlist.add(e.cid, e.priority);\n            }\n        });\n        // broadcast changes\n        for (const p of this.peers.values()) {\n            p.addEntries(entries, options);\n        }\n    }\n    _startPeerHandler(peerId) {\n        let mq = this.peers.get(peerId.toString());\n        if (mq != null) {\n            mq.refcnt++;\n            return;\n        }\n        mq = new _msg_queue_js__WEBPACK_IMPORTED_MODULE_6__.MsgQueue(this._peerId, peerId, this.network);\n        // new peer, give them the full wantlist\n        const fullwantlist = new _message_index_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessage(true);\n        for (const entry of this.wantlist.entries()) {\n            fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n        }\n        mq.addMessage(fullwantlist);\n        this.peers.set(peerId.toString(), mq);\n        return mq;\n    }\n    _stopPeerHandler(peerId) {\n        const mq = this.peers.get(peerId.toString());\n        if (mq == null) {\n            return;\n        }\n        mq.refcnt--;\n        if (mq.refcnt > 0) {\n            return;\n        }\n        this.peers.delete(peerId.toString());\n    }\n    /**\n     * add all the cids to the wantlist\n     */\n    wantBlocks(cids, options = {}) {\n        this._addEntries(cids, false, false, options);\n        options.signal?.addEventListener('abort', () => {\n            this.cancelWants(cids);\n        });\n    }\n    /**\n     * Remove blocks of all the given keys without respecting refcounts\n     */\n    unwantBlocks(cids) {\n        this._log('unwant blocks: %s', cids.length);\n        this._addEntries(cids, true, true);\n    }\n    /**\n     * Cancel wanting all of the given keys\n     */\n    cancelWants(cids) {\n        this._log('cancel wants: %s', cids.length);\n        this._addEntries(cids, true);\n    }\n    /**\n     * Returns a list of all currently connected peers\n     */\n    connectedPeers() {\n        return Array.from(this.peers.keys());\n    }\n    connected(peerId) {\n        this._startPeerHandler(peerId);\n    }\n    disconnected(peerId) {\n        this._stopPeerHandler(peerId);\n    }\n    start() {\n    }\n    stop() {\n        this.peers.forEach((mq) => { this.disconnected(mq.peerId); });\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/want-manager/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MsgQueue: () => (/* binding */ MsgQueue)\n/* harmony export */ });\n/* harmony import */ var just_debounce_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! just-debounce-it */ \"./node_modules/just-debounce-it/index.mjs\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n\n\n\n\nclass MsgQueue {\n    peerId;\n    refcnt;\n    network;\n    _entries;\n    _log;\n    constructor(selfPeerId, otherPeerId, network) {\n        this.peerId = otherPeerId;\n        this.network = network;\n        this.refcnt = 1;\n        this._entries = [];\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.logger)(selfPeerId, 'msgqueue');\n        this.sendEntries = (0,just_debounce_it__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.sendEntries.bind(this), _constants_js__WEBPACK_IMPORTED_MODULE_2__.wantlistSendDebounceMs);\n    }\n    addMessage(msg, options = {}) {\n        if (msg.empty) {\n            return;\n        }\n        void this.send(msg, options);\n    }\n    addEntries(entries, options = {}) {\n        this._entries = this._entries.concat(entries);\n        this.sendEntries(options);\n    }\n    sendEntries(options = {}) {\n        if (this._entries.length === 0) {\n            return;\n        }\n        const msg = new _message_index_js__WEBPACK_IMPORTED_MODULE_3__.BitswapMessage(false);\n        this._entries.forEach((entry) => {\n            if (entry.cancel === true) {\n                msg.cancel(entry.cid);\n            }\n            else {\n                msg.addEntry(entry.cid, entry.priority);\n            }\n        });\n        this._entries = [];\n        this.addMessage(msg, options);\n    }\n    async send(msg, options = {}) {\n        try {\n            await this.network.connectTo(this.peerId, options);\n        }\n        catch (err) {\n            this._log.error('cant connect to peer %p: %s', this.peerId, err.message);\n            return;\n        }\n        this._log('sending message to peer %p', this.peerId);\n        // Note: Don't wait for sendMessage() to complete\n        this.network.sendMessage(this.peerId, msg, options).catch((err) => {\n            this._log.error('send error', err);\n        });\n    }\n}\n//# sourceMappingURL=msg-queue.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WantListEntry: () => (/* binding */ WantListEntry)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n\nclass WantListEntry {\n    _refCounter;\n    cid;\n    priority;\n    wantType;\n    constructor(cid, priority, wantType) {\n        // Keep track of how many requests we have for this key\n        this._refCounter = 1;\n        this.cid = cid;\n        this.priority = priority ?? 1;\n        this.wantType = wantType;\n    }\n    inc() {\n        this._refCounter += 1;\n    }\n    dec() {\n        this._refCounter = Math.max(0, this._refCounter - 1);\n    }\n    hasRefs() {\n        return this._refCounter > 0;\n    }\n    // So that console.log prints a nice description of this object\n    get [Symbol.toStringTag]() {\n        const cidStr = this.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;\n    }\n    equals(other) {\n        return (this._refCounter === other._refCounter) &&\n            this.cid.equals(other.cid) &&\n            this.priority === other.priority &&\n            this.wantType === other.wantType;\n    }\n}\n//# sourceMappingURL=entry.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/wantlist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/wantlist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wantlist: () => (/* binding */ Wantlist)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _message_message_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../message/message.js */ \"./node_modules/ipfs-bitswap/dist/src/message/message.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entry.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js\");\n\n\n\n\nconst WantType = {\n    Block: _message_message_js__WEBPACK_IMPORTED_MODULE_1__.Message.Wantlist.WantType.Block,\n    Have: _message_message_js__WEBPACK_IMPORTED_MODULE_1__.Message.Wantlist.WantType.Have\n};\nconst sortBy = (fn, list) => {\n    return Array.prototype.slice.call(list, 0).sort((a, b) => {\n        const aa = fn(a);\n        const bb = fn(b);\n        return aa < bb ? -1 : aa > bb ? 1 : 0;\n    });\n};\nclass Wantlist {\n    static Entry = _entry_js__WEBPACK_IMPORTED_MODULE_2__.WantListEntry;\n    set;\n    _stats;\n    constructor(stats, libp2p) {\n        this.set = (libp2p != null)\n            ? (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_3__.trackedMap)({\n                name: 'ipfs_bitswap_wantlist',\n                metrics: libp2p.metrics\n            })\n            : new Map();\n        this._stats = stats;\n    }\n    get length() {\n        return this.set.size;\n    }\n    add(cid, priority, wantType) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        const entry = this.set.get(cidStr);\n        if (entry != null) {\n            entry.inc();\n            entry.priority = priority;\n            // We can only overwrite want-have with want-block\n            if (entry.wantType === WantType.Have && wantType === WantType.Block) {\n                entry.wantType = wantType;\n            }\n        }\n        else {\n            this.set.set(cidStr, new _entry_js__WEBPACK_IMPORTED_MODULE_2__.WantListEntry(cid, priority, wantType));\n            if (this._stats != null) {\n                this._stats.push(undefined, 'wantListSize', 1);\n            }\n        }\n    }\n    remove(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        const entry = this.set.get(cidStr);\n        if (entry == null) {\n            return;\n        }\n        entry.dec();\n        // only delete when no refs are held\n        if (entry.hasRefs()) {\n            return;\n        }\n        this.set.delete(cidStr);\n        if (this._stats != null) {\n            this._stats.push(undefined, 'wantListSize', -1);\n        }\n    }\n    removeForce(cidStr) {\n        if (this.set.has(cidStr)) {\n            this.set.delete(cidStr);\n        }\n    }\n    forEach(fn) {\n        this.set.forEach(fn);\n    }\n    entries() {\n        return this.set.entries();\n    }\n    sortedEntries() {\n        // TODO: Figure out if this is an actual bug.\n        // @ts-expect-error - Property 'key' does not exist on type 'WantListEntry'\n        return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())));\n    }\n    contains(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return this.set.has(cidStr);\n    }\n    get(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return this.set.get(cidStr);\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/wantlist/index.js?");

/***/ }),

/***/ "./node_modules/it-drain/dist/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/it-drain/dist/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction drain(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n        })();\n    }\n    else {\n        for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drain);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-drain/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-foreach/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/it-foreach/dist/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-peekable */ \"./node_modules/it-peekable/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Calls a function for each value in an (async)iterable.\n *\n * The function can be sync or async.\n *\n * Async functions can be awaited on so may slow down processing of the (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * // prints 0, 1, 2, 3, 4\n * const arr = drain(\n *   each(values, console.info)\n * )\n * ```\n *\n * Async sources and callbacks must be awaited:\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * // prints 0, 1, 2, 3, 4\n * const arr = await drain(\n *   each(values(), console.info)\n * )\n * ```\n */\n\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction isPromise(thing) {\n    return thing?.then != null;\n}\nfunction forEach(source, fn) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const val of source) {\n                const res = fn(val);\n                if (isPromise(res)) {\n                    await res;\n                }\n                yield val;\n            }\n        })();\n    }\n    // if fn function returns a promise we have to return an async generator\n    const peekable = (0,it_peekable__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source);\n    const { value, done } = peekable.next();\n    if (done === true) {\n        return (function* () { }());\n    }\n    const res = fn(value);\n    if (typeof res?.then === 'function') {\n        return (async function* () {\n            yield value;\n            for await (const val of peekable) {\n                const res = fn(val);\n                if (isPromise(res)) {\n                    await res;\n                }\n                yield val;\n            }\n        })();\n    }\n    const func = fn;\n    return (function* () {\n        yield value;\n        for (const val of peekable) {\n            func(val);\n            yield val;\n        }\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (forEach);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-foreach/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/decode.js":
/*!************************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/decode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_DATA_LENGTH: () => (/* binding */ MAX_DATA_LENGTH),\n/* harmony export */   MAX_LENGTH_LENGTH: () => (/* binding */ MAX_LENGTH_LENGTH),\n/* harmony export */   decode: () => (/* binding */ decode)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8-varint */ \"./node_modules/uint8-varint/dist/src/index.js\");\n/* harmony import */ var uint8arraylist__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arraylist */ \"./node_modules/uint8arraylist/dist/src/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/it-length-prefixed/dist/src/utils.js\");\n/* eslint max-depth: [\"error\", 6] */\n\n\n\n\n// Maximum length of the length section of the message\nconst MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n    ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = (buf) => {\n    const length = uint8_varint__WEBPACK_IMPORTED_MODULE_1__.decode(buf);\n    defaultDecoder.bytes = uint8_varint__WEBPACK_IMPORTED_MODULE_1__.encodingLength(length);\n    return length;\n};\ndefaultDecoder.bytes = 0;\nfunction decode(source, options) {\n    const buffer = new uint8arraylist__WEBPACK_IMPORTED_MODULE_2__.Uint8ArrayList();\n    let mode = ReadMode.LENGTH;\n    let dataLength = -1;\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n    function* maybeYield() {\n        while (buffer.byteLength > 0) {\n            if (mode === ReadMode.LENGTH) {\n                // read length, ignore errors for short reads\n                try {\n                    dataLength = lengthDecoder(buffer);\n                    if (dataLength < 0) {\n                        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n                    }\n                    if (dataLength > maxDataLength) {\n                        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n                    }\n                    const dataLengthLength = lengthDecoder.bytes;\n                    buffer.consume(dataLengthLength);\n                    if (options?.onLength != null) {\n                        options.onLength(dataLength);\n                    }\n                    mode = ReadMode.DATA;\n                }\n                catch (err) {\n                    if (err instanceof RangeError) {\n                        if (buffer.byteLength > maxLengthLength) {\n                            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n                        }\n                        break;\n                    }\n                    throw err;\n                }\n            }\n            if (mode === ReadMode.DATA) {\n                if (buffer.byteLength < dataLength) {\n                    // not enough data, wait for more\n                    break;\n                }\n                const data = buffer.sublist(0, dataLength);\n                buffer.consume(dataLength);\n                if (options?.onData != null) {\n                    options.onData(data);\n                }\n                yield data;\n                mode = ReadMode.LENGTH;\n            }\n        }\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isAsyncIterable)(source)) {\n        return (async function* () {\n            for await (const buf of source) {\n                buffer.append(buf);\n                yield* maybeYield();\n            }\n            if (buffer.byteLength > 0) {\n                throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n            }\n        })();\n    }\n    return (function* () {\n        for (const buf of source) {\n            buffer.append(buf);\n            yield* maybeYield();\n        }\n        if (buffer.byteLength > 0) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n        }\n    })();\n}\ndecode.fromReader = (reader, options) => {\n    let byteLength = 1; // Read single byte chunks until the length is known\n    const varByteSource = (async function* () {\n        while (true) {\n            try {\n                const { done, value } = await reader.next(byteLength);\n                if (done === true) {\n                    return;\n                }\n                if (value != null) {\n                    yield value;\n                }\n            }\n            catch (err) {\n                if (err.code === 'ERR_UNDER_READ') {\n                    return { done: true, value: null };\n                }\n                throw err;\n            }\n            finally {\n                // Reset the byteLength so we continue to check for varints\n                byteLength = 1;\n            }\n        }\n    }());\n    /**\n     * Once the length has been parsed, read chunk for that length\n     */\n    const onLength = (l) => { byteLength = l; };\n    return decode(varByteSource, {\n        ...(options ?? {}),\n        onLength\n    });\n};\n//# sourceMappingURL=decode.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/decode.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/encode.js":
/*!************************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/encode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8-varint */ \"./node_modules/uint8-varint/dist/src/index.js\");\n/* harmony import */ var uint8arraylist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arraylist */ \"./node_modules/uint8arraylist/dist/src/index.js\");\n/* harmony import */ var uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/alloc */ \"./node_modules/uint8arrays/dist/src/alloc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/it-length-prefixed/dist/src/utils.js\");\n\n\n\n\nconst defaultEncoder = (length) => {\n    const lengthLength = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(length);\n    const lengthBuf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_2__.allocUnsafe)(lengthLength);\n    uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encode(length, lengthBuf);\n    defaultEncoder.bytes = lengthLength;\n    return lengthBuf;\n};\ndefaultEncoder.bytes = 0;\nfunction encode(source, options) {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    function* maybeYield(chunk) {\n        // length + data\n        const length = encodeLength(chunk.byteLength);\n        // yield only Uint8Arrays\n        if (length instanceof Uint8Array) {\n            yield length;\n        }\n        else {\n            yield* length;\n        }\n        // yield only Uint8Arrays\n        if (chunk instanceof Uint8Array) {\n            yield chunk;\n        }\n        else {\n            yield* chunk;\n        }\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isAsyncIterable)(source)) {\n        return (async function* () {\n            for await (const chunk of source) {\n                yield* maybeYield(chunk);\n            }\n        })();\n    }\n    return (function* () {\n        for (const chunk of source) {\n            yield* maybeYield(chunk);\n        }\n    })();\n}\nencode.single = (chunk, options) => {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    return new uint8arraylist__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};\n//# sourceMappingURL=encode.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/encode.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   encode: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_0__.encode)\n/* harmony export */ });\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode.js */ \"./node_modules/it-length-prefixed/dist/src/encode.js\");\n/* harmony import */ var _decode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode.js */ \"./node_modules/it-length-prefixed/dist/src/decode.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)\n/* harmony export */ });\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/utils.js?");

/***/ }),

/***/ "./node_modules/it-take/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/it-take/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction take(source, limit) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            let items = 0;\n            if (limit < 1) {\n                return;\n            }\n            for await (const entry of source) {\n                yield entry;\n                items++;\n                if (items === limit) {\n                    return;\n                }\n            }\n        })();\n    }\n    return (function* () {\n        let items = 0;\n        if (limit < 1) {\n            return;\n        }\n        for (const entry of source) {\n            yield entry;\n            items++;\n            if (items === limit) {\n                return;\n            }\n        }\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (take);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-take/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/just-debounce-it/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/just-debounce-it/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ functionDebounce)\n/* harmony export */ });\nvar functionDebounce = debounce;\n\nfunction debounce(fn, wait, callFirst) {\n  var timeout = null;\n  var debouncedFn = null;\n\n  var clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n\n      debouncedFn = null;\n      timeout = null;\n    }\n  };\n\n  var flush = function() {\n    var call = debouncedFn;\n    clear();\n\n    if (call) {\n      call();\n    }\n  };\n\n  var debounceWrapper = function() {\n    if (!wait) {\n      return fn.apply(this, arguments);\n    }\n\n    var context = this;\n    var args = arguments;\n    var callNow = callFirst && !timeout;\n    clear();\n\n    debouncedFn = function() {\n      fn.apply(context, args);\n    };\n\n    timeout = setTimeout(function() {\n      timeout = null;\n\n      if (!callNow) {\n        var call = debouncedFn;\n        debouncedFn = null;\n\n        return call();\n      }\n    }, wait);\n\n    if (callNow) {\n      return debouncedFn();\n    }\n  };\n\n  debounceWrapper.cancel = clear;\n  debounceWrapper.flush = flush;\n\n  return debounceWrapper;\n}\n\n\n\n\n//# sourceURL=webpack://ems/./node_modules/just-debounce-it/index.mjs?");

/***/ })

}])