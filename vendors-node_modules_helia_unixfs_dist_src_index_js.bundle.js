/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkems"] = self["webpackChunkems"] || []).push([["vendors-node_modules_helia_unixfs_dist_src_index_js"],{

/***/ "./node_modules/is-plain-obj/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-plain-obj/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n\n\n//# sourceURL=webpack://ems/./node_modules/is-plain-obj/index.js?");

/***/ }),

/***/ "./node_modules/merge-options/index.js":
/*!*********************************************!*\
  !*** ./node_modules/merge-options/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nconst isOptionObject = __webpack_require__(/*! is-plain-obj */ \"./node_modules/is-plain-obj/index.js\");\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n\n\n//# sourceURL=webpack://ems/./node_modules/merge-options/index.js?");

/***/ }),

/***/ "./node_modules/murmurhash3js-revisited/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/murmurhash3js-revisited/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/murmurHash3js */ \"./node_modules/murmurhash3js-revisited/lib/murmurHash3js.js\");\n\n\n//# sourceURL=webpack://ems/./node_modules/murmurhash3js-revisited/index.js?");

/***/ }),

/***/ "./node_modules/murmurhash3js-revisited/lib/murmurHash3js.js":
/*!*******************************************************************!*\
  !*** ./node_modules/murmurhash3js-revisited/lib/murmurHash3js.js ***!
  \*******************************************************************/
/***/ (function(module, exports) {

eval("/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (true) {\n\n        if ( true && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else {}\n})(this);\n\n\n//# sourceURL=webpack://ems/./node_modules/murmurhash3js-revisited/lib/murmurHash3js.js?");

/***/ }),

/***/ "./node_modules/sparse-array/index.js":
/*!********************************************!*\
  !*** ./node_modules/sparse-array/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}\n\n//# sourceURL=webpack://ems/./node_modules/sparse-array/index.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/add.js":
/*!*************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/add.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addAll: () => (/* binding */ addAll),\n/* harmony export */   addByteStream: () => (/* binding */ addByteStream),\n/* harmony export */   addBytes: () => (/* binding */ addBytes),\n/* harmony export */   addDirectory: () => (/* binding */ addDirectory),\n/* harmony export */   addFile: () => (/* binding */ addFile)\n/* harmony export */ });\n/* harmony import */ var ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-unixfs-importer */ \"./node_modules/ipfs-unixfs-importer/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_importer_chunker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-importer/chunker */ \"./node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js\");\n/* harmony import */ var ipfs_unixfs_importer_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-unixfs-importer/layout */ \"./node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js\");\n\n\n\n/**\n * Default importer settings match Filecoin\n */\nconst defaultImporterSettings = {\n    cidVersion: 1,\n    rawLeaves: true,\n    layout: (0,ipfs_unixfs_importer_layout__WEBPACK_IMPORTED_MODULE_0__.balanced)({\n        maxChildrenPerNode: 1024\n    }),\n    chunker: (0,ipfs_unixfs_importer_chunker__WEBPACK_IMPORTED_MODULE_1__.fixedSize)({\n        chunkSize: 1048576\n    })\n};\nasync function* addAll(source, blockstore, options = {}) {\n    yield* (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_2__.importer)(source, blockstore, {\n        ...defaultImporterSettings,\n        ...options\n    });\n}\nasync function addBytes(bytes, blockstore, options = {}) {\n    const { cid } = await (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_2__.importBytes)(bytes, blockstore, {\n        ...defaultImporterSettings,\n        ...options\n    });\n    return cid;\n}\nasync function addByteStream(bytes, blockstore, options = {}) {\n    const { cid } = await (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_2__.importByteStream)(bytes, blockstore, {\n        ...defaultImporterSettings,\n        ...options\n    });\n    return cid;\n}\nasync function addFile(file, blockstore, options = {}) {\n    const { cid } = await (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_2__.importFile)(file, blockstore, {\n        ...defaultImporterSettings,\n        ...options\n    });\n    return cid;\n}\nasync function addDirectory(dir, blockstore, options = {}) {\n    const { cid } = await (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_2__.importDirectory)({\n        ...dir,\n        path: dir.path ?? '-'\n    }, blockstore, {\n        ...defaultImporterSettings,\n        ...options\n    });\n    return cid;\n}\n//# sourceMappingURL=add.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/add.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/cat.js":
/*!*************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/cat.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cat: () => (/* binding */ cat)\n/* harmony export */ });\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resolve.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js\");\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bind({ ignoreUndefined: true });\nconst defaultOptions = {};\nasync function* cat(cid, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    const resolved = await (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_3__.resolve)(cid, opts.path, blockstore, opts);\n    const result = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__.exporter)(resolved.cid, blockstore, opts);\n    if (result.type !== 'file' && result.type !== 'raw') {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NotAFileError();\n    }\n    if (result.content == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NoContentError();\n    }\n    yield* result.content(opts);\n}\n//# sourceMappingURL=cat.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/cat.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/chmod.js":
/*!***************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/chmod.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chmod: () => (/* binding */ chmod)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ipfs-unixfs-importer */ \"./node_modules/ipfs-unixfs-importer/dist/src/index.js\");\n/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-last */ \"./node_modules/it-last/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/persist.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js\");\n/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/resolve.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_4__[\"default\"].bind({ ignoreUndefined: true });\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_12__.logger)('helia:unixfs:chmod');\nconst defaultOptions = {\n    recursive: false,\n    shardSplitThresholdBytes: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.SHARD_SPLIT_THRESHOLD_BYTES\n};\nasync function chmod(cid, mode, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    const resolved = await (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__.resolve)(cid, opts.path, blockstore, options);\n    log('chmod %c %d', resolved.cid, mode);\n    if (opts.recursive) {\n        // recursively export from root CID, change perms of each entry then reimport\n        // but do not reimport files, only manipulate dag-pb nodes\n        const root = await (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)(async function* () {\n            for await (const entry of (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__.recursive)(resolved.cid, blockstore, options)) {\n                let metadata;\n                let links = [];\n                if (entry.type === 'raw') {\n                    // convert to UnixFS\n                    metadata = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS({ type: 'file', data: entry.node });\n                }\n                else if (entry.type === 'file' || entry.type === 'directory') {\n                    metadata = entry.unixfs;\n                    links = entry.node.Links;\n                }\n                else {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.NotUnixFSError();\n                }\n                metadata.mode = mode;\n                const node = {\n                    Data: metadata.marshal(),\n                    Links: links\n                };\n                yield {\n                    path: entry.path,\n                    content: node\n                };\n            }\n        }, \n        // @ts-expect-error cannot combine progress types\n        (source) => (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_14__.importer)(source, blockstore, {\n            ...opts,\n            dagBuilder: async function* (source, block) {\n                for await (const entry of source) {\n                    yield async function () {\n                        // @ts-expect-error cannot derive type\n                        const node = entry.content;\n                        const buf = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(node);\n                        const updatedCid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_10__.persist)(buf, block, {\n                            ...opts,\n                            cidVersion: cid.version\n                        });\n                        if (node.Data == null) {\n                            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.InvalidPBNodeError(`${updatedCid} had no data`);\n                        }\n                        const unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS.unmarshal(node.Data);\n                        return {\n                            cid: updatedCid,\n                            size: BigInt(buf.length),\n                            path: entry.path,\n                            unixfs\n                        };\n                    };\n                }\n            }\n        }), async (nodes) => (0,it_last__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(nodes));\n        if (root == null) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.UnknownError(`Could not chmod ${resolved.cid.toString()}`);\n        }\n        return (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__.updatePathCids)(root.cid, resolved, blockstore, opts);\n    }\n    const block = await blockstore.get(resolved.cid, options);\n    let metadata;\n    let links = [];\n    if (resolved.cid.code === multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_6__.code) {\n        // convert to UnixFS\n        metadata = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS({ type: 'file', data: block });\n    }\n    else {\n        const node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n        if (node.Data == null) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.InvalidPBNodeError(`${resolved.cid.toString()} had no data`);\n        }\n        links = node.Links;\n        metadata = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS.unmarshal(node.Data);\n    }\n    metadata.mode = mode;\n    const updatedBlock = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode({\n        Data: metadata.marshal(),\n        Links: links\n    });\n    const hash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__.sha256.digest(updatedBlock);\n    const updatedCid = multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.create(resolved.cid.version, _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code, hash);\n    await blockstore.put(updatedCid, updatedBlock);\n    return (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__.updatePathCids)(updatedCid, resolved, blockstore, opts);\n}\n//# sourceMappingURL=chmod.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/chmod.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/cp.js":
/*!************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/cp.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cp: () => (/* binding */ cp)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_add_link_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/add-link.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js\");\n/* harmony import */ var _utils_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/cid-to-directory.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js\");\n/* harmony import */ var _utils_cid_to_pblink_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/cid-to-pblink.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js\");\n\n\n\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bind({ ignoreUndefined: true });\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.logger)('helia:unixfs:cp');\nconst defaultOptions = {\n    force: false,\n    shardSplitThresholdBytes: _utils_constants_js__WEBPACK_IMPORTED_MODULE_5__.SHARD_SPLIT_THRESHOLD_BYTES\n};\nasync function cp(source, target, name, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    if (name.includes('/')) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidParametersError('Name must not have slashes');\n    }\n    const [directory, pblink] = await Promise.all([\n        (0,_utils_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_3__.cidToDirectory)(target, blockstore, opts),\n        (0,_utils_cid_to_pblink_js__WEBPACK_IMPORTED_MODULE_4__.cidToPBLink)(source, name, blockstore, opts)\n    ]);\n    log('Adding %c as \"%s\" to %c', source, name, target);\n    const result = await (0,_utils_add_link_js__WEBPACK_IMPORTED_MODULE_2__.addLink)(directory, pblink, blockstore, {\n        allowOverwriting: opts.force,\n        cidVersion: target.version,\n        ...opts\n    });\n    return result.cid;\n}\n//# sourceMappingURL=cp.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/cp.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/ls.js":
/*!************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/ls.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ls: () => (/* binding */ ls)\n/* harmony export */ });\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resolve.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js\");\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bind({ ignoreUndefined: true });\nconst defaultOptions = {};\nasync function* ls(cid, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    const resolved = await (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_3__.resolve)(cid, opts.path, blockstore, opts);\n    const result = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__.exporter)(resolved.cid, blockstore);\n    if (result.type === 'file' || result.type === 'raw') {\n        yield result;\n        return;\n    }\n    if (result.content == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NoContentError();\n    }\n    if (result.type !== 'directory') {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NotADirectoryError();\n    }\n    yield* result.content({\n        offset: options.offset,\n        length: options.length\n    });\n}\n//# sourceMappingURL=ls.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/ls.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/mkdir.js":
/*!***************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/mkdir.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mkdir: () => (/* binding */ mkdir)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_add_link_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/add-link.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js\");\n/* harmony import */ var _utils_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/cid-to-directory.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js\");\n/* harmony import */ var _utils_cid_to_pblink_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/cid-to-pblink.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_2__[\"default\"].bind({ ignoreUndefined: true });\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_10__.logger)('helia:unixfs:mkdir');\nconst defaultOptions = {\n    cidVersion: 1,\n    force: false,\n    shardSplitThresholdBytes: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.SHARD_SPLIT_THRESHOLD_BYTES\n};\nasync function mkdir(parentCid, dirname, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    if (dirname.includes('/')) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.InvalidParametersError('Path must not have slashes');\n    }\n    const entry = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__.exporter)(parentCid, blockstore, options);\n    if (entry.type !== 'directory') {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.NotADirectoryError(`${parentCid.toString()} was not a UnixFS directory`);\n    }\n    log('creating %s', dirname);\n    const metadata = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_11__.UnixFS({\n        type: 'directory',\n        mode: opts.mode,\n        mtime: opts.mtime\n    });\n    // Persist the new parent PBNode\n    const node = {\n        Data: metadata.marshal(),\n        Links: []\n    };\n    const buf = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(node);\n    const hash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_4__.sha256.digest(buf);\n    const emptyDirCid = multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.create(opts.cidVersion, _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code, hash);\n    await blockstore.put(emptyDirCid, buf);\n    const [directory, pblink] = await Promise.all([\n        (0,_utils_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_7__.cidToDirectory)(parentCid, blockstore, opts),\n        (0,_utils_cid_to_pblink_js__WEBPACK_IMPORTED_MODULE_8__.cidToPBLink)(emptyDirCid, dirname, blockstore, opts)\n    ]);\n    log('adding empty dir called %s to %c', dirname, parentCid);\n    const result = await (0,_utils_add_link_js__WEBPACK_IMPORTED_MODULE_6__.addLink)(directory, pblink, blockstore, {\n        ...opts,\n        allowOverwriting: opts.force\n    });\n    return result.cid;\n}\n//# sourceMappingURL=mkdir.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/mkdir.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/rm.js":
/*!************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/rm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rm: () => (/* binding */ rm)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/cid-to-directory.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js\");\n/* harmony import */ var _utils_remove_link_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/remove-link.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/remove-link.js\");\n\n\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bind({ ignoreUndefined: true });\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_5__.logger)('helia:unixfs:rm');\nconst defaultOptions = {\n    shardSplitThresholdBytes: _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__.SHARD_SPLIT_THRESHOLD_BYTES\n};\nasync function rm(target, name, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    if (name.includes('/')) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidParametersError('Name must not have slashes');\n    }\n    const directory = await (0,_utils_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_2__.cidToDirectory)(target, blockstore, opts);\n    log('Removing %s from %c', name, target);\n    const result = await (0,_utils_remove_link_js__WEBPACK_IMPORTED_MODULE_4__.removeLink)(directory, name, blockstore, {\n        ...opts,\n        cidVersion: target.version\n    });\n    return result.cid;\n}\n//# sourceMappingURL=rm.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/rm.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/stat.js":
/*!**************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/stat.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stat: () => (/* binding */ stat)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/resolve.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js\");\n\n\n\n\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_2__[\"default\"].bind({ ignoreUndefined: true });\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.logger)('helia:unixfs:stat');\nconst defaultOptions = {};\nasync function stat(cid, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    const resolved = await (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_5__.resolve)(cid, options.path, blockstore, opts);\n    log('stat %c', resolved.cid);\n    const result = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__.exporter)(resolved.cid, blockstore, opts);\n    if (result.type !== 'file' && result.type !== 'directory' && result.type !== 'raw') {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_4__.NotUnixFSError();\n    }\n    let fileSize = 0n;\n    let dagSize = 0n;\n    let localFileSize = 0n;\n    let localDagSize = 0n;\n    let blocks = 0;\n    let mode;\n    let mtime;\n    const type = result.type;\n    let unixfs;\n    if (result.type === 'raw') {\n        fileSize = BigInt(result.node.byteLength);\n        dagSize = BigInt(result.node.byteLength);\n        localFileSize = BigInt(result.node.byteLength);\n        localDagSize = BigInt(result.node.byteLength);\n        blocks = 1;\n    }\n    if (result.type === 'directory') {\n        fileSize = 0n;\n        dagSize = BigInt(result.unixfs.marshal().byteLength);\n        localFileSize = 0n;\n        localDagSize = dagSize;\n        blocks = 1;\n        mode = result.unixfs.mode;\n        mtime = result.unixfs.mtime;\n        unixfs = result.unixfs;\n    }\n    if (result.type === 'file') {\n        const results = await inspectDag(resolved.cid, blockstore, opts);\n        fileSize = result.unixfs.fileSize();\n        dagSize = BigInt((result.node.Data?.byteLength ?? 0) + result.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0));\n        localFileSize = BigInt(results.localFileSize);\n        localDagSize = BigInt(results.localDagSize);\n        blocks = results.blocks;\n        mode = result.unixfs.mode;\n        mtime = result.unixfs.mtime;\n        unixfs = result.unixfs;\n    }\n    return {\n        cid: resolved.cid,\n        mode,\n        mtime,\n        fileSize,\n        dagSize,\n        localFileSize,\n        localDagSize,\n        blocks,\n        type,\n        unixfs\n    };\n}\nasync function inspectDag(cid, blockstore, options) {\n    const results = {\n        localFileSize: 0,\n        localDagSize: 0,\n        blocks: 0\n    };\n    if (await blockstore.has(cid, options)) {\n        const block = await blockstore.get(cid, options);\n        results.blocks++;\n        results.localDagSize += block.byteLength;\n        if (cid.code === multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_3__.code) {\n            results.localFileSize += block.byteLength;\n        }\n        else if (cid.code === _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code) {\n            const pbNode = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n            if (pbNode.Links.length > 0) {\n                // intermediate node\n                for (const link of pbNode.Links) {\n                    const linkResult = await inspectDag(link.Hash, blockstore, options);\n                    results.localFileSize += linkResult.localFileSize;\n                    results.localDagSize += linkResult.localDagSize;\n                    results.blocks += linkResult.blocks;\n                }\n            }\n            else {\n                // leaf node\n                if (pbNode.Data == null) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_4__.InvalidPBNodeError(`PBNode ${cid.toString()} had no data`);\n                }\n                const unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_7__.UnixFS.unmarshal(pbNode.Data);\n                if (unixfs.data == null) {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_4__.InvalidPBNodeError(`UnixFS node ${cid.toString()} had no data`);\n                }\n                results.localFileSize += unixfs.data.byteLength ?? 0;\n            }\n        }\n        else {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_4__.UnknownError(`${cid.toString()} was neither DAG_PB nor RAW`);\n        }\n    }\n    return results;\n}\n//# sourceMappingURL=stat.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/stat.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/touch.js":
/*!***************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/touch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   touch: () => (/* binding */ touch)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ipfs-unixfs-importer */ \"./node_modules/ipfs-unixfs-importer/dist/src/index.js\");\n/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-last */ \"./node_modules/it-last/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var merge_options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.mjs\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/persist.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js\");\n/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/resolve.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst mergeOptions = merge_options__WEBPACK_IMPORTED_MODULE_4__[\"default\"].bind({ ignoreUndefined: true });\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_12__.logger)('helia:unixfs:touch');\nconst defaultOptions = {\n    recursive: false,\n    shardSplitThresholdBytes: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.SHARD_SPLIT_THRESHOLD_BYTES\n};\nasync function touch(cid, blockstore, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    const resolved = await (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__.resolve)(cid, opts.path, blockstore, opts);\n    const mtime = opts.mtime ?? {\n        secs: BigInt(Math.round(Date.now() / 1000)),\n        nsecs: 0\n    };\n    log('touch %c %o', resolved.cid, mtime);\n    if (opts.recursive) {\n        // recursively export from root CID, change perms of each entry then reimport\n        // but do not reimport files, only manipulate dag-pb nodes\n        const root = await (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)(async function* () {\n            for await (const entry of (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__.recursive)(resolved.cid, blockstore)) {\n                let metadata;\n                let links;\n                if (entry.type === 'raw') {\n                    metadata = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS({ data: entry.node });\n                    links = [];\n                }\n                else if (entry.type === 'file' || entry.type === 'directory') {\n                    metadata = entry.unixfs;\n                    links = entry.node.Links;\n                }\n                else {\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.NotUnixFSError();\n                }\n                metadata.mtime = mtime;\n                const node = {\n                    Data: metadata.marshal(),\n                    Links: links\n                };\n                yield {\n                    path: entry.path,\n                    content: node\n                };\n            }\n        }, \n        // @ts-expect-error blockstore types are incompatible\n        (source) => (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_14__.importer)(source, blockstore, {\n            ...opts,\n            dagBuilder: async function* (source, block) {\n                for await (const entry of source) {\n                    yield async function () {\n                        // @ts-expect-error cannot derive type\n                        const node = entry.content;\n                        const buf = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(node);\n                        const updatedCid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_10__.persist)(buf, block, {\n                            ...opts,\n                            cidVersion: cid.version\n                        });\n                        if (node.Data == null) {\n                            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.InvalidPBNodeError(`${updatedCid} had no data`);\n                        }\n                        const unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS.unmarshal(node.Data);\n                        return {\n                            cid: updatedCid,\n                            size: BigInt(buf.length),\n                            path: entry.path,\n                            unixfs\n                        };\n                    };\n                }\n            }\n        }), async (nodes) => (0,it_last__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(nodes));\n        if (root == null) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.UnknownError(`Could not chmod ${resolved.cid.toString()}`);\n        }\n        return (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__.updatePathCids)(root.cid, resolved, blockstore, opts);\n    }\n    const block = await blockstore.get(resolved.cid, options);\n    let metadata;\n    let links = [];\n    if (resolved.cid.code === multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_6__.code) {\n        metadata = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS({ data: block });\n    }\n    else {\n        const node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n        links = node.Links;\n        if (node.Data == null) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_8__.InvalidPBNodeError(`${resolved.cid.toString()} had no data`);\n        }\n        metadata = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_13__.UnixFS.unmarshal(node.Data);\n    }\n    metadata.mtime = mtime;\n    const updatedBlock = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode({\n        Data: metadata.marshal(),\n        Links: links\n    });\n    const hash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_7__.sha256.digest(updatedBlock);\n    const updatedCid = multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.create(resolved.cid.version, _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code, hash);\n    await blockstore.put(updatedCid, updatedBlock);\n    return (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_11__.updatePathCids)(updatedCid, resolved, blockstore, opts);\n}\n//# sourceMappingURL=touch.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/touch.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js":
/*!************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addLink: () => (/* binding */ addLink)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var sparse_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sparse-array */ \"./node_modules/sparse-array/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _consumable_hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./consumable-hash.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/consumable-hash.js\");\n/* harmony import */ var _hamt_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hamt-constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js\");\n/* harmony import */ var _hamt_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./hamt-utils.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js\");\n/* harmony import */ var _is_over_shard_threshold_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./is-over-shard-threshold.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/is-over-shard-threshold.js\");\n\n\n\n\n\n// @ts-expect-error no types\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_10__.logger)('helia:unixfs:components:utils:add-link');\nasync function addLink(parent, child, blockstore, options) {\n    if (parent.node.Data == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.InvalidParametersError('Invalid parent passed to addLink');\n    }\n    const meta = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_11__.UnixFS.unmarshal(parent.node.Data);\n    if (meta.type === 'hamt-sharded-directory') {\n        log('adding link to sharded directory');\n        return addToShardedDirectory(parent, child, blockstore, options);\n    }\n    log(`adding ${child.Name} (${child.Hash}) to regular directory`);\n    const result = await addToDirectory(parent, child, blockstore, options);\n    if (await (0,_is_over_shard_threshold_js__WEBPACK_IMPORTED_MODULE_9__.isOverShardThreshold)(result.node, blockstore, options.shardSplitThresholdBytes, options)) {\n        log('converting directory to sharded directory');\n        const converted = await convertToShardedDirectory(result, blockstore);\n        result.cid = converted.cid;\n        result.node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(await blockstore.get(converted.cid, options));\n    }\n    return result;\n}\nconst convertToShardedDirectory = async (parent, blockstore) => {\n    if (parent.node.Data == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.InvalidParametersError('Invalid parent passed to convertToShardedDirectory');\n    }\n    const unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_11__.UnixFS.unmarshal(parent.node.Data);\n    const result = await (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_8__.createShard)(blockstore, parent.node.Links.map(link => ({\n        name: (link.Name ?? ''),\n        size: BigInt(link.Tsize ?? 0),\n        cid: link.Hash\n    })), {\n        mode: unixfs.mode,\n        mtime: unixfs.mtime,\n        cidVersion: parent.cid.version\n    });\n    log(`converted directory to sharded directory ${result.cid}`);\n    return result;\n};\nconst addToDirectory = async (parent, child, blockstore, options) => {\n    // Remove existing link if it exists\n    const parentLinks = parent.node.Links.filter((link) => {\n        const matches = link.Name === child.Name;\n        if (matches && !options.allowOverwriting) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.AlreadyExistsError();\n        }\n        return !matches;\n    });\n    parentLinks.push(child);\n    if (parent.node.Data == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.InvalidPBNodeError('Parent node with no data passed to addToDirectory');\n    }\n    const node = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_11__.UnixFS.unmarshal(parent.node.Data);\n    let data;\n    if (node.mtime != null) {\n        // Update mtime if previously set\n        const ms = Date.now();\n        const secs = Math.floor(ms / 1000);\n        node.mtime = {\n            secs: BigInt(secs),\n            nsecs: (ms - (secs * 1000)) * 1000\n        };\n        data = node.marshal();\n    }\n    else {\n        data = parent.node.Data;\n    }\n    parent.node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare({\n        Data: data,\n        Links: parentLinks\n    });\n    // Persist the new parent PbNode\n    const buf = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(parent.node);\n    const hash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(buf);\n    const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.create(parent.cid.version, _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code, hash);\n    await blockstore.put(cid, buf);\n    return {\n        node: parent.node,\n        cid\n    };\n};\nconst addToShardedDirectory = async (parent, child, blockstore, options) => {\n    const { path, hash } = await (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_8__.recreateShardedDirectory)(parent.cid, child.Name, blockstore, options);\n    const finalSegment = path[path.length - 1];\n    if (finalSegment == null) {\n        throw new Error('Invalid HAMT, could not generate path');\n    }\n    // find the next prefix\n    // const index = await hash.take(hamtBucketBits)\n    const prefix = finalSegment.prefix;\n    const index = parseInt(prefix, 16);\n    log('next prefix for %s is %s', child.Name, prefix);\n    const linkName = `${prefix}${child.Name}`;\n    const existingLink = finalSegment.node.Links.find(l => (l.Name ?? '').startsWith(prefix));\n    if (existingLink != null) {\n        log('link %s was present in shard', linkName);\n        // link is already present in shard\n        if (existingLink.Name === linkName) {\n            // file with same name is already present in shard\n            if (!options.allowOverwriting) {\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_5__.AlreadyExistsError();\n            }\n            log('overwriting %s in subshard', child.Name);\n            finalSegment.node.Links = finalSegment.node.Links.filter(l => l.Name !== linkName);\n            finalSegment.node.Links.push({\n                Name: linkName,\n                Hash: child.Hash,\n                Tsize: child.Tsize\n            });\n        }\n        else if (existingLink.Name?.length === 2) {\n            throw new Error('Existing link was subshard?!');\n        }\n        else {\n            // conflict, add a new HAMT segment\n            log('prefix %s already exists, creating new subshard', prefix);\n            // find the sibling we are going to replace\n            const index = finalSegment.node.Links.findIndex(l => l.Name?.startsWith(prefix));\n            const sibling = finalSegment.node.Links.splice(index, 1)[0];\n            // give the sibling a new HAMT prefix\n            const siblingName = (sibling.Name ?? '').substring(2);\n            const wrapped = (0,_consumable_hash_js__WEBPACK_IMPORTED_MODULE_6__.wrapHash)(_hamt_constants_js__WEBPACK_IMPORTED_MODULE_7__.hamtHashFn);\n            const siblingHash = wrapped((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_4__.fromString)(siblingName));\n            // discard hash bits until we reach the subshard depth\n            for (let i = 0; i < path.length; i++) {\n                await siblingHash.take(_hamt_constants_js__WEBPACK_IMPORTED_MODULE_7__.hamtBucketBits);\n            }\n            while (true) {\n                const siblingIndex = await siblingHash.take(_hamt_constants_js__WEBPACK_IMPORTED_MODULE_7__.hamtBucketBits);\n                const siblingPrefix = (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_8__.toPrefix)(siblingIndex);\n                sibling.Name = `${siblingPrefix}${siblingName}`;\n                // calculate the target file's HAMT prefix in the new sub-shard\n                const newIndex = await hash.take(_hamt_constants_js__WEBPACK_IMPORTED_MODULE_7__.hamtBucketBits);\n                const newPrefix = (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_8__.toPrefix)(newIndex);\n                if (siblingPrefix === newPrefix) {\n                    // the two sibling names have caused another conflict - add an intermediate node to\n                    // the HAMT and try again\n                    // create the child locations\n                    const children = new sparse_array__WEBPACK_IMPORTED_MODULE_3__();\n                    children.set(newIndex, true);\n                    path.push({\n                        prefix: newPrefix,\n                        children,\n                        node: {\n                            Links: []\n                        }\n                    });\n                    continue;\n                }\n                // create the child locations\n                const children = new sparse_array__WEBPACK_IMPORTED_MODULE_3__();\n                children.set(newIndex, true);\n                children.set(siblingIndex, true);\n                // add our new segment\n                path.push({\n                    prefix,\n                    children,\n                    node: {\n                        Links: [\n                            sibling, {\n                                Name: `${newPrefix}${child.Name}`,\n                                Hash: child.Hash,\n                                Tsize: child.Tsize\n                            }\n                        ]\n                    }\n                });\n                break;\n            }\n        }\n    }\n    else {\n        log('link %s was not present in sub-shard', linkName);\n        // add new link to shard\n        child.Name = linkName;\n        finalSegment.node.Links.push(child);\n        finalSegment.children.set(index, true);\n        log('adding %s to existing sub-shard', linkName);\n    }\n    return (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_8__.updateShardedDirectory)(path, blockstore, options);\n};\n//# sourceMappingURL=add-link.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cidToDirectory: () => (/* binding */ cidToDirectory)\n/* harmony export */ });\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n\n\nasync function cidToDirectory(cid, blockstore, options = {}) {\n    const entry = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__.exporter)(cid, blockstore, options);\n    if (entry.type !== 'directory') {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.NotADirectoryError(`${cid.toString()} was not a UnixFS directory`);\n    }\n    return {\n        cid,\n        node: entry.node\n    };\n}\n//# sourceMappingURL=cid-to-directory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cidToPBLink: () => (/* binding */ cidToPBLink)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n\n\n\nasync function cidToPBLink(cid, name, blockstore, options) {\n    const sourceEntry = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__.exporter)(cid, blockstore, options);\n    if (sourceEntry.type !== 'directory' && sourceEntry.type !== 'file' && sourceEntry.type !== 'raw') {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NotUnixFSError(`${cid.toString()} was not a UnixFS node`);\n    }\n    return {\n        Name: name,\n        Tsize: sourceEntry.node instanceof Uint8Array ? sourceEntry.node.byteLength : dagNodeTsize(sourceEntry.node),\n        Hash: cid\n    };\n}\nfunction dagNodeTsize(node) {\n    const linkSizes = node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0);\n    return _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(node).byteLength + linkSizes;\n}\n//# sourceMappingURL=cid-to-pblink.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHARD_SPLIT_THRESHOLD_BYTES: () => (/* binding */ SHARD_SPLIT_THRESHOLD_BYTES)\n/* harmony export */ });\nconst SHARD_SPLIT_THRESHOLD_BYTES = 262144;\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/constants.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/consumable-hash.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/consumable-hash.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsumableBuffer: () => (/* binding */ ConsumableBuffer),\n/* harmony export */   InfiniteHash: () => (/* binding */ InfiniteHash),\n/* harmony export */   wrapHash: () => (/* binding */ wrapHash)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n\nfunction wrapHash(hashFn) {\n    function hashing(value) {\n        if (value instanceof InfiniteHash) {\n            // already a hash. return it\n            return value;\n        }\n        else {\n            return new InfiniteHash(value, hashFn);\n        }\n    }\n    return hashing;\n}\nclass InfiniteHash {\n    _value;\n    _hashFn;\n    _depth;\n    _availableBits;\n    _currentBufferIndex;\n    _buffers;\n    constructor(value, hashFn) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('can only hash Uint8Arrays');\n        }\n        this._value = value;\n        this._hashFn = hashFn;\n        this._depth = -1;\n        this._availableBits = 0;\n        this._currentBufferIndex = 0;\n        this._buffers = [];\n    }\n    async take(bits) {\n        let pendingBits = bits;\n        while (this._availableBits < pendingBits) {\n            await this._produceMoreBits();\n        }\n        let result = 0;\n        while (pendingBits > 0) {\n            const hash = this._buffers[this._currentBufferIndex];\n            const available = Math.min(hash.availableBits(), pendingBits);\n            const took = hash.take(available);\n            result = (result << available) + took;\n            pendingBits -= available;\n            this._availableBits -= available;\n            if (hash.availableBits() === 0) {\n                this._currentBufferIndex++;\n            }\n        }\n        return result;\n    }\n    untake(bits) {\n        let pendingBits = bits;\n        while (pendingBits > 0) {\n            const hash = this._buffers[this._currentBufferIndex];\n            const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n            hash.untake(availableForUntake);\n            pendingBits -= availableForUntake;\n            this._availableBits += availableForUntake;\n            if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n                this._depth--;\n                this._currentBufferIndex--;\n            }\n        }\n    }\n    async _produceMoreBits() {\n        this._depth++;\n        const value = this._depth > 0 ? (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)([this._value, Uint8Array.from([this._depth])]) : this._value;\n        const hashValue = await this._hashFn(value);\n        const buffer = new ConsumableBuffer(hashValue);\n        this._buffers.push(buffer);\n        this._availableBits += buffer.availableBits();\n    }\n}\nconst START_MASKS = [\n    0b11111111,\n    0b11111110,\n    0b11111100,\n    0b11111000,\n    0b11110000,\n    0b11100000,\n    0b11000000,\n    0b10000000\n];\nconst STOP_MASKS = [\n    0b00000001,\n    0b00000011,\n    0b00000111,\n    0b00001111,\n    0b00011111,\n    0b00111111,\n    0b01111111,\n    0b11111111\n];\nclass ConsumableBuffer {\n    _value;\n    _currentBytePos;\n    _currentBitPos;\n    constructor(value) {\n        this._value = value;\n        this._currentBytePos = value.length - 1;\n        this._currentBitPos = 7;\n    }\n    availableBits() {\n        return this._currentBitPos + 1 + this._currentBytePos * 8;\n    }\n    totalBits() {\n        return this._value.length * 8;\n    }\n    take(bits) {\n        let pendingBits = bits;\n        let result = 0;\n        while (pendingBits > 0 && this._haveBits()) {\n            const byte = this._value[this._currentBytePos];\n            const availableBits = this._currentBitPos + 1;\n            const taking = Math.min(availableBits, pendingBits);\n            const value = byteBitsToInt(byte, availableBits - taking, taking);\n            result = (result << taking) + value;\n            pendingBits -= taking;\n            this._currentBitPos -= taking;\n            if (this._currentBitPos < 0) {\n                this._currentBitPos = 7;\n                this._currentBytePos--;\n            }\n        }\n        return result;\n    }\n    untake(bits) {\n        this._currentBitPos += bits;\n        while (this._currentBitPos > 7) {\n            this._currentBitPos -= 8;\n            this._currentBytePos += 1;\n        }\n    }\n    _haveBits() {\n        return this._currentBytePos >= 0;\n    }\n}\nfunction byteBitsToInt(byte, start, length) {\n    const mask = maskFor(start, length);\n    return (byte & mask) >>> start;\n}\nfunction maskFor(start, length) {\n    return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)];\n}\n//# sourceMappingURL=consumable-hash.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/consumable-hash.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/dir-sharded.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/dir-sharded.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID_V0: () => (/* binding */ CID_V0),\n/* harmony export */   CID_V1: () => (/* binding */ CID_V1),\n/* harmony export */   DirSharded: () => (/* binding */ DirSharded)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var hamt_sharding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hamt-sharding */ \"./node_modules/hamt-sharding/dist/src/index.js\");\n/* harmony import */ var hamt_sharding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hamt-sharding */ \"./node_modules/hamt-sharding/dist/src/bucket.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _hamt_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hamt-constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js\");\n/* harmony import */ var _persist_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./persist.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js\");\n\n\n\n\n\n\nclass Dir {\n    options;\n    root;\n    dir;\n    path;\n    dirty;\n    flat;\n    parent;\n    parentKey;\n    unixfs;\n    mode;\n    mtime;\n    cid;\n    size;\n    nodeSize;\n    constructor(props, options) {\n        this.options = options ?? {};\n        this.root = props.root;\n        this.dir = props.dir;\n        this.path = props.path;\n        this.dirty = props.dirty;\n        this.flat = props.flat;\n        this.parent = props.parent;\n        this.parentKey = props.parentKey;\n        this.unixfs = props.unixfs;\n        this.mode = props.mode;\n        this.mtime = props.mtime;\n    }\n}\nclass DirSharded extends Dir {\n    _bucket;\n    constructor(props, options) {\n        super(props, options);\n        this._bucket = (0,hamt_sharding__WEBPACK_IMPORTED_MODULE_4__.createHAMT)({\n            hashFn: _hamt_constants_js__WEBPACK_IMPORTED_MODULE_2__.hamtHashFn,\n            bits: 8\n        });\n    }\n    async put(name, value) {\n        this.cid = undefined;\n        this.size = undefined;\n        this.nodeSize = undefined;\n        await this._bucket.put(name, value);\n    }\n    async get(name) {\n        return this._bucket.get(name);\n    }\n    childCount() {\n        return this._bucket.leafCount();\n    }\n    directChildrenCount() {\n        return this._bucket.childrenCount();\n    }\n    onlyChild() {\n        return this._bucket.onlyChild();\n    }\n    async *eachChildSeries() {\n        for await (const { key, value } of this._bucket.eachLeafSeries()) {\n            yield {\n                key,\n                child: value\n            };\n        }\n    }\n    estimateNodeSize() {\n        if (this.nodeSize !== undefined) {\n            return this.nodeSize;\n        }\n        this.nodeSize = calculateSize(this._bucket, this, this.options);\n        return this.nodeSize;\n    }\n    async *flush(blockstore) {\n        for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n            yield {\n                ...entry,\n                path: this.path\n            };\n        }\n    }\n}\nasync function* flush(bucket, blockstore, shardRoot, options) {\n    const children = bucket._children;\n    const links = [];\n    let childrenSize = 0n;\n    for (let i = 0; i < children.length; i++) {\n        const child = children.get(i);\n        if (child == null) {\n            continue;\n        }\n        const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n        if (child instanceof hamt_sharding__WEBPACK_IMPORTED_MODULE_5__.Bucket) {\n            let shard;\n            for await (const subShard of flush(child, blockstore, null, options)) {\n                shard = subShard;\n            }\n            if (shard == null) {\n                throw new Error('Could not flush sharded directory, no subshard found');\n            }\n            links.push({\n                Name: labelPrefix,\n                Tsize: Number(shard.size),\n                Hash: shard.cid\n            });\n            childrenSize += shard.size;\n        }\n        else if (isDir(child.value)) {\n            const dir = child.value;\n            let flushedDir;\n            for await (const entry of dir.flush(blockstore)) {\n                flushedDir = entry;\n                yield flushedDir;\n            }\n            if (flushedDir == null) {\n                throw new Error('Did not flush dir');\n            }\n            const label = labelPrefix + child.key;\n            links.push({\n                Name: label,\n                Tsize: Number(flushedDir.size),\n                Hash: flushedDir.cid\n            });\n            childrenSize += flushedDir.size;\n        }\n        else {\n            const value = child.value;\n            if (value.cid == null) {\n                continue;\n            }\n            const label = labelPrefix + child.key;\n            const size = value.size;\n            links.push({\n                Name: label,\n                Tsize: Number(size),\n                Hash: value.cid\n            });\n            childrenSize += BigInt(size ?? 0);\n        }\n    }\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(children.bitField().reverse());\n    const dir = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__.UnixFS({\n        type: 'hamt-sharded-directory',\n        data,\n        fanout: BigInt(bucket.tableSize()),\n        hashType: _hamt_constants_js__WEBPACK_IMPORTED_MODULE_2__.hamtHashCode,\n        mtime: shardRoot?.mtime,\n        mode: shardRoot?.mode\n    });\n    const node = {\n        Data: dir.marshal(),\n        Links: links\n    };\n    const buffer = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)(node));\n    const cid = await (0,_persist_js__WEBPACK_IMPORTED_MODULE_3__.persist)(buffer, blockstore, options);\n    const size = BigInt(buffer.byteLength) + childrenSize;\n    yield {\n        cid,\n        unixfs: dir,\n        size\n    };\n}\nfunction isDir(obj) {\n    return typeof obj.flush === 'function';\n}\nfunction calculateSize(bucket, shardRoot, options) {\n    const children = bucket._children;\n    const links = [];\n    for (let i = 0; i < children.length; i++) {\n        const child = children.get(i);\n        if (child == null) {\n            continue;\n        }\n        const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n        if (child instanceof hamt_sharding__WEBPACK_IMPORTED_MODULE_5__.Bucket) {\n            const size = calculateSize(child, null, options);\n            links.push({\n                Name: labelPrefix,\n                Tsize: Number(size),\n                Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n            });\n        }\n        else if (typeof child.value.flush === 'function') {\n            const dir = child.value;\n            const size = dir.nodeSize();\n            links.push({\n                Name: labelPrefix + child.key,\n                Tsize: Number(size),\n                Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n            });\n        }\n        else {\n            const value = child.value;\n            if (value.cid == null) {\n                continue;\n            }\n            const label = labelPrefix + child.key;\n            const size = value.size;\n            links.push({\n                Name: label,\n                Tsize: Number(size),\n                Hash: value.cid\n            });\n        }\n    }\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(children.bitField().reverse());\n    const dir = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__.UnixFS({\n        type: 'hamt-sharded-directory',\n        data,\n        fanout: BigInt(bucket.tableSize()),\n        hashType: _hamt_constants_js__WEBPACK_IMPORTED_MODULE_2__.hamtHashCode,\n        mtime: shardRoot?.mtime,\n        mode: shardRoot?.mode\n    });\n    const buffer = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)({\n        Data: dir.marshal(),\n        Links: links\n    }));\n    return buffer.length;\n}\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nconst CID_V0 = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn');\nconst CID_V1 = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi');\n//# sourceMappingURL=dir-sharded.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/dir-sharded.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hamtBucketBits: () => (/* binding */ hamtBucketBits),\n/* harmony export */   hamtHashCode: () => (/* binding */ hamtHashCode),\n/* harmony export */   hamtHashFn: () => (/* binding */ hamtHashFn)\n/* harmony export */ });\n/* harmony import */ var _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/murmur3 */ \"./node_modules/@multiformats/murmur3/src/index.js\");\n\nconst hamtHashCode = BigInt(_multiformats_murmur3__WEBPACK_IMPORTED_MODULE_0__.murmur3128.code);\nconst hamtBucketBits = 8;\nasync function hamtHashFn(buf) {\n    return (await _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_0__.murmur3128.encode(buf))\n        // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n        // implementation only uses the first 64, so we must do the same\n        // for parity..\n        .subarray(0, 8)\n        // Invert buffer because that's how Go impl does it\n        .reverse();\n}\n//# sourceMappingURL=hamt-constants.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createShard: () => (/* binding */ createShard),\n/* harmony export */   recreateShardedDirectory: () => (/* binding */ recreateShardedDirectory),\n/* harmony export */   toPrefix: () => (/* binding */ toPrefix),\n/* harmony export */   updateShardedDirectory: () => (/* binding */ updateShardedDirectory)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ \"./node_modules/it-last/dist/src/index.js\");\n/* harmony import */ var sparse_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sparse-array */ \"./node_modules/sparse-array/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var _consumable_hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./consumable-hash.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/consumable-hash.js\");\n/* harmony import */ var _dir_sharded_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dir-sharded.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/dir-sharded.js\");\n/* harmony import */ var _hamt_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hamt-constants.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js\");\n/* harmony import */ var _persist_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./persist.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js\");\n\n\n\n\n// @ts-expect-error no types\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_8__.logger)('helia:unixfs:commands:utils:hamt-utils');\nconst toPrefix = (position) => {\n    return position\n        .toString(16)\n        .toUpperCase()\n        .padStart(2, '0')\n        .substring(0, 2);\n};\nconst createShard = async (blockstore, contents, options) => {\n    const shard = new _dir_sharded_js__WEBPACK_IMPORTED_MODULE_5__.DirSharded({\n        root: true,\n        dir: true,\n        parent: undefined,\n        parentKey: undefined,\n        path: '',\n        dirty: true,\n        flat: false,\n        mtime: options.mtime,\n        mode: options.mode\n    }, options);\n    for (let i = 0; i < contents.length; i++) {\n        await shard._bucket.put(contents[i].name, {\n            size: contents[i].size,\n            cid: contents[i].cid\n        });\n    }\n    const res = await (0,it_last__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(shard.flush(blockstore));\n    if (res == null) {\n        throw new Error('Flushing shard yielded no result');\n    }\n    return res;\n};\nconst updateShardedDirectory = async (path, blockstore, options) => {\n    // persist any metadata on the shard root\n    const shardRoot = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_9__.UnixFS.unmarshal(path[0].node.Data ?? new Uint8Array(0));\n    // this is always the same\n    const fanout = BigInt(Math.pow(2, _hamt_constants_js__WEBPACK_IMPORTED_MODULE_6__.hamtBucketBits));\n    // start from the leaf and ascend to the root\n    path.reverse();\n    let cid;\n    let node;\n    for (let i = 0; i < path.length; i++) {\n        const isRoot = i === path.length - 1;\n        const segment = path[i];\n        // go-ipfs uses little endian, that's why we have to\n        // reverse the bit field before storing it\n        const data = Uint8Array.from(segment.children.bitField().reverse());\n        const dir = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_9__.UnixFS({\n            type: 'hamt-sharded-directory',\n            data,\n            fanout,\n            hashType: _hamt_constants_js__WEBPACK_IMPORTED_MODULE_6__.hamtHashCode\n        });\n        if (isRoot) {\n            dir.mtime = shardRoot.mtime;\n            dir.mode = shardRoot.mode;\n        }\n        node = {\n            Data: dir.marshal(),\n            Links: segment.node.Links\n        };\n        const block = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare(node));\n        cid = await (0,_persist_js__WEBPACK_IMPORTED_MODULE_7__.persist)(block, blockstore, options);\n        if (!isRoot) {\n            // update link in parent sub-shard\n            const nextSegment = path[i + 1];\n            if (nextSegment == null) {\n                throw new Error('Was not operating on shard root but also had no parent?');\n            }\n            log('updating link in parent sub-shard with prefix %s', nextSegment.prefix);\n            nextSegment.node.Links = nextSegment.node.Links.filter(l => l.Name !== nextSegment.prefix);\n            nextSegment.node.Links.push({\n                Name: nextSegment.prefix,\n                Hash: cid,\n                Tsize: segment.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), block.byteLength)\n            });\n        }\n    }\n    if (cid == null || node == null) {\n        throw new Error('Noting persisted');\n    }\n    return { cid, node };\n};\nconst recreateShardedDirectory = async (cid, fileName, blockstore, options) => {\n    const wrapped = (0,_consumable_hash_js__WEBPACK_IMPORTED_MODULE_4__.wrapHash)(_hamt_constants_js__WEBPACK_IMPORTED_MODULE_6__.hamtHashFn);\n    const hash = wrapped((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)(fileName));\n    const path = [];\n    // descend the HAMT, loading each layer as we head towards the target child\n    while (true) {\n        const block = await blockstore.get(cid, options);\n        const node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n        const children = new sparse_array__WEBPACK_IMPORTED_MODULE_2__();\n        const index = await hash.take(_hamt_constants_js__WEBPACK_IMPORTED_MODULE_6__.hamtBucketBits);\n        const prefix = toPrefix(index);\n        path.push({\n            prefix,\n            children,\n            node\n        });\n        let childLink;\n        // update sparsearray child layout - the bitfield is used as the data field for the\n        // intermediate DAG node so this is required to generate consistent hashes\n        for (const link of node.Links) {\n            const linkName = link.Name ?? '';\n            if (linkName.length < 2) {\n                throw new Error('Invalid HAMT - link name was too short');\n            }\n            const position = parseInt(linkName.substring(0, 2), 16);\n            children.set(position, true);\n            // we found the child we are looking for\n            if (linkName.startsWith(prefix)) {\n                childLink = link;\n            }\n        }\n        if (childLink == null) {\n            log('no link found with prefix %s for %s', prefix, fileName);\n            // hash.untake(hamtBucketBits)\n            break;\n        }\n        const linkName = childLink.Name ?? '';\n        if (linkName.length < 2) {\n            throw new Error('Invalid HAMT - link name was too short');\n        }\n        if (linkName.length === 2) {\n            // found sub-shard\n            cid = childLink.Hash;\n            log('descend into sub-shard with prefix %s', linkName);\n            continue;\n        }\n        break;\n    }\n    return { path, hash };\n};\n//# sourceMappingURL=hamt-utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/is-over-shard-threshold.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/is-over-shard-threshold.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isOverShardThreshold: () => (/* binding */ isOverShardThreshold)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var _dir_sharded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dir-sharded.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/dir-sharded.js\");\n\n\n\n/**\n * Estimate node size only based on DAGLink name and CID byte lengths\n * https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n *\n * If the node is a hamt sharded directory the calculation is based on if it was a regular directory.\n */\nasync function isOverShardThreshold(node, blockstore, threshold, options) {\n    if (node.Data == null) {\n        throw new Error('DagPB node had no data');\n    }\n    const unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_2__.UnixFS.unmarshal(node.Data);\n    let size;\n    if (unixfs.type === 'directory') {\n        size = estimateNodeSize(node);\n    }\n    else if (unixfs.type === 'hamt-sharded-directory') {\n        size = await estimateShardSize(node, 0, threshold, blockstore, options);\n    }\n    else {\n        throw new Error('Can only estimate the size of directories or shards');\n    }\n    return size > threshold;\n}\nfunction estimateNodeSize(node) {\n    let size = 0;\n    // estimate size only based on DAGLink name and CID byte lengths\n    // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n    for (const link of node.Links) {\n        size += (link.Name ?? '').length;\n        size += link.Hash.version === 1 ? _dir_sharded_js__WEBPACK_IMPORTED_MODULE_1__.CID_V1.bytes.byteLength : _dir_sharded_js__WEBPACK_IMPORTED_MODULE_1__.CID_V0.bytes.byteLength;\n    }\n    return size;\n}\nasync function estimateShardSize(node, current, max, blockstore, options) {\n    if (current > max) {\n        return max;\n    }\n    if (node.Data == null) {\n        return current;\n    }\n    const unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_2__.UnixFS.unmarshal(node.Data);\n    if (!unixfs.isDirectory()) {\n        return current;\n    }\n    for (const link of node.Links) {\n        let name = link.Name ?? '';\n        // remove hamt hash prefix from name\n        name = name.substring(2);\n        current += name.length;\n        current += link.Hash.bytes.byteLength;\n        if (link.Hash.code === _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code) {\n            const block = await blockstore.get(link.Hash, options);\n            const node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n            current += await estimateShardSize(node, current, max, blockstore, options);\n        }\n    }\n    return current;\n}\n//# sourceMappingURL=is-over-shard-threshold.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/is-over-shard-threshold.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   persist: () => (/* binding */ persist)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n\n\n\nconst persist = async (buffer, blockstore, options) => {\n    if (options.codec == null) {\n        options.codec = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__;\n    }\n    const multihash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(buffer);\n    const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.create(options.cidVersion, options.codec.code, multihash);\n    await blockstore.put(cid, buffer, {\n        ...options,\n        signal: options.signal\n    });\n    return cid;\n};\n//# sourceMappingURL=persist.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/remove-link.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/remove-link.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeLink: () => (/* binding */ removeLink)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _hamt_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hamt-utils.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js\");\n/* harmony import */ var _is_over_shard_threshold_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is-over-shard-threshold.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/is-over-shard-threshold.js\");\n/* harmony import */ var _persist_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./persist.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/persist.js\");\n\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.logger)('helia:unixfs:utils:remove-link');\nasync function removeLink(parent, name, blockstore, options) {\n    if (parent.node.Data == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidPBNodeError('Parent node had no data');\n    }\n    const meta = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_7__.UnixFS.unmarshal(parent.node.Data);\n    if (meta.type === 'hamt-sharded-directory') {\n        log(`removing ${name} from sharded directory`);\n        const result = await removeFromShardedDirectory(parent, name, blockstore, options);\n        if (!(await (0,_is_over_shard_threshold_js__WEBPACK_IMPORTED_MODULE_4__.isOverShardThreshold)(result.node, blockstore, options.shardSplitThresholdBytes, options))) {\n            log('converting shard to flat directory %c', parent.cid);\n            return convertToFlatDirectory(result, blockstore, options);\n        }\n        return result;\n    }\n    log(`removing link ${name} regular directory`);\n    return removeFromDirectory(parent, name, blockstore, options);\n}\nconst removeFromDirectory = async (parent, name, blockstore, options) => {\n    // Remove existing link if it exists\n    parent.node.Links = parent.node.Links.filter((link) => {\n        return link.Name !== name;\n    });\n    const parentBlock = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(parent.node);\n    const parentCid = await (0,_persist_js__WEBPACK_IMPORTED_MODULE_5__.persist)(parentBlock, blockstore, {\n        ...options,\n        cidVersion: parent.cid.version\n    });\n    log(`Updated regular directory ${parentCid}`);\n    return {\n        node: parent.node,\n        cid: parentCid\n    };\n};\nconst removeFromShardedDirectory = async (parent, name, blockstore, options) => {\n    const { path } = await (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_3__.recreateShardedDirectory)(parent.cid, name, blockstore, options);\n    const finalSegment = path[path.length - 1];\n    if (finalSegment == null) {\n        throw new Error('Invalid HAMT, could not generate path');\n    }\n    const linkName = finalSegment.node.Links.filter(l => (l.Name ?? '').substring(2) === name).map(l => l.Name).pop();\n    if (linkName == null) {\n        throw new Error('File not found');\n    }\n    const prefix = linkName.substring(0, 2);\n    const index = parseInt(prefix, 16);\n    // remove the file from the shard\n    finalSegment.node.Links = finalSegment.node.Links.filter(link => link.Name !== linkName);\n    finalSegment.children.unset(index);\n    if (finalSegment.node.Links.length === 1) {\n        // replace the subshard with the last remaining file in the parent\n        while (true) {\n            if (path.length === 1) {\n                break;\n            }\n            const segment = path[path.length - 1];\n            if (segment == null || segment.node.Links.length > 1) {\n                break;\n            }\n            // remove final segment\n            path.pop();\n            const nextSegment = path[path.length - 1];\n            if (nextSegment == null) {\n                break;\n            }\n            const link = segment.node.Links[0];\n            nextSegment.node.Links = nextSegment.node.Links.filter(l => !(l.Name ?? '').startsWith(nextSegment.prefix));\n            nextSegment.node.Links.push({\n                Hash: link.Hash,\n                Name: `${nextSegment.prefix}${(link.Name ?? '').substring(2)}`,\n                Tsize: link.Tsize\n            });\n        }\n    }\n    return (0,_hamt_utils_js__WEBPACK_IMPORTED_MODULE_3__.updateShardedDirectory)(path, blockstore, options);\n};\nconst convertToFlatDirectory = async (parent, blockstore, options) => {\n    if (parent.node.Data == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParametersError('Invalid parent passed to convertToFlatDirectory');\n    }\n    const rootNode = {\n        Links: []\n    };\n    const dir = await (0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_1__.exporter)(parent.cid, blockstore);\n    if (dir.type !== 'directory') {\n        throw new Error('Unexpected node type');\n    }\n    for await (const entry of dir.content()) {\n        let tsize = 0;\n        if (entry.node instanceof Uint8Array) {\n            tsize = entry.node.byteLength;\n        }\n        else {\n            tsize = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(entry.node).length;\n        }\n        rootNode.Links.push({\n            Hash: entry.cid,\n            Name: entry.name,\n            Tsize: tsize\n        });\n    }\n    // copy mode/mtime over if set\n    const oldUnixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_7__.UnixFS.unmarshal(parent.node.Data);\n    rootNode.Data = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_7__.UnixFS({ type: 'directory', mode: oldUnixfs.mode, mtime: oldUnixfs.mtime }).marshal();\n    const block = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode(_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare(rootNode));\n    const cid = await (0,_persist_js__WEBPACK_IMPORTED_MODULE_5__.persist)(block, blockstore, {\n        codec: _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__,\n        cidVersion: parent.cid.version,\n        signal: options.signal\n    });\n    return {\n        cid,\n        node: rootNode\n    };\n};\n//# sourceMappingURL=remove-link.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/remove-link.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   updatePathCids: () => (/* binding */ updatePathCids)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-unixfs-exporter */ \"./node_modules/ipfs-unixfs-exporter/dist/src/index.js\");\n/* harmony import */ var it_all__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-all */ \"./node_modules/it-all/dist/src/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n/* harmony import */ var _add_link_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add-link.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js\");\n/* harmony import */ var _cid_to_directory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cid-to-directory.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js\");\n/* harmony import */ var _cid_to_pblink_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cid-to-pblink.js */ \"./node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js\");\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.logger)('helia:unixfs:components:utils:resolve');\nasync function resolve(cid, path, blockstore, options) {\n    if (path == null || path === '') {\n        return { cid };\n    }\n    const p = `/ipfs/${cid}${path == null ? '' : `/${path}`}`;\n    const segments = await (0,it_all__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((0,ipfs_unixfs_exporter__WEBPACK_IMPORTED_MODULE_0__.walkPath)(p, blockstore, options));\n    if (segments.length === 0) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DoesNotExistError('Could not find path in directory');\n    }\n    log('resolved %s to %c', path, cid);\n    return {\n        cid: segments[segments.length - 1].cid,\n        path,\n        segments\n    };\n}\n/**\n * Where we have descended into a DAG to update a child node, ascend up the DAG creating\n * new hashes and blocks for the changed content\n */\nasync function updatePathCids(cid, result, blockstore, options) {\n    if (result.segments == null || result.segments.length === 0) {\n        return cid;\n    }\n    let child = result.segments.pop();\n    if (child == null) {\n        throw new Error('Insufficient segments');\n    }\n    child.cid = cid;\n    result.segments.reverse();\n    for (const parent of result.segments) {\n        const [directory, pblink] = await Promise.all([\n            (0,_cid_to_directory_js__WEBPACK_IMPORTED_MODULE_4__.cidToDirectory)(parent.cid, blockstore, options),\n            (0,_cid_to_pblink_js__WEBPACK_IMPORTED_MODULE_5__.cidToPBLink)(child.cid, child.name, blockstore, options)\n        ]);\n        const result = await (0,_add_link_js__WEBPACK_IMPORTED_MODULE_3__.addLink)(directory, pblink, blockstore, {\n            ...options,\n            allowOverwriting: true,\n            cidVersion: cid.version\n        });\n        cid = result.cid;\n        parent.cid = cid;\n        child = parent;\n    }\n    return cid;\n}\n//# sourceMappingURL=resolve.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlreadyExistsError: () => (/* binding */ AlreadyExistsError),\n/* harmony export */   DoesNotExistError: () => (/* binding */ DoesNotExistError),\n/* harmony export */   InvalidPBNodeError: () => (/* binding */ InvalidPBNodeError),\n/* harmony export */   InvalidParametersError: () => (/* binding */ InvalidParametersError),\n/* harmony export */   NoContentError: () => (/* binding */ NoContentError),\n/* harmony export */   NotADirectoryError: () => (/* binding */ NotADirectoryError),\n/* harmony export */   NotAFileError: () => (/* binding */ NotAFileError),\n/* harmony export */   NotUnixFSError: () => (/* binding */ NotUnixFSError),\n/* harmony export */   UnixFSError: () => (/* binding */ UnixFSError),\n/* harmony export */   UnknownError: () => (/* binding */ UnknownError)\n/* harmony export */ });\nclass UnixFSError extends Error {\n    name;\n    code;\n    constructor(message, name, code) {\n        super(message);\n        this.name = name;\n        this.code = code;\n    }\n}\nclass NotUnixFSError extends UnixFSError {\n    constructor(message = 'not a Unixfs node') {\n        super(message, 'NotUnixFSError', 'ERR_NOT_UNIXFS');\n    }\n}\nclass InvalidPBNodeError extends UnixFSError {\n    constructor(message = 'invalid PBNode') {\n        super(message, 'InvalidPBNodeError', 'ERR_INVALID_PBNODE');\n    }\n}\nclass UnknownError extends UnixFSError {\n    constructor(message = 'unknown error') {\n        super(message, 'InvalidPBNodeError', 'ERR_UNKNOWN_ERROR');\n    }\n}\nclass AlreadyExistsError extends UnixFSError {\n    constructor(message = 'path already exists') {\n        super(message, 'AlreadyExistsError', 'ERR_ALREADY_EXISTS');\n    }\n}\nclass DoesNotExistError extends UnixFSError {\n    constructor(message = 'path does not exist') {\n        super(message, 'DoesNotExistError', 'ERR_DOES_NOT_EXIST');\n    }\n}\nclass NoContentError extends UnixFSError {\n    constructor(message = 'no content') {\n        super(message, 'NoContentError', 'ERR_NO_CONTENT');\n    }\n}\nclass NotAFileError extends UnixFSError {\n    constructor(message = 'not a file') {\n        super(message, 'NotAFileError', 'ERR_NOT_A_FILE');\n    }\n}\nclass NotADirectoryError extends UnixFSError {\n    constructor(message = 'not a directory') {\n        super(message, 'NotADirectoryError', 'ERR_NOT_A_DIRECTORY');\n    }\n}\nclass InvalidParametersError extends UnixFSError {\n    constructor(message = 'invalid parameters') {\n        super(message, 'InvalidParametersError', 'ERR_INVALID_PARAMETERS');\n    }\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globSource: () => (/* reexport safe */ _utils_glob_source_js__WEBPACK_IMPORTED_MODULE_9__.globSource),\n/* harmony export */   unixfs: () => (/* binding */ unixfs),\n/* harmony export */   urlSource: () => (/* reexport safe */ _utils_url_source_js__WEBPACK_IMPORTED_MODULE_10__.urlSource)\n/* harmony export */ });\n/* harmony import */ var _commands_add_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands/add.js */ \"./node_modules/@helia/unixfs/dist/src/commands/add.js\");\n/* harmony import */ var _commands_cat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands/cat.js */ \"./node_modules/@helia/unixfs/dist/src/commands/cat.js\");\n/* harmony import */ var _commands_chmod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commands/chmod.js */ \"./node_modules/@helia/unixfs/dist/src/commands/chmod.js\");\n/* harmony import */ var _commands_cp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commands/cp.js */ \"./node_modules/@helia/unixfs/dist/src/commands/cp.js\");\n/* harmony import */ var _commands_ls_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commands/ls.js */ \"./node_modules/@helia/unixfs/dist/src/commands/ls.js\");\n/* harmony import */ var _commands_mkdir_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./commands/mkdir.js */ \"./node_modules/@helia/unixfs/dist/src/commands/mkdir.js\");\n/* harmony import */ var _commands_rm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commands/rm.js */ \"./node_modules/@helia/unixfs/dist/src/commands/rm.js\");\n/* harmony import */ var _commands_stat_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./commands/stat.js */ \"./node_modules/@helia/unixfs/dist/src/commands/stat.js\");\n/* harmony import */ var _commands_touch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commands/touch.js */ \"./node_modules/@helia/unixfs/dist/src/commands/touch.js\");\n/* harmony import */ var _utils_glob_source_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/glob-source.js */ \"?8965\");\n/* harmony import */ var _utils_url_source_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/url-source.js */ \"./node_modules/@helia/unixfs/dist/src/utils/url-source.js\");\n/**\n * @packageDocumentation\n *\n * `@helia/unixfs` is an implementation of a {@link https://github.com/ipfs/specs/blob/main/UNIXFS.md UnixFS filesystem} compatible with {@link https://github.com/ipfs/helia Helia}.\n *\n * See the [API docs](https://ipfs.github.io/helia/modules/_helia_unixfs.html) for all available operations.\n *\n * @example Creating files and directories\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n *\n * const helia = createHelia({\n *   // ... helia config\n * })\n * const fs = unixfs(helia)\n *\n * // create an empty dir and a file, then add the file to the dir\n * const emptyDirCid = await fs.addDirectory()\n * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n * const updateDirCid = await fs.cp(fileCid, emptyDirCid, 'foo.txt')\n *\n * // or doing the same thing as a stream\n * for await (const entry of fs.addAll([{\n *   path: 'foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3])\n * }])) {\n *   console.info(entry)\n * }\n * ```\n *\n * @example Recursively adding a directory\n *\n * Node.js-compatibly environments only:\n *\n * ```typescript\n * import { globSource } from '@helia/unixfs'\n *\n * for await (const entry of fs.addAll(globSource('path/to/containing/dir', 'glob-pattern'))) {\n *   console.info(entry)\n * }\n * ```\n */\n\n\n\n\n\n\n\n\n\nclass DefaultUnixFS {\n    components;\n    constructor(components) {\n        this.components = components;\n    }\n    async *addAll(source, options = {}) {\n        yield* (0,_commands_add_js__WEBPACK_IMPORTED_MODULE_0__.addAll)(source, this.components.blockstore, options);\n    }\n    async addBytes(bytes, options = {}) {\n        return (0,_commands_add_js__WEBPACK_IMPORTED_MODULE_0__.addBytes)(bytes, this.components.blockstore, options);\n    }\n    async addByteStream(bytes, options = {}) {\n        return (0,_commands_add_js__WEBPACK_IMPORTED_MODULE_0__.addByteStream)(bytes, this.components.blockstore, options);\n    }\n    async addFile(file, options = {}) {\n        return (0,_commands_add_js__WEBPACK_IMPORTED_MODULE_0__.addFile)(file, this.components.blockstore, options);\n    }\n    async addDirectory(dir = {}, options = {}) {\n        return (0,_commands_add_js__WEBPACK_IMPORTED_MODULE_0__.addDirectory)(dir, this.components.blockstore, options);\n    }\n    async *cat(cid, options = {}) {\n        yield* (0,_commands_cat_js__WEBPACK_IMPORTED_MODULE_1__.cat)(cid, this.components.blockstore, options);\n    }\n    async chmod(cid, mode, options = {}) {\n        return (0,_commands_chmod_js__WEBPACK_IMPORTED_MODULE_2__.chmod)(cid, mode, this.components.blockstore, options);\n    }\n    async cp(source, target, name, options = {}) {\n        return (0,_commands_cp_js__WEBPACK_IMPORTED_MODULE_3__.cp)(source, target, name, this.components.blockstore, options);\n    }\n    async *ls(cid, options = {}) {\n        yield* (0,_commands_ls_js__WEBPACK_IMPORTED_MODULE_4__.ls)(cid, this.components.blockstore, options);\n    }\n    async mkdir(cid, dirname, options = {}) {\n        return (0,_commands_mkdir_js__WEBPACK_IMPORTED_MODULE_5__.mkdir)(cid, dirname, this.components.blockstore, options);\n    }\n    async rm(cid, path, options = {}) {\n        return (0,_commands_rm_js__WEBPACK_IMPORTED_MODULE_6__.rm)(cid, path, this.components.blockstore, options);\n    }\n    async stat(cid, options = {}) {\n        return (0,_commands_stat_js__WEBPACK_IMPORTED_MODULE_7__.stat)(cid, this.components.blockstore, options);\n    }\n    async touch(cid, options = {}) {\n        return (0,_commands_touch_js__WEBPACK_IMPORTED_MODULE_8__.touch)(cid, this.components.blockstore, options);\n    }\n}\n/**\n * Create a {@link UnixFS} instance for use with {@link https://github.com/ipfs/helia Helia}\n */\nfunction unixfs(helia) {\n    return new DefaultUnixFS(helia);\n}\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/unixfs/dist/src/utils/url-source.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@helia/unixfs/dist/src/utils/url-source.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urlSource: () => (/* binding */ urlSource)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/@helia/unixfs/dist/src/errors.js\");\n\nfunction urlSource(url, options) {\n    return {\n        path: decodeURIComponent(new URL(url).pathname.split('/').pop() ?? ''),\n        content: readURLContent(url, options)\n    };\n}\nasync function* readURLContent(url, options) {\n    const response = await globalThis.fetch(url, options);\n    if (response.body == null) {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.UnknownError('HTTP response did not have a body');\n    }\n    const reader = response.body.getReader();\n    try {\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n                return;\n            }\n            if (value != null) {\n                yield value;\n            }\n        }\n    }\n    finally {\n        reader.releaseLock();\n    }\n}\n//# sourceMappingURL=url-source.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/unixfs/dist/src/utils/url-source.js?");

/***/ }),

/***/ "./node_modules/@multiformats/murmur3/src/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@multiformats/murmur3/src/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   murmur3128: () => (/* binding */ murmur3128),\n/* harmony export */   murmur332: () => (/* binding */ murmur332),\n/* harmony export */   murmur364: () => (/* binding */ murmur364)\n/* harmony export */ });\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats */ \"./node_modules/multiformats/dist/src/index.js\");\n/* harmony import */ var multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/hashes/hasher */ \"./node_modules/multiformats/dist/src/hashes/hasher.js\");\n/* harmony import */ var murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! murmurhash3js-revisited */ \"./node_modules/murmurhash3js-revisited/index.js\");\n\n\n// @ts-expect-error no types\n\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nconst murmur332 = (0,multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__.x86.hash32(input))\n})\n\nconst murmur3128 = (0,multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => multiformats__WEBPACK_IMPORTED_MODULE_0__.bytes.fromHex(murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nconst murmur364 = (0,multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => multiformats__WEBPACK_IMPORTED_MODULE_0__.bytes.fromHex(murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__.x64.hash128(input)).subarray(0, 8)\n})\n\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/murmur3/src/index.js?");

/***/ }),

/***/ "./node_modules/hamt-sharding/dist/src/bucket.js":
/*!*******************************************************!*\
  !*** ./node_modules/hamt-sharding/dist/src/bucket.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bucket: () => (/* binding */ Bucket)\n/* harmony export */ });\n/* harmony import */ var sparse_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sparse-array */ \"./node_modules/sparse-array/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n// @ts-expect-error no types\n\n\nclass Bucket {\n    _options;\n    _popCount;\n    _parent;\n    _posAtParent;\n    _children;\n    key;\n    constructor(options, parent, posAtParent = 0) {\n        this._options = options;\n        this._popCount = 0;\n        this._parent = parent;\n        this._posAtParent = posAtParent;\n        this._children = new sparse_array__WEBPACK_IMPORTED_MODULE_0__();\n        this.key = null;\n    }\n    async put(key, value) {\n        const place = await this._findNewBucketAndPos(key);\n        place.bucket._putAt(place, key, value);\n    }\n    async get(key) {\n        const child = await this._findChild(key);\n        if (child != null) {\n            return child.value;\n        }\n    }\n    async del(key) {\n        const place = await this._findPlace(key);\n        const child = place.bucket._at(place.pos);\n        if (child != null && child.key === key) {\n            place.bucket._delAt(place.pos);\n        }\n    }\n    leafCount() {\n        const children = this._children.compactArray();\n        return children.reduce((acc, child) => {\n            if (child instanceof Bucket) {\n                return acc + child.leafCount();\n            }\n            return acc + 1;\n        }, 0);\n    }\n    childrenCount() {\n        return this._children.length;\n    }\n    onlyChild() {\n        return this._children.get(0);\n    }\n    *eachLeafSeries() {\n        const children = this._children.compactArray();\n        for (const child of children) {\n            if (child instanceof Bucket) {\n                yield* child.eachLeafSeries();\n            }\n            else {\n                yield child;\n            }\n        }\n    }\n    serialize(map, reduce) {\n        const acc = [];\n        // serialize to a custom non-sparse representation\n        return reduce(this._children.reduce((acc, child, index) => {\n            if (child != null) {\n                if (child instanceof Bucket) {\n                    acc.push(child.serialize(map, reduce));\n                }\n                else {\n                    acc.push(map(child, index));\n                }\n            }\n            return acc;\n        }, acc));\n    }\n    async asyncTransform(asyncMap, asyncReduce) {\n        return asyncTransformBucket(this, asyncMap, asyncReduce);\n    }\n    toJSON() {\n        return this.serialize(mapNode, reduceNodes);\n    }\n    prettyPrint() {\n        return JSON.stringify(this.toJSON(), null, '  ');\n    }\n    tableSize() {\n        return Math.pow(2, this._options.bits);\n    }\n    async _findChild(key) {\n        const result = await this._findPlace(key);\n        const child = result.bucket._at(result.pos);\n        if (child instanceof Bucket) {\n            // should not be possible, this._findPlace should always\n            // return a location for a child, not a bucket\n            return undefined;\n        }\n        if (child != null && child.key === key) {\n            return child;\n        }\n    }\n    async _findPlace(key) {\n        const hashValue = this._options.hash(typeof key === 'string' ? (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(key) : key);\n        const index = await hashValue.take(this._options.bits);\n        const child = this._children.get(index);\n        if (child instanceof Bucket) {\n            return child._findPlace(hashValue);\n        }\n        return {\n            bucket: this,\n            pos: index,\n            hash: hashValue,\n            existingChild: child\n        };\n    }\n    async _findNewBucketAndPos(key) {\n        const place = await this._findPlace(key);\n        if ((place.existingChild != null) && place.existingChild.key !== key) {\n            // conflict\n            const bucket = new Bucket(this._options, place.bucket, place.pos);\n            place.bucket._putObjectAt(place.pos, bucket);\n            // put the previous value\n            const newPlace = await bucket._findPlace(place.existingChild.hash);\n            newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n            return bucket._findNewBucketAndPos(place.hash);\n        }\n        // no conflict, we found the place\n        return place;\n    }\n    _putAt(place, key, value) {\n        this._putObjectAt(place.pos, {\n            key,\n            value,\n            hash: place.hash\n        });\n    }\n    _putObjectAt(pos, object) {\n        if (this._children.get(pos) == null) {\n            this._popCount++;\n        }\n        this._children.set(pos, object);\n    }\n    _delAt(pos) {\n        if (pos === -1) {\n            throw new Error('Invalid position');\n        }\n        if (this._children.get(pos) != null) {\n            this._popCount--;\n        }\n        this._children.unset(pos);\n        this._level();\n    }\n    _level() {\n        if (this._parent != null && this._popCount <= 1) {\n            if (this._popCount === 1) {\n                // remove myself from parent, replacing me with my only child\n                const onlyChild = this._children.find(exists);\n                if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n                    const hash = onlyChild.hash;\n                    hash.untake(this._options.bits);\n                    const place = {\n                        pos: this._posAtParent,\n                        hash,\n                        bucket: this._parent\n                    };\n                    this._parent._putAt(place, onlyChild.key, onlyChild.value);\n                }\n            }\n            else {\n                this._parent._delAt(this._posAtParent);\n            }\n        }\n    }\n    _at(index) {\n        return this._children.get(index);\n    }\n}\nfunction exists(o) {\n    return Boolean(o);\n}\nfunction mapNode(node, _) {\n    return node.key;\n}\nfunction reduceNodes(nodes) {\n    return nodes;\n}\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n    const output = [];\n    for (const child of bucket._children.compactArray()) {\n        if (child instanceof Bucket) {\n            await asyncTransformBucket(child, asyncMap, asyncReduce);\n        }\n        else {\n            const mappedChildren = await asyncMap(child);\n            output.push({\n                bitField: bucket._children.bitField(),\n                children: mappedChildren\n            });\n        }\n    }\n    return asyncReduce(output);\n}\n//# sourceMappingURL=bucket.js.map\n\n//# sourceURL=webpack://ems/./node_modules/hamt-sharding/dist/src/bucket.js?");

/***/ }),

/***/ "./node_modules/hamt-sharding/dist/src/consumable-buffer.js":
/*!******************************************************************!*\
  !*** ./node_modules/hamt-sharding/dist/src/consumable-buffer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsumableBuffer: () => (/* binding */ ConsumableBuffer)\n/* harmony export */ });\nconst START_MASKS = [\n    0b11111111,\n    0b11111110,\n    0b11111100,\n    0b11111000,\n    0b11110000,\n    0b11100000,\n    0b11000000,\n    0b10000000\n];\nconst STOP_MASKS = [\n    0b00000001,\n    0b00000011,\n    0b00000111,\n    0b00001111,\n    0b00011111,\n    0b00111111,\n    0b01111111,\n    0b11111111\n];\nclass ConsumableBuffer {\n    _value;\n    _currentBytePos;\n    _currentBitPos;\n    constructor(value) {\n        this._value = value;\n        this._currentBytePos = value.length - 1;\n        this._currentBitPos = 7;\n    }\n    availableBits() {\n        return this._currentBitPos + 1 + this._currentBytePos * 8;\n    }\n    totalBits() {\n        return this._value.length * 8;\n    }\n    take(bits) {\n        let pendingBits = bits;\n        let result = 0;\n        while (pendingBits > 0 && this._haveBits()) {\n            const byte = this._value[this._currentBytePos];\n            const availableBits = this._currentBitPos + 1;\n            const taking = Math.min(availableBits, pendingBits);\n            const value = byteBitsToInt(byte, availableBits - taking, taking);\n            result = (result << taking) + value;\n            pendingBits -= taking;\n            this._currentBitPos -= taking;\n            if (this._currentBitPos < 0) {\n                this._currentBitPos = 7;\n                this._currentBytePos--;\n            }\n        }\n        return result;\n    }\n    untake(bits) {\n        this._currentBitPos += bits;\n        while (this._currentBitPos > 7) {\n            this._currentBitPos -= 8;\n            this._currentBytePos += 1;\n        }\n    }\n    _haveBits() {\n        return this._currentBytePos >= 0;\n    }\n}\nfunction byteBitsToInt(byte, start, length) {\n    const mask = maskFor(start, length);\n    return (byte & mask) >>> start;\n}\nfunction maskFor(start, length) {\n    return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)];\n}\n//# sourceMappingURL=consumable-buffer.js.map\n\n//# sourceURL=webpack://ems/./node_modules/hamt-sharding/dist/src/consumable-buffer.js?");

/***/ }),

/***/ "./node_modules/hamt-sharding/dist/src/consumable-hash.js":
/*!****************************************************************!*\
  !*** ./node_modules/hamt-sharding/dist/src/consumable-hash.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfiniteHash: () => (/* binding */ InfiniteHash),\n/* harmony export */   wrapHash: () => (/* binding */ wrapHash)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var _consumable_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consumable-buffer.js */ \"./node_modules/hamt-sharding/dist/src/consumable-buffer.js\");\n\n\nfunction wrapHash(hashFn) {\n    function hashing(value) {\n        if (value instanceof InfiniteHash) {\n            // already a hash. return it\n            return value;\n        }\n        else {\n            return new InfiniteHash(value, hashFn);\n        }\n    }\n    return hashing;\n}\nclass InfiniteHash {\n    _value;\n    _hashFn;\n    _depth;\n    _availableBits;\n    _currentBufferIndex;\n    _buffers;\n    constructor(value, hashFn) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('can only hash Uint8Arrays');\n        }\n        this._value = value;\n        this._hashFn = hashFn;\n        this._depth = -1;\n        this._availableBits = 0;\n        this._currentBufferIndex = 0;\n        this._buffers = [];\n    }\n    async take(bits) {\n        let pendingBits = bits;\n        while (this._availableBits < pendingBits) {\n            await this._produceMoreBits();\n        }\n        let result = 0;\n        while (pendingBits > 0) {\n            const hash = this._buffers[this._currentBufferIndex];\n            const available = Math.min(hash.availableBits(), pendingBits);\n            const took = hash.take(available);\n            result = (result << available) + took;\n            pendingBits -= available;\n            this._availableBits -= available;\n            if (hash.availableBits() === 0) {\n                this._currentBufferIndex++;\n            }\n        }\n        return result;\n    }\n    untake(bits) {\n        let pendingBits = bits;\n        while (pendingBits > 0) {\n            const hash = this._buffers[this._currentBufferIndex];\n            const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n            hash.untake(availableForUntake);\n            pendingBits -= availableForUntake;\n            this._availableBits += availableForUntake;\n            if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n                this._depth--;\n                this._currentBufferIndex--;\n            }\n        }\n    }\n    async _produceMoreBits() {\n        this._depth++;\n        const value = this._depth > 0 ? (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)([this._value, Uint8Array.from([this._depth])]) : this._value;\n        const hashValue = await this._hashFn(value);\n        const buffer = new _consumable_buffer_js__WEBPACK_IMPORTED_MODULE_1__.ConsumableBuffer(hashValue);\n        this._buffers.push(buffer);\n        this._availableBits += buffer.availableBits();\n    }\n}\n//# sourceMappingURL=consumable-hash.js.map\n\n//# sourceURL=webpack://ems/./node_modules/hamt-sharding/dist/src/consumable-hash.js?");

/***/ }),

/***/ "./node_modules/hamt-sharding/dist/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/hamt-sharding/dist/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bucket: () => (/* reexport safe */ _bucket_js__WEBPACK_IMPORTED_MODULE_1__.Bucket),\n/* harmony export */   createHAMT: () => (/* binding */ createHAMT)\n/* harmony export */ });\n/* harmony import */ var _bucket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bucket.js */ \"./node_modules/hamt-sharding/dist/src/bucket.js\");\n/* harmony import */ var _consumable_hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consumable-hash.js */ \"./node_modules/hamt-sharding/dist/src/consumable-hash.js\");\n/**\n * @packageDocumentation\n *\n * A [Hash Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) implementation for JavaScript.\n *\n * This is used by [@helia/unixfs](https://www.npmjs.com/package/@helia/unixfs) for it's HAMT-sharded directory implementation.\n *\n * @example\n *\n * ```TypeScript\n * import { createHAMT } from 'hamt-sharding'\n * import crypto from 'crypto-promise'\n *\n * // decide how to hash buffers made from keys, can return a Promise\n * const hashFn = async (buf) => {\n *   return crypto\n *     .createHash('sha256')\n *     .update(buf)\n *     .digest()\n * }\n *\n * const bucket = createHAMT({\n *   hashFn: hashFn\n * })\n *\n * await bucket.put('key', 'value')\n *\n * const output = await bucket.get('key')\n * // output === 'value'\n * ```\n */\n\n\nfunction createHAMT(options) {\n    if (options == null || options.hashFn == null) {\n        throw new Error('please define an options.hashFn');\n    }\n    const bucketOptions = {\n        bits: options.bits ?? 8,\n        hash: (0,_consumable_hash_js__WEBPACK_IMPORTED_MODULE_0__.wrapHash)(options.hashFn)\n    };\n    return new _bucket_js__WEBPACK_IMPORTED_MODULE_1__.Bucket(bucketOptions);\n}\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/hamt-sharding/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exporter: () => (/* binding */ exporter),\n/* harmony export */   recursive: () => (/* binding */ recursive),\n/* harmony export */   walkPath: () => (/* binding */ walkPath)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-last */ \"./node_modules/it-last/dist/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _resolvers_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolvers/index.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js\");\n/**\n * @packageDocumentation\n *\n * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.\n *\n * @example\n *\n * ```js\n * // import a file and export it again\n * import { importer } from 'ipfs-unixfs-importer'\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * // Should contain the blocks we are trying to export\n * const blockstore = new MemoryBlockstore()\n * const files = []\n *\n * for await (const file of importer([{\n *   path: '/foo/bar.txt',\n *   content: new Uint8Array([0, 1, 2, 3])\n * }], blockstore)) {\n *   files.push(file)\n * }\n *\n * console.info(files[0].cid) // Qmbaz\n *\n * const entry = await exporter(files[0].cid, blockstore)\n *\n * console.info(entry.cid) // Qmqux\n * console.info(entry.path) // Qmbaz/foo/bar.txt\n * console.info(entry.name) // bar.txt\n * console.info(entry.unixfs.fileSize()) // 4\n *\n * // stream content from unixfs node\n * const size = entry.unixfs.fileSize()\n * const bytes = new Uint8Array(size)\n * let offset = 0\n *\n * for await (const buf of entry.content()) {\n *   bytes.set(buf, offset)\n *   offset += chunk.length\n * }\n *\n * console.info(bytes) // 0, 1, 2, 3\n * ```\n */\n\n\n\n\nconst toPathComponents = (path = '') => {\n    // split on / unless escaped with \\\n    return (path\n        .trim()\n        .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n        .filter(Boolean);\n};\nconst cidAndRest = (path) => {\n    if (path instanceof Uint8Array) {\n        return {\n            cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.decode(path),\n            toResolve: []\n        };\n    }\n    const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.asCID(path);\n    if (cid != null) {\n        return {\n            cid,\n            toResolve: []\n        };\n    }\n    if (typeof path === 'string') {\n        if (path.indexOf('/ipfs/') === 0) {\n            path = path.substring(6);\n        }\n        const output = toPathComponents(path);\n        return {\n            cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.parse(output[0]),\n            toResolve: output.slice(1)\n        };\n    }\n    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n/**\n * Returns an async iterator that yields entries for all segments in a path\n *\n * @example\n *\n * ```javascript\n * import { walkPath } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains 4x `entry` objects\n * ```\n */\nasync function* walkPath(path, blockstore, options = {}) {\n    let { cid, toResolve } = cidAndRest(path);\n    let name = cid.toString();\n    let entryPath = name;\n    const startingDepth = toResolve.length;\n    while (true) {\n        const result = await (0,_resolvers_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n        if (result.entry == null && result.next == null) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n        }\n        if (result.entry != null) {\n            yield result.entry;\n        }\n        if (result.next == null) {\n            return;\n        }\n        // resolve further parts\n        toResolve = result.next.toResolve;\n        cid = result.next.cid;\n        name = result.next.name;\n        entryPath = result.next.path;\n    }\n}\n/**\n * Uses the given blockstore instance to fetch an IPFS node by a CID or path.\n *\n * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.\n *\n * @example\n *\n * ```typescript\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { CID } from 'multiformats/cid'\n *\n * const cid = CID.parse('QmFoo')\n *\n * const entry = await exporter(cid, blockstore, {\n *   signal: AbortSignal.timeout(50000)\n * })\n *\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Uint8Array\n *   }\n * }\n * ```\n */\nasync function exporter(path, blockstore, options = {}) {\n    const result = await (0,it_last__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(walkPath(path, blockstore, options));\n    if (result == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n    return result;\n}\n/**\n * Returns an async iterator that yields all entries beneath a given CID or IPFS\n * path, as well as the containing directory.\n *\n * @example\n *\n * ```typescript\n * import { recursive } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children\n * ```\n */\nasync function* recursive(path, blockstore, options = {}) {\n    const node = await exporter(path, blockstore, options);\n    if (node == null) {\n        return;\n    }\n    yield node;\n    if (node.type === 'directory') {\n        for await (const child of recurse(node, options)) {\n            yield child;\n        }\n    }\n    async function* recurse(node, options) {\n        for await (const file of node.content(options)) {\n            yield file;\n            if (file instanceof Uint8Array) {\n                continue;\n            }\n            if (file.type === 'directory') {\n                yield* recurse(file, options);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-cbor */ \"./node_modules/@ipld/dag-cbor/src/index.js\");\n/* harmony import */ var _utils_resolve_object_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-object-path.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js\");\n\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n    const block = await blockstore.get(cid, options);\n    const object = _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n    return (0,_utils_resolve_object_path_js__WEBPACK_IMPORTED_MODULE_1__.resolveObjectPath)(object, block, cid, name, path, toResolve, depth);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolve);\n//# sourceMappingURL=dag-cbor.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-json.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-json.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-json */ \"./node_modules/@ipld/dag-json/src/index.js\");\n/* harmony import */ var _utils_resolve_object_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-object-path.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js\");\n\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n    const block = await blockstore.get(cid, options);\n    const object = _ipld_dag_json__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n    return (0,_utils_resolve_object_path_js__WEBPACK_IMPORTED_MODULE_1__.resolveObjectPath)(object, block, cid, name, path, toResolve, depth);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolve);\n//# sourceMappingURL=dag-json.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-json.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/hashes/digest */ \"./node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/extract-data-from-block.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js\");\n/* harmony import */ var _utils_validate_offset_and_length_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/validate-offset-and-length.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js\");\n\n\n\n\n\nconst rawContent = (node) => {\n    async function* contentGenerator(options = {}) {\n        const { start, end } = (0,_utils_validate_offset_and_length_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(node.length, options.offset, options.length);\n        const buf = (0,_utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node, 0n, start, end);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_2__.CustomProgressEvent('unixfs:exporter:progress:identity', {\n            bytesRead: BigInt(buf.byteLength),\n            totalBytes: end - start,\n            fileSize: BigInt(node.byteLength)\n        }));\n        yield buf;\n    }\n    return contentGenerator;\n};\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n    if (toResolve.length > 0) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`No link named ${path} found in raw node ${cid}`), 'ERR_NOT_FOUND');\n    }\n    const buf = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_1__.decode(cid.multihash.bytes);\n    return {\n        entry: {\n            type: 'identity',\n            name,\n            path,\n            cid,\n            content: rawContent(buf.digest),\n            depth,\n            size: BigInt(buf.digest.length),\n            node: buf.digest\n        }\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolve);\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-cbor */ \"./node_modules/@ipld/dag-cbor/src/index.js\");\n/* harmony import */ var _ipld_dag_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ipld/dag-json */ \"./node_modules/@ipld/dag-json/src/index.js\");\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/codecs/json */ \"./node_modules/multiformats/dist/src/codecs/json.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/hashes/identity */ \"./node_modules/multiformats/dist/src/hashes/identity.js\");\n/* harmony import */ var _dag_cbor_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dag-cbor.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js\");\n/* harmony import */ var _dag_json_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dag-json.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-json.js\");\n/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./identity.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./json.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/json.js\");\n/* harmony import */ var _raw_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./raw.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/raw.js\");\n/* harmony import */ var _unixfs_v1_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./unixfs-v1/index.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst resolvers = {\n    [_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__.code]: _unixfs_v1_index_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n    [multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_5__.code]: _raw_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n    [_ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__.code]: _dag_cbor_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n    [_ipld_dag_json__WEBPACK_IMPORTED_MODULE_1__.code]: _dag_json_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n    [multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_6__.identity.code]: _identity_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n    [multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_4__.code]: _json_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]\n};\nconst resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n    const resolver = resolvers[cid.code];\n    if (resolver == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_3__(new Error(`No resolver for code ${cid.code}`), 'ERR_NO_RESOLVER');\n    }\n    return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolve);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/json.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/json.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/codecs/json */ \"./node_modules/multiformats/dist/src/codecs/json.js\");\n/* harmony import */ var _utils_resolve_object_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-object-path.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js\");\n\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n    const block = await blockstore.get(cid, options);\n    const object = multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n    return (0,_utils_resolve_object_path_js__WEBPACK_IMPORTED_MODULE_1__.resolveObjectPath)(object, block, cid, name, path, toResolve, depth);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolve);\n//# sourceMappingURL=json.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/json.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/raw.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/raw.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/extract-data-from-block.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js\");\n/* harmony import */ var _utils_validate_offset_and_length_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/validate-offset-and-length.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js\");\n\n\n\n\nconst rawContent = (node) => {\n    async function* contentGenerator(options = {}) {\n        const { start, end } = (0,_utils_validate_offset_and_length_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node.length, options.offset, options.length);\n        const buf = (0,_utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node, 0n, start, end);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_1__.CustomProgressEvent('unixfs:exporter:progress:raw', {\n            bytesRead: BigInt(buf.byteLength),\n            totalBytes: end - start,\n            fileSize: BigInt(node.byteLength)\n        }));\n        yield buf;\n    }\n    return contentGenerator;\n};\nconst resolve = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n    if (toResolve.length > 0) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`No link named ${path} found in raw node ${cid}`), 'ERR_NOT_FOUND');\n    }\n    const block = await blockstore.get(cid, options);\n    return {\n        entry: {\n            type: 'raw',\n            name,\n            path,\n            cid,\n            content: rawContent(block),\n            depth,\n            size: BigInt(block.length),\n            node: block\n        }\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolve);\n//# sourceMappingURL=raw.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/raw.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_parallel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-parallel */ \"./node_modules/it-parallel/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n\n\n\n\n\nconst directoryContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    async function* yieldDirectoryContent(options = {}) {\n        const offset = options.offset ?? 0;\n        const length = options.length ?? node.Links.length;\n        const links = node.Links.slice(offset, length);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_4__.CustomProgressEvent('unixfs:exporter:walk:directory', {\n            cid\n        }));\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)(links, source => (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(source, link => {\n            return async () => {\n                const linkName = link.Name ?? '';\n                const linkPath = `${path}/${linkName}`;\n                const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options);\n                return result.entry;\n            };\n        }), source => (0,it_parallel__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(source, {\n            ordered: true,\n            concurrency: options.blockReadConcurrency\n        }), source => (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, entry => entry != null));\n    }\n    return yieldDirectoryContent;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (directoryContent);\n//# sourceMappingURL=directory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_parallel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-parallel */ \"./node_modules/it-parallel/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/extract-data-from-block.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js\");\n/* harmony import */ var _utils_validate_offset_and_length_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utils/validate-offset-and-length.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nasync function walkDAG(blockstore, node, queue, streamPosition, start, end, options) {\n    // a `raw` node\n    if (node instanceof Uint8Array) {\n        const buf = (0,_utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(node, streamPosition, start, end);\n        queue.push(buf);\n        return;\n    }\n    if (node.Data == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n    }\n    let file;\n    try {\n        file = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_10__.UnixFS.unmarshal(node.Data);\n    }\n    catch (err) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(err, 'ERR_NOT_UNIXFS');\n    }\n    // might be a unixfs `raw` node or have data on intermediate nodes\n    if (file.data != null) {\n        const data = file.data;\n        const buf = (0,_utils_extract_data_from_block_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(data, streamPosition, start, end);\n        queue.push(buf);\n        streamPosition += BigInt(buf.byteLength);\n    }\n    const childOps = [];\n    if (node.Links.length !== file.blockSizes.length) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Inconsistent block sizes and dag links'), 'ERR_NOT_UNIXFS');\n    }\n    for (let i = 0; i < node.Links.length; i++) {\n        const childLink = node.Links[i];\n        const childStart = streamPosition; // inclusive\n        const childEnd = childStart + file.blockSizes[i]; // exclusive\n        if ((start >= childStart && start < childEnd) || // child has offset byte\n            (end >= childStart && end <= childEnd) || // child has end byte\n            (start < childStart && end > childEnd)) { // child is between offset and end bytes\n            childOps.push({\n                link: childLink,\n                blockStart: streamPosition\n            });\n        }\n        streamPosition = childEnd;\n        if (streamPosition > end) {\n            break;\n        }\n    }\n    await (0,it_pipe__WEBPACK_IMPORTED_MODULE_4__.pipe)(childOps, (source) => (0,it_map__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(source, (op) => {\n        return async () => {\n            const block = await blockstore.get(op.link.Hash, options);\n            return {\n                ...op,\n                block\n            };\n        };\n    }), (source) => (0,it_parallel__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n    }), async (source) => {\n        for await (const { link, block, blockStart } of source) {\n            let child;\n            switch (link.Hash.code) {\n                case _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.code:\n                    child = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode(block);\n                    break;\n                case multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_6__.code:\n                    child = block;\n                    break;\n                default:\n                    queue.end(err_code__WEBPACK_IMPORTED_MODULE_1__(new Error(`Unsupported codec: ${link.Hash.code}`), 'ERR_NOT_UNIXFS'));\n                    return;\n            }\n            // create a queue for this child - we use a queue instead of recursion\n            // to avoid overflowing the stack\n            const childQueue = new p_queue__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({\n                concurrency: 1\n            });\n            // if any of the child jobs error, end the read queue with the error\n            childQueue.on('error', error => {\n                queue.end(error);\n            });\n            // if the job rejects the 'error' event will be emitted on the child queue\n            void childQueue.add(async () => {\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_7__.CustomProgressEvent('unixfs:exporter:walk:file', {\n                    cid: link.Hash\n                }));\n                await walkDAG(blockstore, child, queue, blockStart, start, end, options);\n            });\n            // wait for this child to complete before moving on to the next\n            await childQueue.onIdle();\n        }\n    });\n    if (streamPosition >= end) {\n        queue.end();\n    }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    async function* yieldFileContent(options = {}) {\n        const fileSize = unixfs.fileSize();\n        if (fileSize === undefined) {\n            throw new Error('File was a directory');\n        }\n        const { start, end } = (0,_utils_validate_offset_and_length_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(fileSize, options.offset, options.length);\n        if (end === 0n) {\n            return;\n        }\n        let read = 0n;\n        const wanted = end - start;\n        const queue = (0,it_pushable__WEBPACK_IMPORTED_MODULE_5__.pushable)();\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_7__.CustomProgressEvent('unixfs:exporter:walk:file', {\n            cid\n        }));\n        void walkDAG(blockstore, node, queue, 0n, start, end, options)\n            .catch(err => {\n            queue.end(err);\n        });\n        for await (const buf of queue) {\n            if (buf == null) {\n                continue;\n            }\n            read += BigInt(buf.byteLength);\n            if (read > wanted) {\n                queue.end();\n                throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect'), 'ERR_OVER_READ');\n            }\n            if (read === wanted) {\n                queue.end();\n            }\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_7__.CustomProgressEvent('unixfs:exporter:progress:unixfs:file', {\n                bytesRead: read,\n                totalBytes: wanted,\n                fileSize\n            }));\n            yield buf;\n        }\n        if (read < wanted) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Traversed entire DAG but did not read enough bytes'), 'ERR_UNDER_READ');\n        }\n    }\n    return yieldFileContent;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fileContent);\n//# sourceMappingURL=file.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_parallel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-parallel */ \"./node_modules/it-parallel/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n\n\n\n\n\n\n\nconst hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    function yieldHamtDirectoryContent(options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid\n        }));\n        return listDirectory(node, path, resolve, depth, blockstore, options);\n    }\n    return yieldHamtDirectoryContent;\n};\nasync function* listDirectory(node, path, resolve, depth, blockstore, options) {\n    const links = node.Links;\n    if (node.Data == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n    }\n    let dir;\n    try {\n        dir = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__.UnixFS.unmarshal(node.Data);\n    }\n    catch (err) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(err, 'ERR_NOT_UNIXFS');\n    }\n    if (dir.fanout == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('missing fanout'), 'ERR_NOT_UNIXFS');\n    }\n    const padLength = (dir.fanout - 1n).toString(16).length;\n    const results = (0,it_pipe__WEBPACK_IMPORTED_MODULE_4__.pipe)(links, source => (0,it_map__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(source, link => {\n        return async () => {\n            const name = link.Name != null ? link.Name.substring(padLength) : null;\n            if (name != null && name !== '') {\n                const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options);\n                return { entries: result.entry == null ? [] : [result.entry] };\n            }\n            else {\n                // descend into subshard\n                const block = await blockstore.get(link.Hash, options);\n                node = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode)(block);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('unixfs:exporter:walk:hamt-sharded-directory', {\n                    cid: link.Hash\n                }));\n                return { entries: listDirectory(node, path, resolve, depth, blockstore, options) };\n            }\n        };\n    }), source => (0,it_parallel__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n    }));\n    for await (const { entries } of results) {\n        yield* entries;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hamtShardedDirectoryContent);\n//# sourceMappingURL=hamt-sharded-directory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var _utils_find_cid_in_shard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/find-cid-in-shard.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js\");\n/* harmony import */ var _content_directory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./content/directory.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js\");\n/* harmony import */ var _content_file_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./content/file.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js\");\n/* harmony import */ var _content_hamt_sharded_directory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./content/hamt-sharded-directory.js */ \"./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js\");\n\n\n\n\n\n\n\nconst findLinkCid = (node, name) => {\n    const link = node.Links.find(link => link.Name === name);\n    return link?.Hash;\n};\nconst contentExporters = {\n    raw: _content_file_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    file: _content_file_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    directory: _content_directory_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    'hamt-sharded-directory': _content_hamt_sharded_directory_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n    metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n        return () => [];\n    },\n    symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n        return () => [];\n    }\n};\n// @ts-expect-error types are wrong\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n    const block = await blockstore.get(cid, options);\n    const node = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode)(block);\n    let unixfs;\n    let next;\n    if (name == null) {\n        name = cid.toString();\n    }\n    if (node.Data == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n    }\n    try {\n        unixfs = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_6__.UnixFS.unmarshal(node.Data);\n    }\n    catch (err) {\n        // non-UnixFS dag-pb node? It could happen.\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(err, 'ERR_NOT_UNIXFS');\n    }\n    if (path == null) {\n        path = name;\n    }\n    if (toResolve.length > 0) {\n        let linkCid;\n        if (unixfs?.type === 'hamt-sharded-directory') {\n            // special case - unixfs v1 hamt shards\n            linkCid = await (0,_utils_find_cid_in_shard_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node, toResolve[0], blockstore);\n        }\n        else {\n            linkCid = findLinkCid(node, toResolve[0]);\n        }\n        if (linkCid == null) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('file does not exist'), 'ERR_NOT_FOUND');\n        }\n        // remove the path component we have resolved\n        const nextName = toResolve.shift();\n        const nextPath = `${path}/${nextName}`;\n        next = {\n            cid: linkCid,\n            toResolve,\n            name: nextName ?? '',\n            path: nextPath\n        };\n    }\n    const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore);\n    if (content == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('could not find content exporter'), 'ERR_NOT_FOUND');\n    }\n    if (unixfs.isDirectory()) {\n        return {\n            entry: {\n                type: 'directory',\n                name,\n                path,\n                cid,\n                content,\n                unixfs,\n                depth,\n                node,\n                size: unixfs.fileSize()\n            },\n            next\n        };\n    }\n    return {\n        entry: {\n            type: 'file',\n            name,\n            path,\n            cid,\n            content,\n            unixfs,\n            depth,\n            node,\n            size: unixfs.fileSize()\n        },\n        next\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unixFsResolver);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {\n    const blockLength = BigInt(block.length);\n    const blockEnd = BigInt(blockStart + blockLength);\n    if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n        // If we are looking for a byte range that is starts after the start of the block,\n        // return an empty block.  This can happen when internal nodes contain data\n        return new Uint8Array(0);\n    }\n    if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n        // If the end byte is in the current block, truncate the block to the end byte\n        block = block.subarray(0, Number(requestedEnd - blockStart));\n    }\n    if (requestedStart >= blockStart && requestedStart < blockEnd) {\n        // If the start byte is in the current block, skip to the start byte\n        block = block.subarray(Number(requestedStart - blockStart));\n    }\n    return block;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extractDataFromBlock);\n//# sourceMappingURL=extract-data-from-block.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/murmur3 */ \"./node_modules/@multiformats/murmur3/src/index.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var hamt_sharding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hamt-sharding */ \"./node_modules/hamt-sharding/dist/src/bucket.js\");\n/* harmony import */ var hamt_sharding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hamt-sharding */ \"./node_modules/hamt-sharding/dist/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n\n\n\n\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf) {\n    return (await _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_1__.murmur3128.encode(buf))\n        // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n        // implementation only uses the first 64, so we must do the same\n        // for parity..\n        .slice(0, 8)\n        // Invert buffer because that's how Go impl does it\n        .reverse();\n};\nconst addLinksToHamtBucket = async (links, bucket, rootBucket) => {\n    const padLength = (bucket.tableSize() - 1).toString(16).length;\n    await Promise.all(links.map(async (link) => {\n        if (link.Name == null) {\n            // TODO(@rvagg): what do? this is technically possible\n            throw new Error('Unexpected Link without a Name');\n        }\n        if (link.Name.length === padLength) {\n            const pos = parseInt(link.Name, 16);\n            bucket._putObjectAt(pos, new hamt_sharding__WEBPACK_IMPORTED_MODULE_3__.Bucket({\n                hash: rootBucket._options.hash,\n                bits: rootBucket._options.bits\n            }, bucket, pos));\n            return;\n        }\n        await rootBucket.put(link.Name.substring(2), true);\n    }));\n};\nconst toPrefix = (position, padLength) => {\n    return position\n        .toString(16)\n        .toUpperCase()\n        .padStart(padLength, '0')\n        .substring(0, padLength);\n};\nconst toBucketPath = (position) => {\n    let bucket = position.bucket;\n    const path = [];\n    while (bucket._parent != null) {\n        path.push(bucket);\n        bucket = bucket._parent;\n    }\n    path.push(bucket);\n    return path.reverse();\n};\nconst findShardCid = async (node, name, blockstore, context, options) => {\n    if (context == null) {\n        if (node.Data == null) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_2__(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n        }\n        let dir;\n        try {\n            dir = ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__.UnixFS.unmarshal(node.Data);\n        }\n        catch (err) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_2__(err, 'ERR_NOT_UNIXFS');\n        }\n        if (dir.type !== 'hamt-sharded-directory') {\n            throw err_code__WEBPACK_IMPORTED_MODULE_2__(new Error('not a HAMT'), 'ERR_NOT_UNIXFS');\n        }\n        if (dir.fanout == null) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_2__(new Error('missing fanout'), 'ERR_NOT_UNIXFS');\n        }\n        const rootBucket = (0,hamt_sharding__WEBPACK_IMPORTED_MODULE_5__.createHAMT)({\n            hashFn,\n            bits: Math.log2(Number(dir.fanout))\n        });\n        context = {\n            rootBucket,\n            hamtDepth: 1,\n            lastBucket: rootBucket\n        };\n    }\n    const padLength = (context.lastBucket.tableSize() - 1).toString(16).length;\n    await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n    const position = await context.rootBucket._findNewBucketAndPos(name);\n    let prefix = toPrefix(position.pos, padLength);\n    const bucketPath = toBucketPath(position);\n    if (bucketPath.length > context.hamtDepth) {\n        context.lastBucket = bucketPath[context.hamtDepth];\n        prefix = toPrefix(context.lastBucket._posAtParent, padLength);\n    }\n    const link = node.Links.find(link => {\n        if (link.Name == null) {\n            return false;\n        }\n        const entryPrefix = link.Name.substring(0, padLength);\n        const entryName = link.Name.substring(padLength);\n        if (entryPrefix !== prefix) {\n            // not the entry or subshard we're looking for\n            return false;\n        }\n        if (entryName !== '' && entryName !== name) {\n            // not the entry we're looking for\n            return false;\n        }\n        return true;\n    });\n    if (link == null) {\n        return;\n    }\n    if (link.Name != null && link.Name.substring(padLength) === name) {\n        return link.Hash;\n    }\n    context.hamtDepth++;\n    const block = await blockstore.get(link.Hash, options);\n    node = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.decode)(block);\n    return findShardCid(node, name, blockstore, context, options);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (findShardCid);\n//# sourceMappingURL=find-cid-in-shard.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveObjectPath: () => (/* binding */ resolveObjectPath)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n\n\nfunction resolveObjectPath(object, block, cid, name, path, toResolve, depth) {\n    let subObject = object;\n    let subPath = path;\n    while (toResolve.length > 0) {\n        const prop = toResolve[0];\n        if (prop in subObject) {\n            // remove the bit of the path we have resolved\n            toResolve.shift();\n            subPath = `${subPath}/${prop}`;\n            const subObjectCid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(subObject[prop]);\n            if (subObjectCid != null) {\n                return {\n                    entry: {\n                        type: 'object',\n                        name,\n                        path,\n                        cid,\n                        node: block,\n                        depth,\n                        size: BigInt(block.length),\n                        content: async function* () {\n                            yield object;\n                        }\n                    },\n                    next: {\n                        cid: subObjectCid,\n                        name: prop,\n                        path: subPath,\n                        toResolve\n                    }\n                };\n            }\n            subObject = subObject[prop];\n        }\n        else {\n            // cannot resolve further\n            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`No property named ${prop} found in node ${cid}`), 'ERR_NO_PROP');\n        }\n    }\n    return {\n        entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function* () {\n                yield object;\n            }\n        }\n    };\n}\n//# sourceMappingURL=resolve-object-path.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n\nconst validateOffsetAndLength = (size, offset = 0, length = size) => {\n    const fileSize = BigInt(size);\n    const start = BigInt(offset ?? 0);\n    let end = BigInt(length);\n    if (end !== fileSize) {\n        end = start + end;\n    }\n    if (end > fileSize) {\n        end = fileSize;\n    }\n    if (start < 0n) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Offset must be greater than or equal to 0'), 'ERR_INVALID_PARAMS');\n    }\n    if (start > fileSize) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Offset must be less than the file size'), 'ERR_INVALID_PARAMS');\n    }\n    if (end < 0n) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Length must be greater than or equal to 0'), 'ERR_INVALID_PARAMS');\n    }\n    if (end > fileSize) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Length must be less than the file size'), 'ERR_INVALID_PARAMS');\n    }\n    return {\n        start,\n        end\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateOffsetAndLength);\n//# sourceMappingURL=validate-offset-and-length.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixedSize: () => (/* binding */ fixedSize)\n/* harmony export */ });\n/* harmony import */ var uint8arraylist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arraylist */ \"./node_modules/uint8arraylist/dist/src/index.js\");\n\nconst DEFAULT_CHUNK_SIZE = 262144;\nconst fixedSize = (options = {}) => {\n    const chunkSize = options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    return async function* fixedSizeChunker(source) {\n        let list = new uint8arraylist__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayList();\n        let currentLength = 0;\n        let emitted = false;\n        for await (const buffer of source) {\n            list.append(buffer);\n            currentLength += buffer.length;\n            while (currentLength >= chunkSize) {\n                yield list.slice(0, chunkSize);\n                emitted = true;\n                // throw away consumed bytes\n                if (chunkSize === list.length) {\n                    list = new uint8arraylist__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayList();\n                    currentLength = 0;\n                }\n                else {\n                    const newBl = new uint8arraylist__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayList();\n                    newBl.append(list.sublist(chunkSize));\n                    list = newBl;\n                    // update our offset\n                    currentLength -= chunkSize;\n                }\n            }\n        }\n        if (!emitted || currentLength > 0) {\n            // return any remaining bytes\n            yield list.subarray(0, currentLength);\n        }\n    };\n};\n//# sourceMappingURL=fixed-size.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/buffer-importer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/buffer-importer.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultBufferImporter: () => (/* binding */ defaultBufferImporter)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/persist.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js\");\n\n\n\n\n\nfunction defaultBufferImporter(options) {\n    return async function* bufferImporter(file, blockstore) {\n        let bytesWritten = 0n;\n        for await (let block of file.content) {\n            yield async () => {\n                let unixfs;\n                const opts = {\n                    codec: _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__,\n                    cidVersion: options.cidVersion,\n                    onProgress: options.onProgress\n                };\n                if (options.rawLeaves) {\n                    opts.codec = multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_1__;\n                    opts.cidVersion = 1;\n                }\n                else {\n                    unixfs = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_3__.UnixFS({\n                        type: options.leafType,\n                        data: block\n                    });\n                    block = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode({\n                        Data: unixfs.marshal(),\n                        Links: []\n                    });\n                }\n                const cid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_4__.persist)(block, blockstore, opts);\n                bytesWritten += BigInt(block.byteLength);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_2__.CustomProgressEvent('unixfs:importer:progress:file:write', {\n                    bytesWritten,\n                    cid,\n                    path: file.path\n                }));\n                return {\n                    cid,\n                    unixfs,\n                    size: BigInt(block.length),\n                    block\n                };\n            };\n        }\n    };\n}\n//# sourceMappingURL=buffer-importer.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/buffer-importer.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/dir.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/dir.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dirBuilder: () => (/* binding */ dirBuilder)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/persist.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js\");\n\n\n\nconst dirBuilder = async (dir, blockstore, options) => {\n    const unixfs = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_1__.UnixFS({\n        type: 'directory',\n        mtime: dir.mtime,\n        mode: dir.mode\n    });\n    const block = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)({ Data: unixfs.marshal() }));\n    const cid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_2__.persist)(block, blockstore, options);\n    const path = dir.path;\n    return {\n        cid,\n        path,\n        unixfs,\n        size: BigInt(block.length),\n        originalPath: dir.originalPath,\n        block\n    };\n};\n//# sourceMappingURL=dir.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/dir.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/file.js":
/*!************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/file.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fileBuilder: () => (/* binding */ fileBuilder)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var it_parallel_batch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-parallel-batch */ \"./node_modules/it-parallel-batch/dist/src/index.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/persist.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js\");\n\n\n\n\n\n\nasync function* buildFileBatch(file, blockstore, options) {\n    let count = -1;\n    let previous;\n    for await (const entry of (0,it_parallel_batch__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(options.bufferImporter(file, blockstore), options.blockWriteConcurrency)) {\n        count++;\n        if (count === 0) {\n            // cache the first entry if case there aren't any more\n            previous = {\n                ...entry,\n                single: true\n            };\n            continue;\n        }\n        else if (count === 1 && (previous != null)) {\n            // we have the second block of a multiple block import so yield the first\n            yield {\n                ...previous,\n                block: undefined,\n                single: undefined\n            };\n            previous = undefined;\n        }\n        // yield the second or later block of a multiple block import\n        yield {\n            ...entry,\n            block: undefined\n        };\n    }\n    if (previous != null) {\n        yield previous;\n    }\n}\nfunction isSingleBlockImport(result) {\n    return result.single === true;\n}\nconst reduce = (file, blockstore, options) => {\n    const reducer = async function (leaves) {\n        if (leaves.length === 1 && isSingleBlockImport(leaves[0]) && options.reduceSingleLeafToSelf) {\n            const leaf = leaves[0];\n            let node = leaf.block;\n            if (isSingleBlockImport(leaf) && (file.mtime !== undefined || file.mode !== undefined)) {\n                // only one leaf node which is a raw leaf - we have metadata so convert it into a\n                // UnixFS entry otherwise we'll have nowhere to store the metadata\n                leaf.unixfs = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__.UnixFS({\n                    type: 'file',\n                    mtime: file.mtime,\n                    mode: file.mode,\n                    data: leaf.block\n                });\n                node = { Data: leaf.unixfs.marshal(), Links: [] };\n                leaf.block = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)(node));\n                leaf.cid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_5__.persist)(leaf.block, blockstore, {\n                    ...options,\n                    cidVersion: options.cidVersion\n                });\n                leaf.size = BigInt(leaf.block.length);\n            }\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_3__.CustomProgressEvent('unixfs:importer:progress:file:layout', {\n                cid: leaf.cid,\n                path: leaf.originalPath\n            }));\n            return {\n                cid: leaf.cid,\n                path: file.path,\n                unixfs: leaf.unixfs,\n                size: leaf.size,\n                originalPath: leaf.originalPath\n            };\n        }\n        // create a parent node and add all the leaves\n        const f = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_4__.UnixFS({\n            type: 'file',\n            mtime: file.mtime,\n            mode: file.mode\n        });\n        const links = leaves\n            .filter(leaf => {\n            if (leaf.cid.code === multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__.code && leaf.size > 0) {\n                return true;\n            }\n            if ((leaf.unixfs != null) && (leaf.unixfs.data == null) && leaf.unixfs.fileSize() > 0n) {\n                return true;\n            }\n            return Boolean(leaf.unixfs?.data?.length);\n        })\n            .map((leaf) => {\n            if (leaf.cid.code === multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__.code) {\n                // node is a leaf buffer\n                f.addBlockSize(leaf.size);\n                return {\n                    Name: '',\n                    Tsize: Number(leaf.size),\n                    Hash: leaf.cid\n                };\n            }\n            if ((leaf.unixfs == null) || (leaf.unixfs.data == null)) {\n                // node is an intermediate node\n                f.addBlockSize(leaf.unixfs?.fileSize() ?? 0n);\n            }\n            else {\n                // node is a unixfs 'file' leaf node\n                f.addBlockSize(BigInt(leaf.unixfs.data.length));\n            }\n            return {\n                Name: '',\n                Tsize: Number(leaf.size),\n                Hash: leaf.cid\n            };\n        });\n        const node = {\n            Data: f.marshal(),\n            Links: links\n        };\n        const block = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)(node));\n        const cid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_5__.persist)(block, blockstore, options);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_3__.CustomProgressEvent('unixfs:importer:progress:file:layout', {\n            cid,\n            path: file.originalPath\n        }));\n        return {\n            cid,\n            path: file.path,\n            unixfs: f,\n            size: BigInt(block.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),\n            originalPath: file.originalPath,\n            block\n        };\n    };\n    return reducer;\n};\nconst fileBuilder = async (file, block, options) => {\n    return options.layout(buildFileBatch(file, block, options), reduce(file, block, options));\n};\n//# sourceMappingURL=file.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/file.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDagBuilder: () => (/* binding */ defaultDagBuilder)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _dir_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dir.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/dir.js\");\n/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/file.js\");\n\n\n\n\nfunction isIterable(thing) {\n    return Symbol.iterator in thing;\n}\nfunction isAsyncIterable(thing) {\n    return Symbol.asyncIterator in thing;\n}\nfunction contentAsAsyncIterable(content) {\n    try {\n        if (content instanceof Uint8Array) {\n            return (async function* () {\n                yield content;\n            }());\n        }\n        else if (isIterable(content)) {\n            return (async function* () {\n                yield* content;\n            }());\n        }\n        else if (isAsyncIterable(content)) {\n            return content;\n        }\n    }\n    catch {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n    }\n    throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\nfunction defaultDagBuilder(options) {\n    return async function* dagBuilder(source, blockstore) {\n        for await (const entry of source) {\n            let originalPath;\n            if (entry.path != null) {\n                originalPath = entry.path;\n                entry.path = entry.path\n                    .split('/')\n                    .filter(path => path != null && path !== '.')\n                    .join('/');\n            }\n            if (isFileCandidate(entry)) {\n                const file = {\n                    path: entry.path,\n                    mtime: entry.mtime,\n                    mode: entry.mode,\n                    content: (async function* () {\n                        let bytesRead = 0n;\n                        for await (const chunk of options.chunker(options.chunkValidator(contentAsAsyncIterable(entry.content)))) {\n                            const currentChunkSize = BigInt(chunk.byteLength);\n                            bytesRead += currentChunkSize;\n                            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_1__.CustomProgressEvent('unixfs:importer:progress:file:read', {\n                                bytesRead,\n                                chunkSize: currentChunkSize,\n                                path: entry.path\n                            }));\n                            yield chunk;\n                        }\n                    })(),\n                    originalPath\n                };\n                yield async () => (0,_file_js__WEBPACK_IMPORTED_MODULE_2__.fileBuilder)(file, blockstore, options);\n            }\n            else if (entry.path != null) {\n                const dir = {\n                    path: entry.path,\n                    mtime: entry.mtime,\n                    mode: entry.mode,\n                    originalPath\n                };\n                yield async () => (0,_dir_js__WEBPACK_IMPORTED_MODULE_3__.dirBuilder)(dir, blockstore, options);\n            }\n            else {\n                throw new Error('Import candidate must have content or path or both');\n            }\n        }\n    };\n}\nfunction isFileCandidate(entry) {\n    return entry.content != null;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/validate-chunks.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/validate-chunks.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultChunkValidator: () => (/* binding */ defaultChunkValidator)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n\n\nconst defaultChunkValidator = () => {\n    return async function* validateChunks(source) {\n        for await (const content of source) {\n            if (content.length === undefined) {\n                throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n            }\n            if (typeof content === 'string' || content instanceof String) {\n                yield (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(content.toString());\n            }\n            else if (Array.isArray(content)) {\n                yield Uint8Array.from(content);\n            }\n            else if (content instanceof Uint8Array) {\n                yield content;\n            }\n            else {\n                throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n            }\n        }\n    };\n};\n//# sourceMappingURL=validate-chunks.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/validate-chunks.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DirFlat: () => (/* binding */ DirFlat)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var _dir_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dir.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dir.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/persist.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js\");\n\n\n\n\nclass DirFlat extends _dir_js__WEBPACK_IMPORTED_MODULE_1__.Dir {\n    _children;\n    constructor(props, options) {\n        super(props, options);\n        this._children = new Map();\n    }\n    async put(name, value) {\n        this.cid = undefined;\n        this.size = undefined;\n        this.nodeSize = undefined;\n        this._children.set(name, value);\n    }\n    async get(name) {\n        return Promise.resolve(this._children.get(name));\n    }\n    childCount() {\n        return this._children.size;\n    }\n    directChildrenCount() {\n        return this.childCount();\n    }\n    onlyChild() {\n        return this._children.values().next().value;\n    }\n    async *eachChildSeries() {\n        for (const [key, child] of this._children.entries()) {\n            yield {\n                key,\n                child\n            };\n        }\n    }\n    estimateNodeSize() {\n        if (this.nodeSize !== undefined) {\n            return this.nodeSize;\n        }\n        this.nodeSize = 0;\n        // estimate size only based on DAGLink name and CID byte lengths\n        // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n        for (const [name, child] of this._children.entries()) {\n            if (child.size != null && (child.cid != null)) {\n                this.nodeSize += name.length + (this.options.cidVersion === 1 ? _dir_js__WEBPACK_IMPORTED_MODULE_1__.CID_V1.bytes.byteLength : _dir_js__WEBPACK_IMPORTED_MODULE_1__.CID_V0.bytes.byteLength);\n            }\n        }\n        return this.nodeSize;\n    }\n    async *flush(block) {\n        const links = [];\n        for (const [name, child] of this._children.entries()) {\n            let result = child;\n            if (child instanceof _dir_js__WEBPACK_IMPORTED_MODULE_1__.Dir) {\n                for await (const entry of child.flush(block)) {\n                    result = entry;\n                    yield entry;\n                }\n            }\n            if (result.size != null && (result.cid != null)) {\n                links.push({\n                    Name: name,\n                    Tsize: Number(result.size),\n                    Hash: result.cid\n                });\n            }\n        }\n        const unixfs = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_2__.UnixFS({\n            type: 'directory',\n            mtime: this.mtime,\n            mode: this.mode\n        });\n        const node = { Data: unixfs.marshal(), Links: links };\n        const buffer = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)(node));\n        const cid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_3__.persist)(buffer, block, this.options);\n        const size = buffer.length + node.Links.reduce(\n        /**\n         * @param {number} acc\n         * @param {PBLink} curr\n         */\n        (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);\n        this.cid = cid;\n        this.size = size;\n        yield {\n            cid,\n            unixfs,\n            path: this.path,\n            size: BigInt(size)\n        };\n    }\n}\n//# sourceMappingURL=dir-flat.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dir-sharded.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dir-sharded.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/murmur3 */ \"./node_modules/@multiformats/murmur3/src/index.js\");\n/* harmony import */ var hamt_sharding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hamt-sharding */ \"./node_modules/hamt-sharding/dist/src/index.js\");\n/* harmony import */ var hamt_sharding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hamt-sharding */ \"./node_modules/hamt-sharding/dist/src/bucket.js\");\n/* harmony import */ var ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ipfs-unixfs */ \"./node_modules/ipfs-unixfs/dist/src/index.js\");\n/* harmony import */ var _dir_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dir.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dir.js\");\n/* harmony import */ var _utils_persist_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/persist.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js\");\n\n\n\n\n\n\nasync function hamtHashFn(buf) {\n    return (await _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_1__.murmur3128.encode(buf))\n        // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n        // implementation only uses the first 64, so we must do the same\n        // for parity..\n        .slice(0, 8)\n        // Invert buffer because that's how Go impl does it\n        .reverse();\n}\nconst HAMT_HASH_CODE = BigInt(0x22);\nconst DEFAULT_FANOUT_BITS = 8;\nclass DirSharded extends _dir_js__WEBPACK_IMPORTED_MODULE_2__.Dir {\n    _bucket;\n    constructor(props, options) {\n        super(props, options);\n        this._bucket = (0,hamt_sharding__WEBPACK_IMPORTED_MODULE_3__.createHAMT)({\n            hashFn: hamtHashFn,\n            bits: options.shardFanoutBits ?? DEFAULT_FANOUT_BITS\n        });\n    }\n    async put(name, value) {\n        this.cid = undefined;\n        this.size = undefined;\n        this.nodeSize = undefined;\n        await this._bucket.put(name, value);\n    }\n    async get(name) {\n        return this._bucket.get(name);\n    }\n    childCount() {\n        return this._bucket.leafCount();\n    }\n    directChildrenCount() {\n        return this._bucket.childrenCount();\n    }\n    onlyChild() {\n        return this._bucket.onlyChild();\n    }\n    async *eachChildSeries() {\n        for await (const { key, value } of this._bucket.eachLeafSeries()) {\n            yield {\n                key,\n                child: value\n            };\n        }\n    }\n    estimateNodeSize() {\n        if (this.nodeSize !== undefined) {\n            return this.nodeSize;\n        }\n        this.nodeSize = calculateSize(this._bucket, this, this.options);\n        return this.nodeSize;\n    }\n    async *flush(blockstore) {\n        for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n            yield {\n                ...entry,\n                path: this.path\n            };\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DirSharded);\nasync function* flush(bucket, blockstore, shardRoot, options) {\n    const children = bucket._children;\n    const padLength = (bucket.tableSize() - 1).toString(16).length;\n    const links = [];\n    let childrenSize = 0n;\n    for (let i = 0; i < children.length; i++) {\n        const child = children.get(i);\n        if (child == null) {\n            continue;\n        }\n        const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0');\n        if (child instanceof hamt_sharding__WEBPACK_IMPORTED_MODULE_4__.Bucket) {\n            let shard;\n            for await (const subShard of flush(child, blockstore, null, options)) {\n                shard = subShard;\n            }\n            if (shard == null) {\n                throw new Error('Could not flush sharded directory, no subshard found');\n            }\n            links.push({\n                Name: labelPrefix,\n                Tsize: Number(shard.size),\n                Hash: shard.cid\n            });\n            childrenSize += shard.size;\n        }\n        else if (isDir(child.value)) {\n            const dir = child.value;\n            let flushedDir;\n            for await (const entry of dir.flush(blockstore)) {\n                flushedDir = entry;\n                yield flushedDir;\n            }\n            if (flushedDir == null) {\n                throw new Error('Did not flush dir');\n            }\n            const label = labelPrefix + child.key;\n            links.push({\n                Name: label,\n                Tsize: Number(flushedDir.size),\n                Hash: flushedDir.cid\n            });\n            childrenSize += flushedDir.size;\n        }\n        else {\n            const value = child.value;\n            if (value.cid == null) {\n                continue;\n            }\n            const label = labelPrefix + child.key;\n            const size = value.size;\n            links.push({\n                Name: label,\n                Tsize: Number(size),\n                Hash: value.cid\n            });\n            childrenSize += BigInt(size ?? 0);\n        }\n    }\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(children.bitField().reverse());\n    const dir = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__.UnixFS({\n        type: 'hamt-sharded-directory',\n        data,\n        fanout: BigInt(bucket.tableSize()),\n        hashType: HAMT_HASH_CODE,\n        mtime: shardRoot?.mtime,\n        mode: shardRoot?.mode\n    });\n    const node = {\n        Data: dir.marshal(),\n        Links: links\n    };\n    const buffer = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)(node));\n    const cid = await (0,_utils_persist_js__WEBPACK_IMPORTED_MODULE_6__.persist)(buffer, blockstore, options);\n    const size = BigInt(buffer.byteLength) + childrenSize;\n    yield {\n        cid,\n        unixfs: dir,\n        size\n    };\n}\nfunction isDir(obj) {\n    return typeof obj.flush === 'function';\n}\nfunction calculateSize(bucket, shardRoot, options) {\n    const children = bucket._children;\n    const padLength = (bucket.tableSize() - 1).toString(16).length;\n    const links = [];\n    for (let i = 0; i < children.length; i++) {\n        const child = children.get(i);\n        if (child == null) {\n            continue;\n        }\n        const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0');\n        if (child instanceof hamt_sharding__WEBPACK_IMPORTED_MODULE_4__.Bucket) {\n            const size = calculateSize(child, null, options);\n            links.push({\n                Name: labelPrefix,\n                Tsize: Number(size),\n                Hash: options.cidVersion === 0 ? _dir_js__WEBPACK_IMPORTED_MODULE_2__.CID_V0 : _dir_js__WEBPACK_IMPORTED_MODULE_2__.CID_V1\n            });\n        }\n        else if (typeof child.value.flush === 'function') {\n            const dir = child.value;\n            const size = dir.nodeSize();\n            links.push({\n                Name: labelPrefix + child.key,\n                Tsize: Number(size),\n                Hash: options.cidVersion === 0 ? _dir_js__WEBPACK_IMPORTED_MODULE_2__.CID_V0 : _dir_js__WEBPACK_IMPORTED_MODULE_2__.CID_V1\n            });\n        }\n        else {\n            const value = child.value;\n            if (value.cid == null) {\n                continue;\n            }\n            const label = labelPrefix + child.key;\n            const size = value.size;\n            links.push({\n                Name: label,\n                Tsize: Number(size),\n                Hash: value.cid\n            });\n        }\n    }\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(children.bitField().reverse());\n    const dir = new ipfs_unixfs__WEBPACK_IMPORTED_MODULE_5__.UnixFS({\n        type: 'hamt-sharded-directory',\n        data,\n        fanout: BigInt(bucket.tableSize()),\n        hashType: HAMT_HASH_CODE,\n        mtime: shardRoot?.mtime,\n        mode: shardRoot?.mode\n    });\n    const buffer = (0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.encode)((0,_ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__.prepare)({\n        Data: dir.marshal(),\n        Links: links\n    }));\n    return buffer.length;\n}\n//# sourceMappingURL=dir-sharded.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dir-sharded.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/dir.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/dir.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID_V0: () => (/* binding */ CID_V0),\n/* harmony export */   CID_V1: () => (/* binding */ CID_V1),\n/* harmony export */   Dir: () => (/* binding */ Dir)\n/* harmony export */ });\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n\nclass Dir {\n    options;\n    root;\n    dir;\n    path;\n    dirty;\n    flat;\n    parent;\n    parentKey;\n    unixfs;\n    mode;\n    mtime;\n    cid;\n    size;\n    nodeSize;\n    constructor(props, options) {\n        this.options = options ?? {};\n        this.root = props.root;\n        this.dir = props.dir;\n        this.path = props.path;\n        this.dirty = props.dirty;\n        this.flat = props.flat;\n        this.parent = props.parent;\n        this.parentKey = props.parentKey;\n        this.unixfs = props.unixfs;\n        this.mode = props.mode;\n        this.mtime = props.mtime;\n    }\n}\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nconst CID_V0 = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn');\nconst CID_V1 = multiformats_cid__WEBPACK_IMPORTED_MODULE_0__.CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi');\n//# sourceMappingURL=dir.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/dir.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/flat-to-shard.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/flat-to-shard.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flatToShard: () => (/* binding */ flatToShard)\n/* harmony export */ });\n/* harmony import */ var _dir_flat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dir-flat.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js\");\n/* harmony import */ var _dir_sharded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dir-sharded.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dir-sharded.js\");\n\n\nasync function flatToShard(child, dir, threshold, options) {\n    let newDir = dir;\n    if (dir instanceof _dir_flat_js__WEBPACK_IMPORTED_MODULE_0__.DirFlat && dir.estimateNodeSize() > threshold) {\n        newDir = await convertToShard(dir, options);\n    }\n    const parent = newDir.parent;\n    if (parent != null) {\n        if (newDir !== dir) {\n            if (child != null) {\n                child.parent = newDir;\n            }\n            if (newDir.parentKey == null) {\n                throw new Error('No parent key found');\n            }\n            await parent.put(newDir.parentKey, newDir);\n        }\n        return flatToShard(newDir, parent, threshold, options);\n    }\n    return newDir;\n}\nasync function convertToShard(oldDir, options) {\n    const newDir = new _dir_sharded_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        root: oldDir.root,\n        dir: true,\n        parent: oldDir.parent,\n        parentKey: oldDir.parentKey,\n        path: oldDir.path,\n        dirty: oldDir.dirty,\n        flat: false,\n        mtime: oldDir.mtime,\n        mode: oldDir.mode\n    }, options);\n    for await (const { key, child } of oldDir.eachChildSeries()) {\n        await newDir.put(key, child);\n    }\n    return newDir;\n}\n//# sourceMappingURL=flat-to-shard.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/flat-to-shard.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   importByteStream: () => (/* binding */ importByteStream),\n/* harmony export */   importBytes: () => (/* binding */ importBytes),\n/* harmony export */   importDirectory: () => (/* binding */ importDirectory),\n/* harmony export */   importFile: () => (/* binding */ importFile),\n/* harmony export */   importer: () => (/* binding */ importer)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var it_first__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-first */ \"./node_modules/it-first/dist/src/index.js\");\n/* harmony import */ var it_parallel_batch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-parallel-batch */ \"./node_modules/it-parallel-batch/dist/src/index.js\");\n/* harmony import */ var _chunker_fixed_size_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunker/fixed-size.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js\");\n/* harmony import */ var _dag_builder_buffer_importer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dag-builder/buffer-importer.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/buffer-importer.js\");\n/* harmony import */ var _dag_builder_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dag-builder/index.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/index.js\");\n/* harmony import */ var _dag_builder_validate_chunks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dag-builder/validate-chunks.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dag-builder/validate-chunks.js\");\n/* harmony import */ var _layout_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./layout/index.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js\");\n/* harmony import */ var _tree_builder_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tree-builder.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/tree-builder.js\");\n/**\n * @packageDocumentation\n *\n * @example\n *\n * Let's create a little directory to import:\n *\n * ```console\n * > cd /tmp\n * > mkdir foo\n * > echo 'hello' > foo/bar\n * > echo 'world' > foo/quux\n * ```\n *\n * And write the importing logic:\n *\n * ```js\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n * import * as fs from 'node:fs'\n *\n * // Where the blocks will be stored\n * const blockstore = new MemoryBlockstore()\n *\n * // Import path /tmp/foo/\n * const source = [{\n *   path: '/tmp/foo/bar',\n *   content: fs.createReadStream('/tmp/foo/bar')\n * }, {\n *   path: '/tmp/foo/quxx',\n *   content: fs.createReadStream('/tmp/foo/quux')\n * }]\n *\n * for await (const entry of importer(source, blockstore)) {\n *   console.info(entry)\n * }\n * ```\n *\n * When run, metadata about DAGNodes in the created tree is printed until the root:\n *\n * ```js\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/bar',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/quxx',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * ```\n */\n\n\n\n\n\n\n\n\n\n/**\n * The importer creates UnixFS DAGs and stores the blocks that make\n * them up in the passed blockstore.\n *\n * @example\n *\n * ```typescript\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [{\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }, {\n *   path: './bar.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }]\n *\n * for await (const entry of importer(input, blockstore)) {\n *   console.info(entry)\n *   // { cid: CID(), ... }\n * }\n * ```\n */\nasync function* importer(source, blockstore, options = {}) {\n    let candidates;\n    if (Symbol.asyncIterator in source || Symbol.iterator in source) {\n        candidates = source;\n    }\n    else {\n        candidates = [source];\n    }\n    const wrapWithDirectory = options.wrapWithDirectory ?? false;\n    const shardSplitThresholdBytes = options.shardSplitThresholdBytes ?? 262144;\n    const shardFanoutBits = options.shardFanoutBits ?? 8;\n    const cidVersion = options.cidVersion ?? 1;\n    const rawLeaves = options.rawLeaves ?? true;\n    const leafType = options.leafType ?? 'file';\n    const fileImportConcurrency = options.fileImportConcurrency ?? 50;\n    const blockWriteConcurrency = options.blockWriteConcurrency ?? 10;\n    const reduceSingleLeafToSelf = options.reduceSingleLeafToSelf ?? true;\n    const chunker = options.chunker ?? (0,_chunker_fixed_size_js__WEBPACK_IMPORTED_MODULE_3__.fixedSize)();\n    const chunkValidator = options.chunkValidator ?? (0,_dag_builder_validate_chunks_js__WEBPACK_IMPORTED_MODULE_4__.defaultChunkValidator)();\n    const buildDag = options.dagBuilder ?? (0,_dag_builder_index_js__WEBPACK_IMPORTED_MODULE_5__.defaultDagBuilder)({\n        chunker,\n        chunkValidator,\n        wrapWithDirectory,\n        layout: options.layout ?? (0,_layout_index_js__WEBPACK_IMPORTED_MODULE_6__.balanced)(),\n        bufferImporter: options.bufferImporter ?? (0,_dag_builder_buffer_importer_js__WEBPACK_IMPORTED_MODULE_7__.defaultBufferImporter)({\n            cidVersion,\n            rawLeaves,\n            leafType,\n            onProgress: options.onProgress\n        }),\n        blockWriteConcurrency,\n        reduceSingleLeafToSelf,\n        cidVersion,\n        onProgress: options.onProgress\n    });\n    const buildTree = options.treeBuilder ?? (0,_tree_builder_js__WEBPACK_IMPORTED_MODULE_8__.defaultTreeBuilder)({\n        wrapWithDirectory,\n        shardSplitThresholdBytes,\n        shardFanoutBits,\n        cidVersion,\n        onProgress: options.onProgress\n    });\n    for await (const entry of buildTree((0,it_parallel_batch__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {\n        yield {\n            cid: entry.cid,\n            path: entry.path,\n            unixfs: entry.unixfs,\n            size: entry.size\n        };\n    }\n}\n/**\n * `importFile` is similar to `importer` except it accepts a single\n * `FileCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importFile } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: FileCandidate = {\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }\n *\n * const entry = await importFile(input, blockstore)\n * ```\n */\nasync function importFile(content, blockstore, options = {}) {\n    const result = await (0,it_first__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(importer([content], blockstore, options));\n    if (result == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Nothing imported'), 'ERR_INVALID_PARAMS');\n    }\n    return result;\n}\n/**\n * `importDir` is similar to `importer` except it accepts a single\n * `DirectoryCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importDirectory } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: DirectoryCandidate = {\n *   path: './foo.txt'\n * }\n *\n * const entry = await importDirectory(input, blockstore)\n * ```\n */\nasync function importDirectory(content, blockstore, options = {}) {\n    const result = await (0,it_first__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(importer([content], blockstore, options));\n    if (result == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Nothing imported'), 'ERR_INVALID_PARAMS');\n    }\n    return result;\n}\n/**\n * `importBytes` accepts a single Uint8Array and returns a promise\n * of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importBytes } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = Uint8Array.from([0, 1, 2, 3, 4])\n *\n * const entry = await importBytes(input, blockstore)\n * ```\n */\nasync function importBytes(buf, blockstore, options = {}) {\n    return importFile({\n        content: buf\n    }, blockstore, options);\n}\n/**\n * `importByteStream` accepts a single stream of Uint8Arrays and\n * returns a promise of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importByteStream } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ]\n *\n * const entry = await importByteStream(input, blockstore)\n * ```\n */\nasync function importByteStream(bufs, blockstore, options = {}) {\n    return importFile({\n        content: bufs\n    }, blockstore, options);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   balanced: () => (/* binding */ balanced)\n/* harmony export */ });\n/* harmony import */ var it_batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-batch */ \"./node_modules/it-batch/dist/src/index.js\");\n\nconst DEFAULT_MAX_CHILDREN_PER_NODE = 174;\nfunction balanced(options) {\n    const maxChildrenPerNode = options?.maxChildrenPerNode ?? DEFAULT_MAX_CHILDREN_PER_NODE;\n    return async function balancedLayout(source, reduce) {\n        const roots = [];\n        for await (const chunked of (0,it_batch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, maxChildrenPerNode)) {\n            roots.push(await reduce(chunked));\n        }\n        if (roots.length > 1) {\n            return balancedLayout(roots, reduce);\n        }\n        return roots[0];\n    };\n}\n//# sourceMappingURL=balanced.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/tree-builder.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/tree-builder.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultTreeBuilder: () => (/* binding */ defaultTreeBuilder)\n/* harmony export */ });\n/* harmony import */ var _dir_flat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dir-flat.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js\");\n/* harmony import */ var _dir_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dir.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/dir.js\");\n/* harmony import */ var _flat_to_shard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flat-to-shard.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/flat-to-shard.js\");\n/* harmony import */ var _utils_to_path_components_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/to-path-components.js */ \"./node_modules/ipfs-unixfs-importer/dist/src/utils/to-path-components.js\");\n\n\n\n\nasync function addToTree(elem, tree, options) {\n    const pathElems = (0,_utils_to_path_components_js__WEBPACK_IMPORTED_MODULE_0__.toPathComponents)(elem.path ?? '');\n    const lastIndex = pathElems.length - 1;\n    let parent = tree;\n    let currentPath = '';\n    for (let i = 0; i < pathElems.length; i++) {\n        const pathElem = pathElems[i];\n        currentPath += `${currentPath !== '' ? '/' : ''}${pathElem}`;\n        const last = (i === lastIndex);\n        parent.dirty = true;\n        parent.cid = undefined;\n        parent.size = undefined;\n        if (last) {\n            await parent.put(pathElem, elem);\n            tree = await (0,_flat_to_shard_js__WEBPACK_IMPORTED_MODULE_1__.flatToShard)(null, parent, options.shardSplitThresholdBytes, options);\n        }\n        else {\n            let dir = await parent.get(pathElem);\n            if ((dir == null) || !(dir instanceof _dir_js__WEBPACK_IMPORTED_MODULE_2__.Dir)) {\n                dir = new _dir_flat_js__WEBPACK_IMPORTED_MODULE_3__.DirFlat({\n                    root: false,\n                    dir: true,\n                    parent,\n                    parentKey: pathElem,\n                    path: currentPath,\n                    dirty: true,\n                    flat: true,\n                    mtime: dir?.unixfs?.mtime,\n                    mode: dir?.unixfs?.mode\n                }, options);\n            }\n            await parent.put(pathElem, dir);\n            parent = dir;\n        }\n    }\n    return tree;\n}\nasync function* flushAndYield(tree, blockstore) {\n    if (!(tree instanceof _dir_js__WEBPACK_IMPORTED_MODULE_2__.Dir)) {\n        if (tree.unixfs?.isDirectory() === true) {\n            yield tree;\n        }\n        return;\n    }\n    yield* tree.flush(blockstore);\n}\nfunction defaultTreeBuilder(options) {\n    return async function* treeBuilder(source, block) {\n        let tree = new _dir_flat_js__WEBPACK_IMPORTED_MODULE_3__.DirFlat({\n            root: true,\n            dir: true,\n            path: '',\n            dirty: true,\n            flat: true\n        }, options);\n        let rootDir;\n        let singleRoot = false;\n        for await (const entry of source) {\n            if (entry == null) {\n                continue;\n            }\n            // if all paths are from the same root directory, we should\n            // wrap them all in that root directory\n            const dir = `${entry.originalPath ?? ''}`.split('/')[0];\n            if (dir != null && dir !== '') {\n                if (rootDir == null) {\n                    rootDir = dir;\n                    singleRoot = true;\n                }\n                else if (rootDir !== dir) {\n                    singleRoot = false;\n                }\n            }\n            tree = await addToTree(entry, tree, options);\n            if (entry.unixfs == null || !entry.unixfs.isDirectory()) {\n                yield entry;\n            }\n        }\n        if (options.wrapWithDirectory || (singleRoot && tree.childCount() > 1)) {\n            yield* flushAndYield(tree, block);\n        }\n        else {\n            for await (const unwrapped of tree.eachChildSeries()) {\n                if (unwrapped == null) {\n                    continue;\n                }\n                yield* flushAndYield(unwrapped.child, block);\n            }\n        }\n    };\n}\n//# sourceMappingURL=tree-builder.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/tree-builder.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   persist: () => (/* binding */ persist)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n\n\n\nconst persist = async (buffer, blockstore, options) => {\n    if (options.codec == null) {\n        options.codec = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_0__;\n    }\n    const multihash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(buffer);\n    const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.create(options.cidVersion, options.codec.code, multihash);\n    await blockstore.put(cid, buffer, options);\n    return cid;\n};\n//# sourceMappingURL=persist.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs-importer/dist/src/utils/to-path-components.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ipfs-unixfs-importer/dist/src/utils/to-path-components.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toPathComponents: () => (/* binding */ toPathComponents)\n/* harmony export */ });\nconst toPathComponents = (path = '') => {\n    // split on / unless escaped with \\\n    return path.split(/(?<!\\\\)\\//).filter(Boolean);\n};\n//# sourceMappingURL=to-path-components.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs-importer/dist/src/utils/to-path-components.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ipfs-unixfs/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnixFS: () => (/* binding */ UnixFS)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var _unixfs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unixfs.js */ \"./node_modules/ipfs-unixfs/dist/src/unixfs.js\");\n/**\n * @packageDocumentation\n *\n * This module contains the protobuf definition of the UnixFS data structure found at the root of all UnixFS DAGs.\n *\n * The UnixFS spec can be found in the [ipfs/specs repository](http://github.com/ipfs/specs)\n *\n * @example Create a file composed of several blocks\n *\n * ```JavaScript\n * const data = new UnixFS({ type: 'file' })\n * data.addBlockSize(256) // add the size of each block\n * data.addBlockSize(256)\n * // ...\n * ```\n *\n * @example Create a directory that contains several files\n *\n * Creating a directory that contains several files is achieve by creating a unixfs element that identifies a MerkleDAG node as a directory. The links of that MerkleDAG node are the files that are contained in this directory.\n *\n * ```JavaScript\n * const data = new UnixFS({ type: 'directory' })\n * ```\n *\n * @example Create an unixfs Data element\n *\n * ```JavaScript\n * const data = new UnixFS([options])\n * ```\n *\n * `options` is an optional object argument that might include the following keys:\n *\n * - type (string, default `file`): The type of UnixFS entry.  Can be:\n *   - `raw`\n *   - `directory`\n *   - `file`\n *   - `metadata`\n *   - `symlink`\n *   - `hamt-sharded-directory`\n * - data (Uint8Array): The optional data field for this node\n * - blockSizes (Array, default: `[]`): If this is a `file` node that is made up of multiple blocks, `blockSizes` is a list numbers that represent the size of the file chunks stored in each child node. It is used to calculate the total file size.\n * - mode (Number, default `0644` for files, `0755` for directories/hamt-sharded-directories) file mode\n * - mtime (`Date`, `{ secs, nsecs }`, `{ Seconds, FractionalNanoseconds }`, `[ secs, nsecs ]`): The modification time of this node\n *\n * @example Add and remove a block size to the block size list\n *\n * ```JavaScript\n * data.addBlockSize(<size in bytes>)\n * ```\n *\n * ```JavaScript\n * data.removeBlockSize(<index>)\n * ```\n *\n * @example Get total fileSize\n *\n * ```JavaScript\n * data.fileSize() // => size in bytes\n * ```\n *\n * @example Marshal and unmarshal\n *\n * ```javascript\n * const marshaled = data.marshal()\n * const unmarshaled = Unixfs.unmarshal(marshaled)\n * ```\n *\n * @example Is this UnixFS entry a directory?\n *\n * ```JavaScript\n * const dir = new Data({ type: 'directory' })\n * dir.isDirectory() // true\n *\n * const file = new Data({ type: 'file' })\n * file.isDirectory() // false\n * ```\n *\n * @example Has an mtime been set?\n *\n * If no modification time has been set, no `mtime` property will be present on the `Data` instance:\n *\n * ```JavaScript\n * const file = new Data({ type: 'file' })\n * file.mtime // undefined\n *\n * Object.prototype.hasOwnProperty.call(file, 'mtime') // false\n *\n * const dir = new Data({ type: 'dir', mtime: new Date() })\n * dir.mtime // { secs: Number, nsecs: Number }\n * ```\n */\n\n\nconst types = {\n    Raw: 'raw',\n    Directory: 'directory',\n    File: 'file',\n    Metadata: 'metadata',\n    Symlink: 'symlink',\n    HAMTShard: 'hamt-sharded-directory'\n};\nconst dirTypes = [\n    'directory',\n    'hamt-sharded-directory'\n];\nconst DEFAULT_FILE_MODE = parseInt('0644', 8);\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\nclass UnixFS {\n    /**\n     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n     */\n    static unmarshal(marshaled) {\n        const message = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.decode(marshaled);\n        const data = new UnixFS({\n            type: types[message.Type != null ? message.Type.toString() : 'File'],\n            data: message.Data,\n            blockSizes: message.blocksizes,\n            mode: message.mode,\n            mtime: message.mtime != null\n                ? {\n                    secs: message.mtime.Seconds ?? 0n,\n                    nsecs: message.mtime.FractionalNanoseconds\n                }\n                : undefined,\n            fanout: message.fanout\n        });\n        // make sure we honour the original mode\n        data._originalMode = message.mode ?? 0;\n        return data;\n    }\n    type;\n    data;\n    blockSizes;\n    hashType;\n    fanout;\n    mtime;\n    _mode;\n    _originalMode;\n    constructor(options = {\n        type: 'file'\n    }) {\n        const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;\n        if (type != null && !Object.values(types).includes(type)) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n        }\n        this.type = type ?? 'file';\n        this.data = data;\n        this.hashType = hashType;\n        this.fanout = fanout;\n        this.blockSizes = blockSizes ?? [];\n        this._originalMode = 0;\n        this.mode = mode;\n        this.mtime = mtime;\n    }\n    set mode(mode) {\n        if (mode == null) {\n            this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n        }\n        else {\n            this._mode = (mode & 0xFFF);\n        }\n    }\n    get mode() {\n        return this._mode;\n    }\n    isDirectory() {\n        return dirTypes.includes(this.type);\n    }\n    addBlockSize(size) {\n        this.blockSizes.push(size);\n    }\n    removeBlockSize(index) {\n        this.blockSizes.splice(index, 1);\n    }\n    /**\n     * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n     */\n    fileSize() {\n        if (this.isDirectory()) {\n            // dirs don't have file size\n            return 0n;\n        }\n        let sum = 0n;\n        this.blockSizes.forEach((size) => {\n            sum += size;\n        });\n        if (this.data != null) {\n            sum += BigInt(this.data.length);\n        }\n        return sum;\n    }\n    /**\n     * encode to protobuf Uint8Array\n     */\n    marshal() {\n        let type;\n        switch (this.type) {\n            case 'raw':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.DataType.Raw;\n                break;\n            case 'directory':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.DataType.Directory;\n                break;\n            case 'file':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.DataType.File;\n                break;\n            case 'metadata':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.DataType.Metadata;\n                break;\n            case 'symlink':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.DataType.Symlink;\n                break;\n            case 'hamt-sharded-directory':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.DataType.HAMTShard;\n                break;\n            default:\n                throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error(`Type: ${type} is not valid`), 'ERR_INVALID_TYPE');\n        }\n        let data = this.data;\n        if (this.data == null || this.data.length === 0) {\n            data = undefined;\n        }\n        let mode;\n        if (this.mode != null) {\n            mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0);\n            if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n                mode = undefined;\n            }\n            if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n                mode = undefined;\n            }\n        }\n        let mtime;\n        if (this.mtime != null) {\n            mtime = {\n                Seconds: this.mtime.secs,\n                FractionalNanoseconds: this.mtime.nsecs\n            };\n        }\n        return _unixfs_js__WEBPACK_IMPORTED_MODULE_1__.Data.encode({\n            Type: type,\n            Data: data,\n            filesize: this.isDirectory() ? undefined : this.fileSize(),\n            blocksizes: this.blockSizes,\n            hashType: this.hashType,\n            fanout: this.fanout,\n            mode,\n            mtime\n        });\n    }\n}\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-unixfs/dist/src/unixfs.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-unixfs/dist/src/unixfs.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Data: () => (/* binding */ Data),\n/* harmony export */   Metadata: () => (/* binding */ Metadata),\n/* harmony export */   UnixTime: () => (/* binding */ UnixTime)\n/* harmony export */ });\n/* harmony import */ var protons_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protons-runtime */ \"./node_modules/protons-runtime/dist/src/index.js\");\n/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nvar Data;\n(function (Data) {\n    let DataType;\n    (function (DataType) {\n        DataType[\"Raw\"] = \"Raw\";\n        DataType[\"Directory\"] = \"Directory\";\n        DataType[\"File\"] = \"File\";\n        DataType[\"Metadata\"] = \"Metadata\";\n        DataType[\"Symlink\"] = \"Symlink\";\n        DataType[\"HAMTShard\"] = \"HAMTShard\";\n    })(DataType = Data.DataType || (Data.DataType = {}));\n    let __DataTypeValues;\n    (function (__DataTypeValues) {\n        __DataTypeValues[__DataTypeValues[\"Raw\"] = 0] = \"Raw\";\n        __DataTypeValues[__DataTypeValues[\"Directory\"] = 1] = \"Directory\";\n        __DataTypeValues[__DataTypeValues[\"File\"] = 2] = \"File\";\n        __DataTypeValues[__DataTypeValues[\"Metadata\"] = 3] = \"Metadata\";\n        __DataTypeValues[__DataTypeValues[\"Symlink\"] = 4] = \"Symlink\";\n        __DataTypeValues[__DataTypeValues[\"HAMTShard\"] = 5] = \"HAMTShard\";\n    })(__DataTypeValues || (__DataTypeValues = {}));\n    (function (DataType) {\n        DataType.codec = () => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__DataTypeValues);\n        };\n    })(DataType = Data.DataType || (Data.DataType = {}));\n    let _codec;\n    Data.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    Data.DataType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (obj.filesize != null) {\n                    w.uint32(24);\n                    w.uint64(obj.filesize);\n                }\n                if (obj.blocksizes != null) {\n                    for (const value of obj.blocksizes) {\n                        w.uint32(32);\n                        w.uint64(value);\n                    }\n                }\n                if (obj.hashType != null) {\n                    w.uint32(40);\n                    w.uint64(obj.hashType);\n                }\n                if (obj.fanout != null) {\n                    w.uint32(48);\n                    w.uint64(obj.fanout);\n                }\n                if (obj.mode != null) {\n                    w.uint32(56);\n                    w.uint32(obj.mode);\n                }\n                if (obj.mtime != null) {\n                    w.uint32(66);\n                    UnixTime.codec().encode(obj.mtime, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    blocksizes: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = Data.DataType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        case 3:\n                            obj.filesize = reader.uint64();\n                            break;\n                        case 4:\n                            obj.blocksizes.push(reader.uint64());\n                            break;\n                        case 5:\n                            obj.hashType = reader.uint64();\n                            break;\n                        case 6:\n                            obj.fanout = reader.uint64();\n                            break;\n                        case 7:\n                            obj.mode = reader.uint32();\n                            break;\n                        case 8:\n                            obj.mtime = UnixTime.codec().decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Data.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Data.codec());\n    };\n    Data.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Data.codec());\n    };\n})(Data || (Data = {}));\nvar UnixTime;\n(function (UnixTime) {\n    let _codec;\n    UnixTime.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Seconds != null) {\n                    w.uint32(8);\n                    w.int64(obj.Seconds);\n                }\n                if (obj.FractionalNanoseconds != null) {\n                    w.uint32(21);\n                    w.fixed32(obj.FractionalNanoseconds);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Seconds = reader.int64();\n                            break;\n                        case 2:\n                            obj.FractionalNanoseconds = reader.fixed32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    UnixTime.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, UnixTime.codec());\n    };\n    UnixTime.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, UnixTime.codec());\n    };\n})(UnixTime || (UnixTime = {}));\nvar Metadata;\n(function (Metadata) {\n    let _codec;\n    Metadata.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.MimeType != null) {\n                    w.uint32(10);\n                    w.string(obj.MimeType);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.MimeType = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Metadata.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Metadata.codec());\n    };\n    Metadata.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Metadata.codec());\n    };\n})(Metadata || (Metadata = {}));\n//# sourceMappingURL=unixfs.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-unixfs/dist/src/unixfs.js?");

/***/ }),

/***/ "./node_modules/it-batch/dist/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/it-batch/dist/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n * const batchSize = 2\n *\n * const result = all(batch(values, batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const batchSize = 2\n * const result = await all(batch(values(), batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction batch(source, size = 1) {\n    size = Number(size);\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            let things = [];\n            if (size < 1) {\n                size = 1;\n            }\n            if (size !== Math.round(size)) {\n                throw new Error('Batch size must be an integer');\n            }\n            for await (const thing of source) {\n                things.push(thing);\n                while (things.length >= size) {\n                    yield things.slice(0, size);\n                    things = things.slice(size);\n                }\n            }\n            while (things.length > 0) {\n                yield things.slice(0, size);\n                things = things.slice(size);\n            }\n        }());\n    }\n    return (function* () {\n        let things = [];\n        if (size < 1) {\n            size = 1;\n        }\n        if (size !== Math.round(size)) {\n            throw new Error('Batch size must be an integer');\n        }\n        for (const thing of source) {\n            things.push(thing);\n            while (things.length >= size) {\n                yield things.slice(0, size);\n                things = things.slice(size);\n            }\n        }\n        while (things.length > 0) {\n            yield things.slice(0, size);\n            things = things.slice(size);\n        }\n    }());\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (batch);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-batch/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-last/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/it-last/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * Return the last value from an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import last from 'it-last'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = last(values)\n *\n * console.info(res) // 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import last from 'it-last'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await last(values())\n *\n * console.info(res) // 4\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction last(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            let res;\n            for await (const entry of source) {\n                res = entry;\n            }\n            return res;\n        })();\n    }\n    let res;\n    for (const entry of source) {\n        res = entry;\n    }\n    return res;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (last);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-last/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-parallel-batch/dist/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/it-parallel-batch/dist/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ parallelBatch)\n/* harmony export */ });\n/* harmony import */ var it_batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-batch */ \"./node_modules/it-batch/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Takes an async iterator that emits promise-returning functions, invokes them in parallel and emits the results in the same order as the input.\n *\n * The final batch may be smaller than the batch size.\n *\n * @example\n *\n * ```javascript\n * import parallelBatch from 'it-parallel-batch'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     await delay(500)\n *\n *     return 1\n *   },\n *   async () => {\n *     await delay(200)\n *\n *     return 2\n *   },\n *   async () => {\n *     await delay(100)\n *\n *     return 3\n *   }\n * ]\n *\n * const batchSize = 2\n *\n * const result = await all(parallelBatch(input, batchSize))\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nasync function* parallelBatch(source, size = 1) {\n    for await (const tasks of (0,it_batch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, size)) {\n        const things = tasks.map(async (p) => {\n            return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }));\n        });\n        for (let i = 0; i < things.length; i++) {\n            const result = await things[i];\n            if (result.ok) {\n                yield result.value;\n            }\n            else {\n                throw result.err;\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-parallel-batch/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-parallel/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/it-parallel/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ parallel)\n/* harmony export */ });\n/* harmony import */ var p_defer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-defer */ \"./node_modules/p-defer/index.js\");\n/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nconst CustomEvent = globalThis.CustomEvent ?? Event;\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nasync function* parallel(source, options = {}) {\n    let concurrency = options.concurrency ?? Infinity;\n    if (concurrency < 1) {\n        concurrency = Infinity;\n    }\n    const ordered = options.ordered == null ? false : options.ordered;\n    const emitter = new EventTarget();\n    const ops = [];\n    let slotAvailable = (0,p_defer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    let resultAvailable = (0,p_defer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    let sourceFinished = false;\n    let sourceErr;\n    let opErred = false;\n    emitter.addEventListener('task-complete', () => {\n        resultAvailable.resolve();\n    });\n    void Promise.resolve().then(async () => {\n        try {\n            for await (const task of source) {\n                if (ops.length === concurrency) {\n                    slotAvailable = (0,p_defer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n                    await slotAvailable.promise;\n                }\n                if (opErred) {\n                    break;\n                }\n                const op = {\n                    done: false\n                };\n                ops.push(op);\n                task()\n                    .then(result => {\n                    op.done = true;\n                    op.ok = true;\n                    op.value = result;\n                    emitter.dispatchEvent(new CustomEvent('task-complete'));\n                }, err => {\n                    op.done = true;\n                    op.err = err;\n                    emitter.dispatchEvent(new CustomEvent('task-complete'));\n                });\n            }\n            sourceFinished = true;\n            emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }\n        catch (err) {\n            sourceErr = err;\n            emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }\n    });\n    function valuesAvailable() {\n        if (ordered) {\n            return ops[0]?.done;\n        }\n        return Boolean(ops.find(op => op.done));\n    }\n    function* yieldOrderedValues() {\n        while ((ops.length > 0) && ops[0].done) {\n            const op = ops[0];\n            ops.shift();\n            if (op.ok) {\n                yield op.value;\n            }\n            else {\n                // allow the source to exit\n                opErred = true;\n                slotAvailable.resolve();\n                throw op.err;\n            }\n            slotAvailable.resolve();\n        }\n    }\n    function* yieldUnOrderedValues() {\n        // more values can become available while we wait for `yield`\n        // to return control to this function\n        while (valuesAvailable()) {\n            for (let i = 0; i < ops.length; i++) {\n                if (ops[i].done) {\n                    const op = ops[i];\n                    ops.splice(i, 1);\n                    i--;\n                    if (op.ok) {\n                        yield op.value;\n                    }\n                    else {\n                        opErred = true;\n                        slotAvailable.resolve();\n                        throw op.err;\n                    }\n                    slotAvailable.resolve();\n                }\n            }\n        }\n    }\n    while (true) {\n        if (!valuesAvailable()) {\n            resultAvailable = (0,p_defer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n            await resultAvailable.promise;\n        }\n        if (sourceErr != null) {\n            // the source threw an error, propagate it\n            throw sourceErr;\n        }\n        if (ordered) {\n            yield* yieldOrderedValues();\n        }\n        else {\n            yield* yieldUnOrderedValues();\n        }\n        if (sourceFinished && ops.length === 0) {\n            // not waiting for any results and no more tasks so we are done\n            break;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-parallel/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/merge-options/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/merge-options/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/merge-options/index.js\");\n/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack://ems/./node_modules/merge-options/index.mjs?");

/***/ })

}])