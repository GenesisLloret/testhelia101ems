/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkems"] = self["webpackChunkems"] || []).push([["vendors-node_modules_helia_http_dist_src_index_js"],{

/***/ "./node_modules/@vascosantos/moving-average/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vascosantos/moving-average/index.js ***!
  \***********************************************************/
/***/ ((module, exports) => {

eval("\n\nconst exp = Math.exp\n\nexports =\nmodule.exports =\nfunction MovingAverage (timespan) {\n  if (typeof timespan !== 'number') { throw new Error('must provide a timespan to the moving average constructor') }\n\n  if (timespan <= 0) { throw new Error('must provide a timespan > 0 to the moving average constructor') }\n\n  let ma     // moving average\n  let v = 0  // variance\n  let d = 0  // deviation\n  let f = 0  // forecast\n\n  let previousTime\n\n  let ret = {}\n\n  function alpha (t, pt) {\n    return 1 - (exp(-(t - pt) / timespan))\n  }\n\n  ret.push =\n  function push (time, value) {\n    if (previousTime) {\n      // calculate moving average\n      const a = alpha(time, previousTime)\n      const diff = value - ma\n      const incr = a * diff\n      ma = a * value + (1 - a) * ma\n      // calculate variance & deviation\n      v = (1 - a) * (v + diff * incr)\n      d = Math.sqrt(v)\n      // calculate forecast\n      f = ma + a * diff\n    } else {\n      ma = value\n    }\n    previousTime = time\n  }\n\n  // Exponential Moving Average\n\n  ret.movingAverage =\n  function movingAverage () {\n    return ma\n  }\n\n  // Variance\n  ret.variance =\n  function variance () {\n    return v\n  }\n\n  ret.deviation =\n  function deviation () {\n    return d\n  }\n\n  ret.forecast =\n  function forecast () {\n    return f\n  }\n\n  return ret\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/@vascosantos/moving-average/index.js?");

/***/ }),

/***/ "./node_modules/asn1js/build/index.es.js":
/*!***********************************************!*\
  !*** ./node_modules/asn1js/build/index.es.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Any: () => (/* binding */ Any),\n/* harmony export */   BaseBlock: () => (/* binding */ BaseBlock),\n/* harmony export */   BaseStringBlock: () => (/* binding */ BaseStringBlock),\n/* harmony export */   BitString: () => (/* binding */ BitString),\n/* harmony export */   BmpString: () => (/* binding */ BmpString),\n/* harmony export */   Boolean: () => (/* binding */ Boolean),\n/* harmony export */   CharacterString: () => (/* binding */ CharacterString),\n/* harmony export */   Choice: () => (/* binding */ Choice),\n/* harmony export */   Constructed: () => (/* binding */ Constructed),\n/* harmony export */   DATE: () => (/* binding */ DATE),\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Duration: () => (/* binding */ Duration),\n/* harmony export */   EndOfContent: () => (/* binding */ EndOfContent),\n/* harmony export */   Enumerated: () => (/* binding */ Enumerated),\n/* harmony export */   GeneralString: () => (/* binding */ GeneralString),\n/* harmony export */   GeneralizedTime: () => (/* binding */ GeneralizedTime),\n/* harmony export */   GraphicString: () => (/* binding */ GraphicString),\n/* harmony export */   HexBlock: () => (/* binding */ HexBlock),\n/* harmony export */   IA5String: () => (/* binding */ IA5String),\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   Null: () => (/* binding */ Null),\n/* harmony export */   NumericString: () => (/* binding */ NumericString),\n/* harmony export */   ObjectIdentifier: () => (/* binding */ ObjectIdentifier),\n/* harmony export */   OctetString: () => (/* binding */ OctetString),\n/* harmony export */   Primitive: () => (/* binding */ Primitive),\n/* harmony export */   PrintableString: () => (/* binding */ PrintableString),\n/* harmony export */   RawData: () => (/* binding */ RawData),\n/* harmony export */   RelativeObjectIdentifier: () => (/* binding */ RelativeObjectIdentifier),\n/* harmony export */   Repeated: () => (/* binding */ Repeated),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Set: () => (/* binding */ Set),\n/* harmony export */   TIME: () => (/* binding */ TIME),\n/* harmony export */   TeletexString: () => (/* binding */ TeletexString),\n/* harmony export */   TimeOfDay: () => (/* binding */ TimeOfDay),\n/* harmony export */   UTCTime: () => (/* binding */ UTCTime),\n/* harmony export */   UniversalString: () => (/* binding */ UniversalString),\n/* harmony export */   Utf8String: () => (/* binding */ Utf8String),\n/* harmony export */   ValueBlock: () => (/* binding */ ValueBlock),\n/* harmony export */   VideotexString: () => (/* binding */ VideotexString),\n/* harmony export */   ViewWriter: () => (/* binding */ ViewWriter),\n/* harmony export */   VisibleString: () => (/* binding */ VisibleString),\n/* harmony export */   compareSchema: () => (/* binding */ compareSchema),\n/* harmony export */   fromBER: () => (/* binding */ fromBER),\n/* harmony export */   verifySchema: () => (/* binding */ verifySchema)\n/* harmony export */ });\n/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pvtsutils */ \"./node_modules/pvtsutils/build/index.js\");\n/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ \"./node_modules/pvutils/build/utils.es.js\");\n/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\n\n\n\n\nfunction assertBigInt() {\r\n    if (typeof BigInt === \"undefined\") {\r\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\r\n    }\r\n}\r\nfunction concat(buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retView = new Uint8Array(outputLength);\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retView.buffer;\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof Uint8Array)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nclass ViewWriter {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n    write(buf) {\r\n        this.items.push(buf);\r\n    }\r\n    final() {\r\n        return concat(this.items);\r\n    }\r\n}\n\nconst powers2 = [new Uint8Array([1])];\r\nconst digitsString = \"0123456789\";\r\nconst NAME = \"name\";\r\nconst VALUE_HEX_VIEW = \"valueHexView\";\r\nconst IS_HEX_ONLY = \"isHexOnly\";\r\nconst ID_BLOCK = \"idBlock\";\r\nconst TAG_CLASS = \"tagClass\";\r\nconst TAG_NUMBER = \"tagNumber\";\r\nconst IS_CONSTRUCTED = \"isConstructed\";\r\nconst FROM_BER = \"fromBER\";\r\nconst TO_BER = \"toBER\";\r\nconst LOCAL = \"local\";\r\nconst EMPTY_STRING = \"\";\r\nconst EMPTY_BUFFER = new ArrayBuffer(0);\r\nconst EMPTY_VIEW = new Uint8Array(0);\r\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\r\nconst OCTET_STRING_NAME = \"OCTET STRING\";\r\nconst BIT_STRING_NAME = \"BIT STRING\";\n\nfunction HexBlock(BaseClass) {\r\n    var _a;\r\n    return _a = class Some extends BaseClass {\r\n            constructor(...args) {\r\n                var _a;\r\n                super(...args);\r\n                const params = args[0] || {};\r\n                this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n                this.valueHexView = params.valueHex ? pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\r\n            }\r\n            get valueHex() {\r\n                return this.valueHexView.slice().buffer;\r\n            }\r\n            set valueHex(value) {\r\n                this.valueHexView = new Uint8Array(value);\r\n            }\r\n            fromBER(inputBuffer, inputOffset, inputLength) {\r\n                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n                if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n                    return -1;\r\n                }\r\n                const endLength = inputOffset + inputLength;\r\n                this.valueHexView = view.subarray(inputOffset, endLength);\r\n                if (!this.valueHexView.length) {\r\n                    this.warnings.push(\"Zero buffer length\");\r\n                    return inputOffset;\r\n                }\r\n                this.blockLength = inputLength;\r\n                return endLength;\r\n            }\r\n            toBER(sizeOnly = false) {\r\n                if (!this.isHexOnly) {\r\n                    this.error = \"Flag 'isHexOnly' is not set, abort\";\r\n                    return EMPTY_BUFFER;\r\n                }\r\n                if (sizeOnly) {\r\n                    return new ArrayBuffer(this.valueHexView.byteLength);\r\n                }\r\n                return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)\r\n                    ? this.valueHexView.buffer\r\n                    : this.valueHexView.slice().buffer;\r\n            }\r\n            toJSON() {\r\n                return {\r\n                    ...super.toJSON(),\r\n                    isHexOnly: this.isHexOnly,\r\n                    valueHex: pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueHexView),\r\n                };\r\n            }\r\n        },\r\n        _a.NAME = \"hexBlock\",\r\n        _a;\r\n}\n\nclass LocalBaseBlock {\r\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {\r\n        this.blockLength = blockLength;\r\n        this.error = error;\r\n        this.warnings = warnings;\r\n        this.valueBeforeDecodeView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(valueBeforeDecode);\r\n    }\r\n    static blockName() {\r\n        return this.NAME;\r\n    }\r\n    get valueBeforeDecode() {\r\n        return this.valueBeforeDecodeView.slice().buffer;\r\n    }\r\n    set valueBeforeDecode(value) {\r\n        this.valueBeforeDecodeView = new Uint8Array(value);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            blockName: this.constructor.NAME,\r\n            blockLength: this.blockLength,\r\n            error: this.error,\r\n            warnings: this.warnings,\r\n            valueBeforeDecode: pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueBeforeDecodeView),\r\n        };\r\n    }\r\n}\r\nLocalBaseBlock.NAME = \"baseBlock\";\n\nclass ValueBlock extends LocalBaseBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n}\r\nValueBlock.NAME = \"valueBlock\";\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ idBlock = {}, } = {}) {\r\n        var _a, _b, _c, _d;\r\n        super();\r\n        if (idBlock) {\r\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n            this.valueHexView = idBlock.valueHex ? pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\r\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\r\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\r\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\r\n        }\r\n        else {\r\n            this.tagClass = -1;\r\n            this.tagNumber = -1;\r\n            this.isConstructed = false;\r\n        }\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let firstOctet = 0;\r\n        switch (this.tagClass) {\r\n            case 1:\r\n                firstOctet |= 0x00;\r\n                break;\r\n            case 2:\r\n                firstOctet |= 0x40;\r\n                break;\r\n            case 3:\r\n                firstOctet |= 0x80;\r\n                break;\r\n            case 4:\r\n                firstOctet |= 0xC0;\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return EMPTY_BUFFER;\r\n        }\r\n        if (this.isConstructed)\r\n            firstOctet |= 0x20;\r\n        if (this.tagNumber < 31 && !this.isHexOnly) {\r\n            const retView = new Uint8Array(1);\r\n            if (!sizeOnly) {\r\n                let number = this.tagNumber;\r\n                number &= 0x1F;\r\n                firstOctet |= number;\r\n                retView[0] = firstOctet;\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        if (!this.isHexOnly) {\r\n            const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.tagNumber, 7);\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const size = encodedBuf.byteLength;\r\n            const retView = new Uint8Array(size + 1);\r\n            retView[0] = (firstOctet | 0x1F);\r\n            if (!sizeOnly) {\r\n                for (let i = 0; i < (size - 1); i++)\r\n                    retView[i + 1] = encodedView[i] | 0x80;\r\n                retView[size] = encodedView[size - 1];\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\r\n        retView[0] = (firstOctet | 0x1F);\r\n        if (!sizeOnly) {\r\n            const curView = this.valueHexView;\r\n            for (let i = 0; i < (curView.length - 1); i++)\r\n                retView[i + 1] = curView[i] | 0x80;\r\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        const tagClassMask = intBuffer[0] & 0xC0;\r\n        switch (tagClassMask) {\r\n            case 0x00:\r\n                this.tagClass = (1);\r\n                break;\r\n            case 0x40:\r\n                this.tagClass = (2);\r\n                break;\r\n            case 0x80:\r\n                this.tagClass = (3);\r\n                break;\r\n            case 0xC0:\r\n                this.tagClass = (4);\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return -1;\r\n        }\r\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\r\n        this.isHexOnly = false;\r\n        const tagNumberMask = intBuffer[0] & 0x1F;\r\n        if (tagNumberMask !== 0x1F) {\r\n            this.tagNumber = (tagNumberMask);\r\n            this.blockLength = 1;\r\n        }\r\n        else {\r\n            let count = 1;\r\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\r\n            let tagNumberBufferMaxLength = 255;\r\n            while (intBuffer[count] & 0x80) {\r\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n                count++;\r\n                if (count >= intBuffer.length) {\r\n                    this.error = \"End of input reached before message was fully decoded\";\r\n                    return -1;\r\n                }\r\n                if (count === tagNumberBufferMaxLength) {\r\n                    tagNumberBufferMaxLength += 255;\r\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\r\n                    for (let i = 0; i < intTagNumberBuffer.length; i++)\r\n                        tempBufferView[i] = intTagNumberBuffer[i];\r\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\r\n                }\r\n            }\r\n            this.blockLength = (count + 1);\r\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n            const tempBufferView = new Uint8Array(count);\r\n            for (let i = 0; i < count; i++)\r\n                tempBufferView[i] = intTagNumberBuffer[i];\r\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\r\n            intTagNumberBuffer.set(tempBufferView);\r\n            if (this.blockLength <= 9)\r\n                this.tagNumber = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(intTagNumberBuffer, 7);\r\n            else {\r\n                this.isHexOnly = true;\r\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\r\n            }\r\n        }\r\n        if (((this.tagClass === 1)) &&\r\n            (this.isConstructed)) {\r\n            switch (this.tagNumber) {\r\n                case 1:\r\n                case 2:\r\n                case 5:\r\n                case 6:\r\n                case 9:\r\n                case 13:\r\n                case 14:\r\n                case 23:\r\n                case 24:\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                case 34:\r\n                    this.error = \"Constructed encoding used for primitive type\";\r\n                    return -1;\r\n            }\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            tagClass: this.tagClass,\r\n            tagNumber: this.tagNumber,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalIdentificationBlock.NAME = \"identificationBlock\";\n\nclass LocalLengthBlock extends LocalBaseBlock {\r\n    constructor({ lenBlock = {}, } = {}) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\r\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\r\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        if (intBuffer[0] === 0xFF) {\r\n            this.error = \"Length block 0xFF is reserved by standard\";\r\n            return -1;\r\n        }\r\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\r\n        if (this.isIndefiniteForm) {\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\r\n        if (this.longFormUsed === false) {\r\n            this.length = (intBuffer[0]);\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        const count = intBuffer[0] & 0x7F;\r\n        if (count > 8) {\r\n            this.error = \"Too big integer\";\r\n            return -1;\r\n        }\r\n        if ((count + 1) > intBuffer.length) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        const lenOffset = inputOffset + 1;\r\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\r\n        if (lengthBufferView[count - 1] === 0x00)\r\n            this.warnings.push(\"Needlessly long encoded length\");\r\n        this.length = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(lengthBufferView, 8);\r\n        if (this.longFormUsed && (this.length <= 127))\r\n            this.warnings.push(\"Unnecessary usage of long length form\");\r\n        this.blockLength = count + 1;\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let retBuf;\r\n        let retView;\r\n        if (this.length > 127)\r\n            this.longFormUsed = true;\r\n        if (this.isIndefiniteForm) {\r\n            retBuf = new ArrayBuffer(1);\r\n            if (sizeOnly === false) {\r\n                retView = new Uint8Array(retBuf);\r\n                retView[0] = 0x80;\r\n            }\r\n            return retBuf;\r\n        }\r\n        if (this.longFormUsed) {\r\n            const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.length, 8);\r\n            if (encodedBuf.byteLength > 127) {\r\n                this.error = \"Too big length\";\r\n                return (EMPTY_BUFFER);\r\n            }\r\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\r\n            if (sizeOnly)\r\n                return retBuf;\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = encodedBuf.byteLength | 0x80;\r\n            for (let i = 0; i < encodedBuf.byteLength; i++)\r\n                retView[i + 1] = encodedView[i];\r\n            return retBuf;\r\n        }\r\n        retBuf = new ArrayBuffer(1);\r\n        if (sizeOnly === false) {\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = this.length;\r\n        }\r\n        return retBuf;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            longFormUsed: this.longFormUsed,\r\n            length: this.length,\r\n        };\r\n    }\r\n}\r\nLocalLengthBlock.NAME = \"lengthBlock\";\n\nconst typeStore = {};\n\nclass BaseBlock extends LocalBaseBlock {\r\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {\r\n        super(parameters);\r\n        this.name = name;\r\n        this.optional = optional;\r\n        if (primitiveSchema) {\r\n            this.primitiveSchema = primitiveSchema;\r\n        }\r\n        this.idBlock = new LocalIdentificationBlock(parameters);\r\n        this.lenBlock = new LocalLengthBlock(parameters);\r\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        if (!writer) {\r\n            prepareIndefiniteForm(this);\r\n        }\r\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\r\n        _writer.write(idBlockBuf);\r\n        if (this.lenBlock.isIndefiniteForm) {\r\n            _writer.write(new Uint8Array([0x80]).buffer);\r\n            this.valueBlock.toBER(sizeOnly, _writer);\r\n            _writer.write(new ArrayBuffer(2));\r\n        }\r\n        else {\r\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\r\n            this.lenBlock.length = valueBlockBuf.byteLength;\r\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\r\n            _writer.write(lenBlockBuf);\r\n            _writer.write(valueBlockBuf);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            idBlock: this.idBlock.toJSON(),\r\n            lenBlock: this.lenBlock.toJSON(),\r\n            valueBlock: this.valueBlock.toJSON(),\r\n            name: this.name,\r\n            optional: this.optional,\r\n        };\r\n        if (this.primitiveSchema)\r\n            object.primitiveSchema = this.primitiveSchema.toJSON();\r\n        return object;\r\n    }\r\n    toString(encoding = \"ascii\") {\r\n        if (encoding === \"ascii\") {\r\n            return this.onAsciiEncoding();\r\n        }\r\n        return pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.toBER());\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\r\n    }\r\n    isEqual(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof this.constructor)) {\r\n            return false;\r\n        }\r\n        const thisRaw = this.toBER();\r\n        const otherRaw = other.toBER();\r\n        return pvutils__WEBPACK_IMPORTED_MODULE_1__.isEqualBuffer(thisRaw, otherRaw);\r\n    }\r\n}\r\nBaseBlock.NAME = \"BaseBlock\";\r\nfunction prepareIndefiniteForm(baseBlock) {\r\n    if (baseBlock instanceof typeStore.Constructed) {\r\n        for (const value of baseBlock.valueBlock.value) {\r\n            if (prepareIndefiniteForm(value)) {\r\n                baseBlock.lenBlock.isIndefiniteForm = true;\r\n            }\r\n        }\r\n    }\r\n    return !!baseBlock.lenBlock.isIndefiniteForm;\r\n}\n\nclass BaseStringBlock extends BaseBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {\r\n        super(parameters, stringValueBlockType);\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        this.fromBuffer(this.valueBlock.valueHexView);\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\r\n    }\r\n}\r\nBaseStringBlock.NAME = \"BaseStringBlock\";\n\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ isHexOnly = true, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = isHexOnly;\r\n    }\r\n}\r\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\n\nvar _a$w;\r\nclass Primitive extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalPrimitiveValueBlock);\r\n        this.idBlock.isConstructed = false;\r\n    }\r\n}\r\n_a$w = Primitive;\r\n(() => {\r\n    typeStore.Primitive = _a$w;\r\n})();\r\nPrimitive.NAME = \"PRIMITIVE\";\n\nfunction localChangeType(inputObject, newType) {\r\n    if (inputObject instanceof newType) {\r\n        return inputObject;\r\n    }\r\n    const newObject = new newType();\r\n    newObject.idBlock = inputObject.idBlock;\r\n    newObject.lenBlock = inputObject.lenBlock;\r\n    newObject.warnings = inputObject.warnings;\r\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\r\n    return newObject;\r\n}\r\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\r\n    const incomingOffset = inputOffset;\r\n    let returnObject = new BaseBlock({}, ValueBlock);\r\n    const baseBlock = new LocalBaseBlock();\r\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\r\n        returnObject.error = baseBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\r\n    if (!intBuffer.length) {\r\n        returnObject.error = \"Zero buffer length\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.idBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.idBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.idBlock.blockLength;\r\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.lenBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.lenBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.lenBlock.blockLength;\r\n    if (!returnObject.idBlock.isConstructed &&\r\n        returnObject.lenBlock.isIndefiniteForm) {\r\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let newASN1Type = BaseBlock;\r\n    switch (returnObject.idBlock.tagClass) {\r\n        case 1:\r\n            if ((returnObject.idBlock.tagNumber >= 37) &&\r\n                (returnObject.idBlock.isHexOnly === false)) {\r\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\r\n                return {\r\n                    offset: -1,\r\n                    result: returnObject\r\n                };\r\n            }\r\n            switch (returnObject.idBlock.tagNumber) {\r\n                case 0:\r\n                    if ((returnObject.idBlock.isConstructed) &&\r\n                        (returnObject.lenBlock.length > 0)) {\r\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\r\n                        return {\r\n                            offset: -1,\r\n                            result: returnObject\r\n                        };\r\n                    }\r\n                    newASN1Type = typeStore.EndOfContent;\r\n                    break;\r\n                case 1:\r\n                    newASN1Type = typeStore.Boolean;\r\n                    break;\r\n                case 2:\r\n                    newASN1Type = typeStore.Integer;\r\n                    break;\r\n                case 3:\r\n                    newASN1Type = typeStore.BitString;\r\n                    break;\r\n                case 4:\r\n                    newASN1Type = typeStore.OctetString;\r\n                    break;\r\n                case 5:\r\n                    newASN1Type = typeStore.Null;\r\n                    break;\r\n                case 6:\r\n                    newASN1Type = typeStore.ObjectIdentifier;\r\n                    break;\r\n                case 10:\r\n                    newASN1Type = typeStore.Enumerated;\r\n                    break;\r\n                case 12:\r\n                    newASN1Type = typeStore.Utf8String;\r\n                    break;\r\n                case 13:\r\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\r\n                    break;\r\n                case 14:\r\n                    newASN1Type = typeStore.TIME;\r\n                    break;\r\n                case 15:\r\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\r\n                    return {\r\n                        offset: -1,\r\n                        result: returnObject\r\n                    };\r\n                case 16:\r\n                    newASN1Type = typeStore.Sequence;\r\n                    break;\r\n                case 17:\r\n                    newASN1Type = typeStore.Set;\r\n                    break;\r\n                case 18:\r\n                    newASN1Type = typeStore.NumericString;\r\n                    break;\r\n                case 19:\r\n                    newASN1Type = typeStore.PrintableString;\r\n                    break;\r\n                case 20:\r\n                    newASN1Type = typeStore.TeletexString;\r\n                    break;\r\n                case 21:\r\n                    newASN1Type = typeStore.VideotexString;\r\n                    break;\r\n                case 22:\r\n                    newASN1Type = typeStore.IA5String;\r\n                    break;\r\n                case 23:\r\n                    newASN1Type = typeStore.UTCTime;\r\n                    break;\r\n                case 24:\r\n                    newASN1Type = typeStore.GeneralizedTime;\r\n                    break;\r\n                case 25:\r\n                    newASN1Type = typeStore.GraphicString;\r\n                    break;\r\n                case 26:\r\n                    newASN1Type = typeStore.VisibleString;\r\n                    break;\r\n                case 27:\r\n                    newASN1Type = typeStore.GeneralString;\r\n                    break;\r\n                case 28:\r\n                    newASN1Type = typeStore.UniversalString;\r\n                    break;\r\n                case 29:\r\n                    newASN1Type = typeStore.CharacterString;\r\n                    break;\r\n                case 30:\r\n                    newASN1Type = typeStore.BmpString;\r\n                    break;\r\n                case 31:\r\n                    newASN1Type = typeStore.DATE;\r\n                    break;\r\n                case 32:\r\n                    newASN1Type = typeStore.TimeOfDay;\r\n                    break;\r\n                case 33:\r\n                    newASN1Type = typeStore.DateTime;\r\n                    break;\r\n                case 34:\r\n                    newASN1Type = typeStore.Duration;\r\n                    break;\r\n                default: {\r\n                    const newObject = returnObject.idBlock.isConstructed\r\n                        ? new typeStore.Constructed()\r\n                        : new typeStore.Primitive();\r\n                    newObject.idBlock = returnObject.idBlock;\r\n                    newObject.lenBlock = returnObject.lenBlock;\r\n                    newObject.warnings = returnObject.warnings;\r\n                    returnObject = newObject;\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        default: {\r\n            newASN1Type = returnObject.idBlock.isConstructed\r\n                ? typeStore.Constructed\r\n                : typeStore.Primitive;\r\n        }\r\n    }\r\n    returnObject = localChangeType(returnObject, newASN1Type);\r\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\r\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\r\n    return {\r\n        offset: resultOffset,\r\n        result: returnObject\r\n    };\r\n}\r\nfunction fromBER(inputBuffer) {\r\n    if (!inputBuffer.byteLength) {\r\n        const result = new BaseBlock({}, ValueBlock);\r\n        result.error = \"Input buffer has zero length\";\r\n        return {\r\n            offset: -1,\r\n            result\r\n        };\r\n    }\r\n    return localFromBER(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\r\n}\n\nfunction checkLen(indefiniteLength, length) {\r\n    if (indefiniteLength) {\r\n        return 1;\r\n    }\r\n    return length;\r\n}\r\nclass LocalConstructedValueBlock extends ValueBlock {\r\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.isIndefiniteForm = isIndefiniteForm;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (this.valueBeforeDecodeView.length === 0) {\r\n            this.warnings.push(\"Zero buffer length\");\r\n            return inputOffset;\r\n        }\r\n        let currentOffset = inputOffset;\r\n        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\r\n            const returnObject = localFromBER(view, currentOffset, inputLength);\r\n            if (returnObject.offset === -1) {\r\n                this.error = returnObject.result.error;\r\n                this.warnings.concat(returnObject.result.warnings);\r\n                return -1;\r\n            }\r\n            currentOffset = returnObject.offset;\r\n            this.blockLength += returnObject.result.blockLength;\r\n            inputLength -= returnObject.result.blockLength;\r\n            this.value.push(returnObject.result);\r\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\r\n                break;\r\n            }\r\n        }\r\n        if (this.isIndefiniteForm) {\r\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\r\n                this.value.pop();\r\n            }\r\n            else {\r\n                this.warnings.push(\"No EndOfContent block encoded\");\r\n            }\r\n        }\r\n        return currentOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            this.value[i].toBER(sizeOnly, _writer);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            value: [],\r\n        };\r\n        for (const value of this.value) {\r\n            object.value.push(value.toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\n\nvar _a$v;\r\nclass Constructed extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalConstructedValueBlock);\r\n        this.idBlock.isConstructed = true;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        const values = [];\r\n        for (const value of this.valueBlock.value) {\r\n            values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\r\n        }\r\n        const blockName = this.idBlock.tagClass === 3\r\n            ? `[${this.idBlock.tagNumber}]`\r\n            : this.constructor.NAME;\r\n        return values.length\r\n            ? `${blockName} :\\n${values.join(\"\\n\")}`\r\n            : `${blockName} :`;\r\n    }\r\n}\r\n_a$v = Constructed;\r\n(() => {\r\n    typeStore.Constructed = _a$v;\r\n})();\r\nConstructed.NAME = \"CONSTRUCTED\";\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        return inputOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return EMPTY_BUFFER;\r\n    }\r\n}\r\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\n\nvar _a$u;\r\nclass EndOfContent extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalEndOfContentValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 0;\r\n    }\r\n}\r\n_a$u = EndOfContent;\r\n(() => {\r\n    typeStore.EndOfContent = _a$u;\r\n})();\r\nEndOfContent.NAME = END_OF_CONTENT_NAME;\n\nvar _a$t;\r\nclass Null extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, ValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 5;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (this.lenBlock.length > 0)\r\n            this.warnings.push(\"Non-zero length of value block for Null type\");\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        this.blockLength += inputLength;\r\n        if ((inputOffset + inputLength) > inputBuffer.byteLength) {\r\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n            return -1;\r\n        }\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuf = new ArrayBuffer(2);\r\n        if (!sizeOnly) {\r\n            const retView = new Uint8Array(retBuf);\r\n            retView[0] = 0x05;\r\n            retView[1] = 0x00;\r\n        }\r\n        if (writer) {\r\n            writer.write(retBuf);\r\n        }\r\n        return retBuf;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME}`;\r\n    }\r\n}\r\n_a$t = Null;\r\n(() => {\r\n    typeStore.Null = _a$t;\r\n})();\r\nNull.NAME = \"NULL\";\n\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        if (parameters.valueHex) {\r\n            this.valueHexView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(parameters.valueHex);\r\n        }\r\n        else {\r\n            this.valueHexView = new Uint8Array(1);\r\n        }\r\n        if (value) {\r\n            this.value = value;\r\n        }\r\n    }\r\n    get value() {\r\n        for (const octet of this.valueHexView) {\r\n            if (octet > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    set value(value) {\r\n        this.valueHexView[0] = value ? 0xFF : 0x00;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (inputLength > 1)\r\n            this.warnings.push(\"Boolean value encoded in more then 1 octet\");\r\n        this.isHexOnly = true;\r\n        pvutils__WEBPACK_IMPORTED_MODULE_1__.utilDecodeTC.call(this);\r\n        this.blockLength = inputLength;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER() {\r\n        return this.valueHexView.slice();\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\n\nvar _a$s;\r\nclass Boolean extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalBooleanValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 1;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.getValue}`;\r\n    }\r\n}\r\n_a$s = Boolean;\r\n(() => {\r\n    typeStore.Boolean = _a$s;\r\n})();\r\nBoolean.NAME = \"BOOLEAN\";\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isConstructed = isConstructed;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = 0;\r\n        if (this.isConstructed) {\r\n            this.isHexOnly = false;\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (let i = 0; i < this.value.length; i++) {\r\n                const currentBlockName = this.value[i].constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== OCTET_STRING_NAME) {\r\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\r\n                    return -1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.isHexOnly = true;\r\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n            this.blockLength = inputLength;\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed)\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.byteLength)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\n\nvar _a$r;\r\nclass OctetString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalOctetStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 4;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        if (inputLength === 0) {\r\n            if (this.idBlock.error.length === 0)\r\n                this.blockLength += this.idBlock.blockLength;\r\n            if (this.lenBlock.error.length === 0)\r\n                this.blockLength += this.lenBlock.blockLength;\r\n            return inputOffset;\r\n        }\r\n        if (!this.valueBlock.isConstructed) {\r\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\r\n                        this.valueBlock.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        return `${this.constructor.NAME} : ${pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueBlock.valueHexView)}`;\r\n    }\r\n    getValue() {\r\n        if (!this.idBlock.isConstructed) {\r\n            return this.valueBlock.valueHexView.slice().buffer;\r\n        }\r\n        const array = [];\r\n        for (const content of this.valueBlock.value) {\r\n            if (content instanceof OctetString) {\r\n                array.push(content.valueBlock.valueHexView);\r\n            }\r\n        }\r\n        return pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.concat(array);\r\n    }\r\n}\r\n_a$r = OctetString;\r\n(() => {\r\n    typeStore.OctetString = _a$r;\r\n})();\r\nOctetString.NAME = OCTET_STRING_NAME;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.unusedBits = unusedBits;\r\n        this.isConstructed = isConstructed;\r\n        this.blockLength = this.valueHexView.byteLength;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        let resultOffset = -1;\r\n        if (this.isConstructed) {\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (const value of this.value) {\r\n                const currentBlockName = value.constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== BIT_STRING_NAME) {\r\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\r\n                    return -1;\r\n                }\r\n                const valueBlock = value.valueBlock;\r\n                if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {\r\n                    this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\r\n                    return -1;\r\n                }\r\n                this.unusedBits = valueBlock.unusedBits;\r\n            }\r\n            return resultOffset;\r\n        }\r\n        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.unusedBits = intBuffer[0];\r\n        if (this.unusedBits > 7) {\r\n            this.error = \"Unused bits for BitString must be in range 0-7\";\r\n            return -1;\r\n        }\r\n        if (!this.unusedBits) {\r\n            const buf = intBuffer.subarray(1);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\r\n                        this.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        this.valueHexView = intBuffer.subarray(1);\r\n        this.blockLength = intBuffer.length;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed) {\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        }\r\n        if (sizeOnly) {\r\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\r\n        }\r\n        if (!this.valueHexView.byteLength) {\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.length + 1);\r\n        retView[0] = this.unusedBits;\r\n        retView.set(this.valueHexView, 1);\r\n        return retView.buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            unusedBits: this.unusedBits,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\n\nvar _a$q;\r\nclass BitString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalBitStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 3;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        else {\r\n            const bits = [];\r\n            const valueHex = this.valueBlock.valueHexView;\r\n            for (const byte of valueHex) {\r\n                bits.push(byte.toString(2).padStart(8, \"0\"));\r\n            }\r\n            const bitsStr = bits.join(\"\");\r\n            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\r\n        }\r\n    }\r\n}\r\n_a$q = BitString;\r\n(() => {\r\n    typeStore.BitString = _a$q;\r\n})();\r\nBitString.NAME = BIT_STRING_NAME;\n\nvar _a$p;\r\nfunction viewAdd(first, second) {\r\n    const c = new Uint8Array([0]);\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    let firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value = 0;\r\n    const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\r\n    let counter = 0;\r\n    for (let i = max; i >= 0; i--, counter++) {\r\n        switch (true) {\r\n            case (counter < secondViewCopy.length):\r\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\r\n                break;\r\n            default:\r\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\r\n        }\r\n        c[0] = value / 10;\r\n        switch (true) {\r\n            case (counter >= firstViewCopy.length):\r\n                firstViewCopy = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\r\n                break;\r\n            default:\r\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\r\n        }\r\n    }\r\n    if (c[0] > 0)\r\n        firstViewCopy = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilConcatView(c, firstViewCopy);\r\n    return firstViewCopy;\r\n}\r\nfunction power2(n) {\r\n    if (n >= powers2.length) {\r\n        for (let p = powers2.length; p <= n; p++) {\r\n            const c = new Uint8Array([0]);\r\n            let digits = (powers2[p - 1]).slice(0);\r\n            for (let i = (digits.length - 1); i >= 0; i--) {\r\n                const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\r\n                c[0] = newValue[0] / 10;\r\n                digits[i] = newValue[0] % 10;\r\n            }\r\n            if (c[0] > 0)\r\n                digits = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilConcatView(c, digits);\r\n            powers2.push(digits);\r\n        }\r\n    }\r\n    return powers2[n];\r\n}\r\nfunction viewSub(first, second) {\r\n    let b = 0;\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    const firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value;\r\n    let counter = 0;\r\n    for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\r\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\r\n        switch (true) {\r\n            case (value < 0):\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n                break;\r\n            default:\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n        }\r\n    }\r\n    if (b > 0) {\r\n        for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {\r\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\r\n            if (value < 0) {\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n            }\r\n            else {\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return firstViewCopy.slice();\r\n}\r\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        this._valueDec = 0;\r\n        if (parameters.valueHex) {\r\n            this.setValueHex();\r\n        }\r\n        if (value !== undefined) {\r\n            this.valueDec = value;\r\n        }\r\n    }\r\n    setValueHex() {\r\n        if (this.valueHexView.length >= 4) {\r\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\r\n            this.isHexOnly = true;\r\n            this._valueDec = 0;\r\n        }\r\n        else {\r\n            this.isHexOnly = false;\r\n            if (this.valueHexView.length > 0) {\r\n                this._valueDec = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilDecodeTC.call(this);\r\n            }\r\n        }\r\n    }\r\n    set valueDec(v) {\r\n        this._valueDec = v;\r\n        this.isHexOnly = false;\r\n        this.valueHexView = new Uint8Array(pvutils__WEBPACK_IMPORTED_MODULE_1__.utilEncodeTC(v));\r\n    }\r\n    get valueDec() {\r\n        return this._valueDec;\r\n    }\r\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\r\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (offset === -1)\r\n            return offset;\r\n        const view = this.valueHexView;\r\n        if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {\r\n            this.valueHexView = view.subarray(1);\r\n        }\r\n        else {\r\n            if (expectedLength !== 0) {\r\n                if (view.length < expectedLength) {\r\n                    if ((expectedLength - view.length) > 1)\r\n                        expectedLength = view.length + 1;\r\n                    this.valueHexView = view.subarray(expectedLength - view.length);\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n    toDER(sizeOnly = false) {\r\n        const view = this.valueHexView;\r\n        switch (true) {\r\n            case ((view[0] & 0x80) !== 0):\r\n                {\r\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\r\n                    updatedView[0] = 0x00;\r\n                    updatedView.set(view, 1);\r\n                    this.valueHexView = updatedView;\r\n                }\r\n                break;\r\n            case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\r\n                {\r\n                    this.valueHexView = this.valueHexView.subarray(1);\r\n                }\r\n                break;\r\n        }\r\n        return this.toBER(sizeOnly);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (resultOffset === -1) {\r\n            return resultOffset;\r\n        }\r\n        this.setValueHex();\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.length)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n    toString() {\r\n        const firstBit = (this.valueHexView.length * 8) - 1;\r\n        let digits = new Uint8Array((this.valueHexView.length * 8) / 3);\r\n        let bitNumber = 0;\r\n        let currentByte;\r\n        const asn1View = this.valueHexView;\r\n        let result = \"\";\r\n        let flag = false;\r\n        for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {\r\n            currentByte = asn1View[byteNumber];\r\n            for (let i = 0; i < 8; i++) {\r\n                if ((currentByte & 1) === 1) {\r\n                    switch (bitNumber) {\r\n                        case firstBit:\r\n                            digits = viewSub(power2(bitNumber), digits);\r\n                            result = \"-\";\r\n                            break;\r\n                        default:\r\n                            digits = viewAdd(digits, power2(bitNumber));\r\n                    }\r\n                }\r\n                bitNumber++;\r\n                currentByte >>= 1;\r\n            }\r\n        }\r\n        for (let i = 0; i < digits.length; i++) {\r\n            if (digits[i])\r\n                flag = true;\r\n            if (flag)\r\n                result += digitsString.charAt(digits[i]);\r\n        }\r\n        if (flag === false)\r\n            result += digitsString.charAt(0);\r\n        return result;\r\n    }\r\n}\r\n_a$p = LocalIntegerValueBlock;\r\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\r\n(() => {\r\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\r\n        set: function (v) {\r\n            this.valueHexView = new Uint8Array(v);\r\n            this.setValueHex();\r\n        },\r\n        get: function () {\r\n            return this.valueHexView.slice().buffer;\r\n        },\r\n    });\r\n})();\n\nvar _a$o;\r\nclass Integer extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalIntegerValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 2;\r\n    }\r\n    toBigInt() {\r\n        assertBigInt();\r\n        return BigInt(this.valueBlock.toString());\r\n    }\r\n    static fromBigInt(value) {\r\n        assertBigInt();\r\n        const bigIntValue = BigInt(value);\r\n        const writer = new ViewWriter();\r\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\r\n        const view = new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromHex(hex));\r\n        if (bigIntValue < 0) {\r\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\r\n            first[0] |= 0x80;\r\n            const firstInt = BigInt(`0x${pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(first)}`);\r\n            const secondInt = firstInt + bigIntValue;\r\n            const second = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromHex(secondInt.toString(16)));\r\n            second[0] |= 0x80;\r\n            writer.write(second);\r\n        }\r\n        else {\r\n            if (view[0] & 0x80) {\r\n                writer.write(new Uint8Array([0]));\r\n            }\r\n            writer.write(view);\r\n        }\r\n        const res = new Integer({\r\n            valueHex: writer.final(),\r\n        });\r\n        return res;\r\n    }\r\n    convertToDER() {\r\n        const integer = new Integer({ valueHex: this.valueBlock.valueHexView });\r\n        integer.valueBlock.toDER();\r\n        return integer;\r\n    }\r\n    convertFromDER() {\r\n        return new Integer({\r\n            valueHex: this.valueBlock.valueHexView[0] === 0\r\n                ? this.valueBlock.valueHexView.subarray(1)\r\n                : this.valueBlock.valueHexView,\r\n        });\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\r\n    }\r\n}\r\n_a$o = Integer;\r\n(() => {\r\n    typeStore.Integer = _a$o;\r\n})();\r\nInteger.NAME = \"INTEGER\";\n\nvar _a$n;\r\nclass Enumerated extends Integer {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 10;\r\n    }\r\n}\r\n_a$n = Enumerated;\r\n(() => {\r\n    typeStore.Enumerated = _a$n;\r\n})();\r\nEnumerated.NAME = \"ENUMERATED\";\n\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n        this.isFirstSid = isFirstSid;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++) {\r\n            tempView[i] = this.valueHexView[i];\r\n        }\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    set valueBigInt(value) {\r\n        assertBigInt();\r\n        let bits = BigInt(value).toString(2);\r\n        while (bits.length % 7) {\r\n            bits = \"0\" + bits;\r\n        }\r\n        const bytes = new Uint8Array(bits.length / 7);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\r\n        }\r\n        this.fromBER(bytes.buffer, 0, bytes.length);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            if (this.isFirstSid) {\r\n                let sidValue = this.valueDec;\r\n                if (this.valueDec <= 39)\r\n                    result = \"0.\";\r\n                else {\r\n                    if (this.valueDec <= 79) {\r\n                        result = \"1.\";\r\n                        sidValue -= 40;\r\n                    }\r\n                    else {\r\n                        result = \"2.\";\r\n                        sidValue -= 80;\r\n                    }\r\n                }\r\n                result += sidValue.toString();\r\n            }\r\n            else\r\n                result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n            isFirstSid: this.isFirstSid,\r\n        };\r\n    }\r\n}\r\nLocalSidValueBlock.NAME = \"sidBlock\";\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            if (this.value.length === 0)\r\n                sidBlock.isFirstSid = true;\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        let flag = false;\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            if (flag) {\r\n                const sidBlock = this.value[0];\r\n                let plus = 0;\r\n                switch (sidBlock.valueDec) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        plus = 40;\r\n                        break;\r\n                    case 2:\r\n                        plus = 80;\r\n                        break;\r\n                    default:\r\n                        this.value = [];\r\n                        return;\r\n                }\r\n                const parsedSID = parseInt(sid, 10);\r\n                if (isNaN(parsedSID))\r\n                    return;\r\n                sidBlock.valueDec = parsedSID + plus;\r\n                flag = false;\r\n            }\r\n            else {\r\n                const sidBlock = new LocalSidValueBlock();\r\n                if (sid > Number.MAX_SAFE_INTEGER) {\r\n                    assertBigInt();\r\n                    const sidValue = BigInt(sid);\r\n                    sidBlock.valueBigInt = sidValue;\r\n                }\r\n                else {\r\n                    sidBlock.valueDec = parseInt(sid, 10);\r\n                    if (isNaN(sidBlock.valueDec))\r\n                        return;\r\n                }\r\n                if (!this.value.length) {\r\n                    sidBlock.isFirstSid = true;\r\n                    flag = true;\r\n                }\r\n                this.value.push(sidBlock);\r\n            }\r\n        } while (pos2 !== -1);\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                if (this.value[i].isFirstSid)\r\n                    result = `2.{${sidStr} - 80}`;\r\n                else\r\n                    result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\n\nvar _a$m;\r\nclass ObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 6;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$m = ObjectIdentifier;\r\n(() => {\r\n    typeStore.ObjectIdentifier = _a$m;\r\n})();\r\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ valueDec = 0, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (inputLength === 0)\r\n            return inputOffset;\r\n        const inputView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength))\r\n            return -1;\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++)\r\n            tempView[i] = this.valueHexView[i];\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n}\r\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            sidBlock.valueDec = parseInt(sid, 10);\r\n            if (isNaN(sidBlock.valueDec))\r\n                return true;\r\n            this.value.push(sidBlock);\r\n        } while (pos2 !== -1);\r\n        return true;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++)\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        return object;\r\n    }\r\n}\r\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\n\nvar _a$l;\r\nclass RelativeObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 13;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$l = RelativeObjectIdentifier;\r\n(() => {\r\n    typeStore.RelativeObjectIdentifier = _a$l;\r\n})();\r\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\n\nvar _a$k;\r\nclass Sequence extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 16;\r\n    }\r\n}\r\n_a$k = Sequence;\r\n(() => {\r\n    typeStore.Sequence = _a$k;\r\n})();\r\nSequence.NAME = \"SEQUENCE\";\n\nvar _a$j;\r\nclass Set extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 17;\r\n    }\r\n}\r\n_a$j = Set;\r\n(() => {\r\n    typeStore.Set = _a$j;\r\n})();\r\nSet.NAME = \"SET\";\n\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = true;\r\n        this.value = EMPTY_STRING;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalStringValueBlock.NAME = \"StringValueBlock\";\n\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\r\n}\r\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\n\nclass LocalSimpleStringBlock extends BaseStringBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters, LocalSimpleStringValueBlock);\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLen = inputString.length;\r\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\r\n        for (let i = 0; i < strLen; i++)\r\n            view[i] = inputString.charCodeAt(i);\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\n\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.valueHexView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        try {\r\n            this.valueBlock.value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToUtf8String(inputBuffer);\r\n        }\r\n        catch (ex) {\r\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\r\n            this.valueBlock.value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToBinary(inputBuffer);\r\n        }\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromUtf8String(inputString));\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\n\nvar _a$i;\r\nclass Utf8String extends LocalUtf8StringValueBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 12;\r\n    }\r\n}\r\n_a$i = Utf8String;\r\n(() => {\r\n    typeStore.Utf8String = _a$i;\r\n})();\r\nUtf8String.NAME = \"UTF8String\";\n\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.ToUtf16String(inputBuffer);\r\n        this.valueBlock.valueHexView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer);\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.value = inputString;\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.Convert.FromUtf16String(inputString));\r\n    }\r\n}\r\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\n\nvar _a$h;\r\nclass BmpString extends LocalBmpStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 30;\r\n    }\r\n}\r\n_a$h = BmpString;\r\n(() => {\r\n    typeStore.BmpString = _a$h;\r\n})();\r\nBmpString.NAME = \"BMPString\";\n\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\r\n        const valueView = new Uint8Array(copyBuffer);\r\n        for (let i = 0; i < valueView.length; i += 4) {\r\n            valueView[i] = valueView[i + 3];\r\n            valueView[i + 1] = valueView[i + 2];\r\n            valueView[i + 2] = 0x00;\r\n            valueView[i + 3] = 0x00;\r\n        }\r\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLength = inputString.length;\r\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\r\n        for (let i = 0; i < strLength; i++) {\r\n            const codeBuf = pvutils__WEBPACK_IMPORTED_MODULE_1__.utilToBase(inputString.charCodeAt(i), 8);\r\n            const codeView = new Uint8Array(codeBuf);\r\n            if (codeView.length > 4)\r\n                continue;\r\n            const dif = 4 - codeView.length;\r\n            for (let j = (codeView.length - 1); j >= 0; j--)\r\n                valueHexView[i * 4 + j + dif] = codeView[j];\r\n        }\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\n\nvar _a$g;\r\nclass UniversalString extends LocalUniversalStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 28;\r\n    }\r\n}\r\n_a$g = UniversalString;\r\n(() => {\r\n    typeStore.UniversalString = _a$g;\r\n})();\r\nUniversalString.NAME = \"UniversalString\";\n\nvar _a$f;\r\nclass NumericString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 18;\r\n    }\r\n}\r\n_a$f = NumericString;\r\n(() => {\r\n    typeStore.NumericString = _a$f;\r\n})();\r\nNumericString.NAME = \"NumericString\";\n\nvar _a$e;\r\nclass PrintableString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 19;\r\n    }\r\n}\r\n_a$e = PrintableString;\r\n(() => {\r\n    typeStore.PrintableString = _a$e;\r\n})();\r\nPrintableString.NAME = \"PrintableString\";\n\nvar _a$d;\r\nclass TeletexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 20;\r\n    }\r\n}\r\n_a$d = TeletexString;\r\n(() => {\r\n    typeStore.TeletexString = _a$d;\r\n})();\r\nTeletexString.NAME = \"TeletexString\";\n\nvar _a$c;\r\nclass VideotexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 21;\r\n    }\r\n}\r\n_a$c = VideotexString;\r\n(() => {\r\n    typeStore.VideotexString = _a$c;\r\n})();\r\nVideotexString.NAME = \"VideotexString\";\n\nvar _a$b;\r\nclass IA5String extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 22;\r\n    }\r\n}\r\n_a$b = IA5String;\r\n(() => {\r\n    typeStore.IA5String = _a$b;\r\n})();\r\nIA5String.NAME = \"IA5String\";\n\nvar _a$a;\r\nclass GraphicString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 25;\r\n    }\r\n}\r\n_a$a = GraphicString;\r\n(() => {\r\n    typeStore.GraphicString = _a$a;\r\n})();\r\nGraphicString.NAME = \"GraphicString\";\n\nvar _a$9;\r\nclass VisibleString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 26;\r\n    }\r\n}\r\n_a$9 = VisibleString;\r\n(() => {\r\n    typeStore.VisibleString = _a$9;\r\n})();\r\nVisibleString.NAME = \"VisibleString\";\n\nvar _a$8;\r\nclass GeneralString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 27;\r\n    }\r\n}\r\n_a$8 = GeneralString;\r\n(() => {\r\n    typeStore.GeneralString = _a$8;\r\n})();\r\nGeneralString.NAME = \"GeneralString\";\n\nvar _a$7;\r\nclass CharacterString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 29;\r\n    }\r\n}\r\n_a$7 = CharacterString;\r\n(() => {\r\n    typeStore.CharacterString = _a$7;\r\n})();\r\nCharacterString.NAME = \"CharacterString\";\n\nvar _a$6;\r\nclass UTCTime extends VisibleString {\r\n    constructor({ value, valueDate, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.year = 0;\r\n        this.month = 0;\r\n        this.day = 0;\r\n        this.hour = 0;\r\n        this.minute = 0;\r\n        this.second = 0;\r\n        if (value) {\r\n            this.fromString(value);\r\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\r\n            for (let i = 0; i < value.length; i++)\r\n                this.valueBlock.valueHexView[i] = value.charCodeAt(i);\r\n        }\r\n        if (valueDate) {\r\n            this.fromDate(valueDate);\r\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\r\n        }\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 23;\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.fromString(String.fromCharCode.apply(null, pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer)));\r\n    }\r\n    toBuffer() {\r\n        const str = this.toString();\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new Uint8Array(buffer);\r\n        for (let i = 0; i < str.length; i++)\r\n            view[i] = str.charCodeAt(i);\r\n        return buffer;\r\n    }\r\n    fromDate(inputDate) {\r\n        this.year = inputDate.getUTCFullYear();\r\n        this.month = inputDate.getUTCMonth() + 1;\r\n        this.day = inputDate.getUTCDate();\r\n        this.hour = inputDate.getUTCHours();\r\n        this.minute = inputDate.getUTCMinutes();\r\n        this.second = inputDate.getUTCSeconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\r\n    }\r\n    fromString(inputString) {\r\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\r\n        const parserArray = parser.exec(inputString);\r\n        if (parserArray === null) {\r\n            this.error = \"Wrong input string for conversion\";\r\n            return;\r\n        }\r\n        const year = parseInt(parserArray[1], 10);\r\n        if (year >= 50)\r\n            this.year = 1900 + year;\r\n        else\r\n            this.year = 2000 + year;\r\n        this.month = parseInt(parserArray[2], 10);\r\n        this.day = parseInt(parserArray[3], 10);\r\n        this.hour = parseInt(parserArray[4], 10);\r\n        this.minute = parseInt(parserArray[5], 10);\r\n        this.second = parseInt(parserArray[6], 10);\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = new Array(7);\r\n            outputArray[0] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\r\n            outputArray[1] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.month, 2);\r\n            outputArray[2] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.day, 2);\r\n            outputArray[3] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.hour, 2);\r\n            outputArray[4] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.minute, 2);\r\n            outputArray[5] = pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.second, 2);\r\n            outputArray[6] = \"Z\";\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            year: this.year,\r\n            month: this.month,\r\n            day: this.day,\r\n            hour: this.hour,\r\n            minute: this.minute,\r\n            second: this.second,\r\n        };\r\n    }\r\n}\r\n_a$6 = UTCTime;\r\n(() => {\r\n    typeStore.UTCTime = _a$6;\r\n})();\r\nUTCTime.NAME = \"UTCTime\";\n\nvar _a$5;\r\nclass GeneralizedTime extends UTCTime {\r\n    constructor(parameters = {}) {\r\n        var _b;\r\n        super(parameters);\r\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 24;\r\n    }\r\n    fromDate(inputDate) {\r\n        super.fromDate(inputDate);\r\n        this.millisecond = inputDate.getUTCMilliseconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\r\n    }\r\n    fromString(inputString) {\r\n        let isUTC = false;\r\n        let timeString = \"\";\r\n        let dateTimeString = \"\";\r\n        let fractionPart = 0;\r\n        let parser;\r\n        let hourDifference = 0;\r\n        let minuteDifference = 0;\r\n        if (inputString[inputString.length - 1] === \"Z\") {\r\n            timeString = inputString.substring(0, inputString.length - 1);\r\n            isUTC = true;\r\n        }\r\n        else {\r\n            const number = new Number(inputString[inputString.length - 1]);\r\n            if (isNaN(number.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            timeString = inputString;\r\n        }\r\n        if (isUTC) {\r\n            if (timeString.indexOf(\"+\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            if (timeString.indexOf(\"-\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        else {\r\n            let multiplier = 1;\r\n            let differencePosition = timeString.indexOf(\"+\");\r\n            let differenceString = \"\";\r\n            if (differencePosition === -1) {\r\n                differencePosition = timeString.indexOf(\"-\");\r\n                multiplier = -1;\r\n            }\r\n            if (differencePosition !== -1) {\r\n                differenceString = timeString.substring(differencePosition + 1);\r\n                timeString = timeString.substring(0, differencePosition);\r\n                if ((differenceString.length !== 2) && (differenceString.length !== 4))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                let number = parseInt(differenceString.substring(0, 2), 10);\r\n                if (isNaN(number.valueOf()))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                hourDifference = multiplier * number;\r\n                if (differenceString.length === 4) {\r\n                    number = parseInt(differenceString.substring(2, 4), 10);\r\n                    if (isNaN(number.valueOf()))\r\n                        throw new Error(\"Wrong input string for conversion\");\r\n                    minuteDifference = multiplier * number;\r\n                }\r\n            }\r\n        }\r\n        let fractionPointPosition = timeString.indexOf(\".\");\r\n        if (fractionPointPosition === -1)\r\n            fractionPointPosition = timeString.indexOf(\",\");\r\n        if (fractionPointPosition !== -1) {\r\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\r\n            if (isNaN(fractionPartCheck.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            fractionPart = fractionPartCheck.valueOf();\r\n            dateTimeString = timeString.substring(0, fractionPointPosition);\r\n        }\r\n        else\r\n            dateTimeString = timeString;\r\n        switch (true) {\r\n            case (dateTimeString.length === 8):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1)\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                break;\r\n            case (dateTimeString.length === 10):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.minute = Math.floor(fractionResult);\r\n                    fractionResult = 60 * (fractionResult - this.minute);\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 12):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 14):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    const fractionResult = 1000 * fractionPart;\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        const parserArray = parser.exec(dateTimeString);\r\n        if (parserArray === null)\r\n            throw new Error(\"Wrong input string for conversion\");\r\n        for (let j = 1; j < parserArray.length; j++) {\r\n            switch (j) {\r\n                case 1:\r\n                    this.year = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 2:\r\n                    this.month = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 3:\r\n                    this.day = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 4:\r\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\r\n                    break;\r\n                case 5:\r\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\r\n                    break;\r\n                case 6:\r\n                    this.second = parseInt(parserArray[j], 10);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n            }\r\n        }\r\n        if (isUTC === false) {\r\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n            this.year = tempDate.getUTCFullYear();\r\n            this.month = tempDate.getUTCMonth();\r\n            this.day = tempDate.getUTCDay();\r\n            this.hour = tempDate.getUTCHours();\r\n            this.minute = tempDate.getUTCMinutes();\r\n            this.second = tempDate.getUTCSeconds();\r\n            this.millisecond = tempDate.getUTCMilliseconds();\r\n        }\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = [];\r\n            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.year, 4));\r\n            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.month, 2));\r\n            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.day, 2));\r\n            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.hour, 2));\r\n            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.minute, 2));\r\n            outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.second, 2));\r\n            if (this.millisecond !== 0) {\r\n                outputArray.push(\".\");\r\n                outputArray.push(pvutils__WEBPACK_IMPORTED_MODULE_1__.padNumber(this.millisecond, 3));\r\n            }\r\n            outputArray.push(\"Z\");\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            millisecond: this.millisecond,\r\n        };\r\n    }\r\n}\r\n_a$5 = GeneralizedTime;\r\n(() => {\r\n    typeStore.GeneralizedTime = _a$5;\r\n})();\r\nGeneralizedTime.NAME = \"GeneralizedTime\";\n\nvar _a$4;\r\nclass DATE extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 31;\r\n    }\r\n}\r\n_a$4 = DATE;\r\n(() => {\r\n    typeStore.DATE = _a$4;\r\n})();\r\nDATE.NAME = \"DATE\";\n\nvar _a$3;\r\nclass TimeOfDay extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 32;\r\n    }\r\n}\r\n_a$3 = TimeOfDay;\r\n(() => {\r\n    typeStore.TimeOfDay = _a$3;\r\n})();\r\nTimeOfDay.NAME = \"TimeOfDay\";\n\nvar _a$2;\r\nclass DateTime extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 33;\r\n    }\r\n}\r\n_a$2 = DateTime;\r\n(() => {\r\n    typeStore.DateTime = _a$2;\r\n})();\r\nDateTime.NAME = \"DateTime\";\n\nvar _a$1;\r\nclass Duration extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 34;\r\n    }\r\n}\r\n_a$1 = Duration;\r\n(() => {\r\n    typeStore.Duration = _a$1;\r\n})();\r\nDuration.NAME = \"Duration\";\n\nvar _a;\r\nclass TIME extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 14;\r\n    }\r\n}\r\n_a = TIME;\r\n(() => {\r\n    typeStore.TIME = _a;\r\n})();\r\nTIME.NAME = \"TIME\";\n\nclass Any {\r\n    constructor({ name = EMPTY_STRING, optional = false, } = {}) {\r\n        this.name = name;\r\n        this.optional = optional;\r\n    }\r\n}\n\nclass Choice extends Any {\r\n    constructor({ value = [], ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n    }\r\n}\n\nclass Repeated extends Any {\r\n    constructor({ value = new Any(), local = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.local = local;\r\n    }\r\n}\n\nclass RawData {\r\n    constructor({ data = EMPTY_VIEW } = {}) {\r\n        this.dataView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(data);\r\n    }\r\n    get data() {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n    set data(value) {\r\n        this.dataView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(value);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const endLength = inputOffset + inputLength;\r\n        this.dataView = pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\r\n        return endLength;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n}\n\nfunction compareSchema(root, inputData, inputSchema) {\r\n    if (inputSchema instanceof Choice) {\r\n        for (let j = 0; j < inputSchema.value.length; j++) {\r\n            const result = compareSchema(root, inputData, inputSchema.value[j]);\r\n            if (result.verified) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n        {\r\n            const _result = {\r\n                verified: false,\r\n                result: {\r\n                    error: \"Wrong values for Choice type\"\r\n                },\r\n            };\r\n            if (inputSchema.hasOwnProperty(NAME))\r\n                _result.name = inputSchema.name;\r\n            return _result;\r\n        }\r\n    }\r\n    if (inputSchema instanceof Any) {\r\n        if (inputSchema.hasOwnProperty(NAME))\r\n            root[inputSchema.name] = inputData;\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if ((root instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong root object\" }\r\n        };\r\n    }\r\n    if ((inputData instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 data\" }\r\n        };\r\n    }\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((ID_BLOCK in inputSchema) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((FROM_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((TO_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    const encodedId = inputSchema.idBlock.toBER(false);\r\n    if (encodedId.byteLength === 0) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error encoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\r\n    if (decodedOffset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error decoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly) {\r\n        if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {\r\n            return {\r\n                verified: false,\r\n                result: { error: \"Wrong ASN.1 schema\" }\r\n            };\r\n        }\r\n        const schemaView = inputSchema.idBlock.valueHexView;\r\n        const asn1View = inputData.idBlock.valueHexView;\r\n        if (schemaView.length !== asn1View.length) {\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < schemaView.length; i++) {\r\n            if (schemaView[i] !== asn1View[1]) {\r\n                return {\r\n                    verified: false,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n    }\r\n    if (inputSchema.name) {\r\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n        if (inputSchema.name)\r\n            root[inputSchema.name] = inputData;\r\n    }\r\n    if (inputSchema instanceof typeStore.Constructed) {\r\n        let admission = 0;\r\n        let result = {\r\n            verified: false,\r\n            result: {\r\n                error: \"Unknown error\",\r\n            }\r\n        };\r\n        let maxLength = inputSchema.valueBlock.value.length;\r\n        if (maxLength > 0) {\r\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                maxLength = inputData.valueBlock.value.length;\r\n            }\r\n        }\r\n        if (maxLength === 0) {\r\n            return {\r\n                verified: true,\r\n                result: root\r\n            };\r\n        }\r\n        if ((inputData.valueBlock.value.length === 0) &&\r\n            (inputSchema.valueBlock.value.length !== 0)) {\r\n            let _optional = true;\r\n            for (let i = 0; i < inputSchema.valueBlock.value.length; i++)\r\n                _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\r\n            if (_optional) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name)\r\n                    delete root[inputSchema.name];\r\n            }\r\n            root.error = \"Inconsistent object length\";\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < maxLength; i++) {\r\n            if ((i - admission) >= inputData.valueBlock.value.length) {\r\n                if (inputSchema.valueBlock.value[i].optional === false) {\r\n                    const _result = {\r\n                        verified: false,\r\n                        result: root\r\n                    };\r\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\r\n                    if (inputSchema.name) {\r\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                        if (inputSchema.name) {\r\n                            delete root[inputSchema.name];\r\n                            _result.name = inputSchema.name;\r\n                        }\r\n                    }\r\n                    return _result;\r\n                }\r\n            }\r\n            else {\r\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[0].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                    if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {\r\n                        let arrayRoot = {};\r\n                        if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))\r\n                            arrayRoot = inputData;\r\n                        else\r\n                            arrayRoot = root;\r\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\r\n                            arrayRoot[inputSchema.valueBlock.value[0].name] = [];\r\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[i].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (result.verified === false) {\r\n            const _result = {\r\n                verified: false,\r\n                result: root\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.primitiveSchema &&\r\n        (VALUE_HEX_VIEW in inputData.valueBlock)) {\r\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\r\n        if (asn1.offset === -1) {\r\n            const _result = {\r\n                verified: false,\r\n                result: asn1.result\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\r\n    }\r\n    return {\r\n        verified: true,\r\n        result: root\r\n    };\r\n}\r\nfunction verifySchema(inputBuffer, inputSchema) {\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema type\" }\r\n        };\r\n    }\r\n    const asn1 = localFromBER(pvtsutils__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    if (asn1.offset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: asn1.result\r\n        };\r\n    }\r\n    return compareSchema(asn1.result, asn1.result, inputSchema);\r\n}\n\n\n\n\n//# sourceURL=webpack://ems/./node_modules/asn1js/build/index.es.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/hashlru/index.js":
/*!***************************************!*\
  !*** ./node_modules/hashlru/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ems/./node_modules/hashlru/index.js?");

/***/ }),

/***/ "./node_modules/pvtsutils/build/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pvtsutils/build/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n\n\n\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data.buffer)\n            .slice(data.byteOffset, data.byteOffset + data.byteLength)\n            .buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data)\n            || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data)\n            || (data && this.isArrayBuffer(data.buffer));\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < aView.length; i++) {\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        let buffers;\n        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n            buffers = args[0];\n        }\n        else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n            buffers = args[0];\n        }\n        else {\n            if (args[args.length - 1] instanceof Function) {\n                buffers = args.slice(0, args.length - 1);\n            }\n            else {\n                buffers = args;\n            }\n        }\n        let size = 0;\n        for (const buffer of buffers) {\n            size += buffer.byteLength;\n        }\n        const res = new Uint8Array(size);\n        let offset = 0;\n        for (const buffer of buffers) {\n            const view = this.toUint8Array(buffer);\n            res.set(view, offset);\n            offset += view.length;\n        }\n        if (args[args.length - 1] instanceof Function) {\n            return this.toView(res, args[args.length - 1]);\n        }\n        return res.buffer;\n    }\n}\n\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for (let i = 0; i < s.length; i++) {\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for (let i = 0; i < text.length; i++) {\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === STRING_TYPE\n            && HEX_REGEX.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === STRING_TYPE\n            && BASE64_REGEX.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === STRING_TYPE\n            && BASE64URL_REGEX.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        }\n        else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        }\n        else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for (let i = 0; i < stringLength; i++) {\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let result = \"\";\n        const len = buf.length;\n        for (let i = 0; i < len; i++) {\n            const byte = buf[i];\n            if (byte < 16) {\n                result += \"0\";\n            }\n            result += byte.toString(16);\n        }\n        return result;\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for (let i = 0; i < formatted.length; i = i + 2) {\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - (base64.length % 4);\n        if (padCount < 4) {\n            for (let i = 0; i < padCount; i++) {\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\n\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for (let i = 1; i < arguments.length; i++) {\n        const obj = arguments[i];\n        for (const prop in obj) {\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item) => new Uint8Array(item)).forEach((arr) => {\n        for (const item2 of arr) {\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;\n\n\n//# sourceURL=webpack://ems/./node_modules/pvtsutils/build/index.js?");

/***/ }),

/***/ "./node_modules/pvutils/build/utils.es.js":
/*!************************************************!*\
  !*** ./node_modules/pvutils/build/utils.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayBufferToString: () => (/* binding */ arrayBufferToString),\n/* harmony export */   bufferToHexCodes: () => (/* binding */ bufferToHexCodes),\n/* harmony export */   checkBufferParams: () => (/* binding */ checkBufferParams),\n/* harmony export */   clearProps: () => (/* binding */ clearProps),\n/* harmony export */   fromBase64: () => (/* binding */ fromBase64),\n/* harmony export */   getParametersValue: () => (/* binding */ getParametersValue),\n/* harmony export */   getUTCDate: () => (/* binding */ getUTCDate),\n/* harmony export */   isEqualBuffer: () => (/* binding */ isEqualBuffer),\n/* harmony export */   nearestPowerOf2: () => (/* binding */ nearestPowerOf2),\n/* harmony export */   padNumber: () => (/* binding */ padNumber),\n/* harmony export */   stringToArrayBuffer: () => (/* binding */ stringToArrayBuffer),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   utilConcatBuf: () => (/* binding */ utilConcatBuf),\n/* harmony export */   utilConcatView: () => (/* binding */ utilConcatView),\n/* harmony export */   utilDecodeTC: () => (/* binding */ utilDecodeTC),\n/* harmony export */   utilEncodeTC: () => (/* binding */ utilEncodeTC),\n/* harmony export */   utilFromBase: () => (/* binding */ utilFromBase),\n/* harmony export */   utilToBase: () => (/* binding */ utilToBase)\n/* harmony export */ });\n/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\nfunction getUTCDate(date) {\r\n    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));\r\n}\r\nfunction getParametersValue(parameters, name, defaultValue) {\r\n    var _a;\r\n    if ((parameters instanceof Object) === false) {\r\n        return defaultValue;\r\n    }\r\n    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;\r\n}\r\nfunction bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {\r\n    let result = \"\";\r\n    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {\r\n        const str = item.toString(16).toUpperCase();\r\n        if (str.length === 1) {\r\n            result += \"0\";\r\n        }\r\n        result += str;\r\n        if (insertSpace) {\r\n            result += \" \";\r\n        }\r\n    }\r\n    return result.trim();\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof ArrayBuffer)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction utilFromBase(inputBuffer, inputBase) {\r\n    let result = 0;\r\n    if (inputBuffer.length === 1) {\r\n        return inputBuffer[0];\r\n    }\r\n    for (let i = (inputBuffer.length - 1); i >= 0; i--) {\r\n        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);\r\n    }\r\n    return result;\r\n}\r\nfunction utilToBase(value, base, reserved = (-1)) {\r\n    const internalReserved = reserved;\r\n    let internalValue = value;\r\n    let result = 0;\r\n    let biggest = Math.pow(2, base);\r\n    for (let i = 1; i < 8; i++) {\r\n        if (value < biggest) {\r\n            let retBuf;\r\n            if (internalReserved < 0) {\r\n                retBuf = new ArrayBuffer(i);\r\n                result = i;\r\n            }\r\n            else {\r\n                if (internalReserved < i) {\r\n                    return (new ArrayBuffer(0));\r\n                }\r\n                retBuf = new ArrayBuffer(internalReserved);\r\n                result = internalReserved;\r\n            }\r\n            const retView = new Uint8Array(retBuf);\r\n            for (let j = (i - 1); j >= 0; j--) {\r\n                const basis = Math.pow(2, j * base);\r\n                retView[result - j - 1] = Math.floor(internalValue / basis);\r\n                internalValue -= (retView[result - j - 1]) * basis;\r\n            }\r\n            return retBuf;\r\n        }\r\n        biggest *= Math.pow(2, base);\r\n    }\r\n    return new ArrayBuffer(0);\r\n}\r\nfunction utilConcatBuf(...buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (const buffer of buffers) {\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retBuf = new ArrayBuffer(outputLength);\r\n    const retView = new Uint8Array(retBuf);\r\n    for (const buffer of buffers) {\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retBuf;\r\n}\r\nfunction utilConcatView(...views) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (const view of views) {\r\n        outputLength += view.length;\r\n    }\r\n    const retBuf = new ArrayBuffer(outputLength);\r\n    const retView = new Uint8Array(retBuf);\r\n    for (const view of views) {\r\n        retView.set(view, prevLength);\r\n        prevLength += view.length;\r\n    }\r\n    return retView;\r\n}\r\nfunction utilDecodeTC() {\r\n    const buf = new Uint8Array(this.valueHex);\r\n    if (this.valueHex.byteLength >= 2) {\r\n        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);\r\n        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);\r\n        if (condition1 || condition2) {\r\n            this.warnings.push(\"Needlessly long format\");\r\n        }\r\n    }\r\n    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n    const bigIntView = new Uint8Array(bigIntBuffer);\r\n    for (let i = 0; i < this.valueHex.byteLength; i++) {\r\n        bigIntView[i] = 0;\r\n    }\r\n    bigIntView[0] = (buf[0] & 0x80);\r\n    const bigInt = utilFromBase(bigIntView, 8);\r\n    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n    const smallIntView = new Uint8Array(smallIntBuffer);\r\n    for (let j = 0; j < this.valueHex.byteLength; j++) {\r\n        smallIntView[j] = buf[j];\r\n    }\r\n    smallIntView[0] &= 0x7F;\r\n    const smallInt = utilFromBase(smallIntView, 8);\r\n    return (smallInt - bigInt);\r\n}\r\nfunction utilEncodeTC(value) {\r\n    const modValue = (value < 0) ? (value * (-1)) : value;\r\n    let bigInt = 128;\r\n    for (let i = 1; i < 8; i++) {\r\n        if (modValue <= bigInt) {\r\n            if (value < 0) {\r\n                const smallInt = bigInt - modValue;\r\n                const retBuf = utilToBase(smallInt, 8, i);\r\n                const retView = new Uint8Array(retBuf);\r\n                retView[0] |= 0x80;\r\n                return retBuf;\r\n            }\r\n            let retBuf = utilToBase(modValue, 8, i);\r\n            let retView = new Uint8Array(retBuf);\r\n            if (retView[0] & 0x80) {\r\n                const tempBuf = retBuf.slice(0);\r\n                const tempView = new Uint8Array(tempBuf);\r\n                retBuf = new ArrayBuffer(retBuf.byteLength + 1);\r\n                retView = new Uint8Array(retBuf);\r\n                for (let k = 0; k < tempBuf.byteLength; k++) {\r\n                    retView[k + 1] = tempView[k];\r\n                }\r\n                retView[0] = 0x00;\r\n            }\r\n            return retBuf;\r\n        }\r\n        bigInt *= Math.pow(2, 8);\r\n    }\r\n    return (new ArrayBuffer(0));\r\n}\r\nfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\r\n    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {\r\n        return false;\r\n    }\r\n    const view1 = new Uint8Array(inputBuffer1);\r\n    const view2 = new Uint8Array(inputBuffer2);\r\n    for (let i = 0; i < view1.length; i++) {\r\n        if (view1[i] !== view2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction padNumber(inputNumber, fullLength) {\r\n    const str = inputNumber.toString(10);\r\n    if (fullLength < str.length) {\r\n        return \"\";\r\n    }\r\n    const dif = fullLength - str.length;\r\n    const padding = new Array(dif);\r\n    for (let i = 0; i < dif; i++) {\r\n        padding[i] = \"0\";\r\n    }\r\n    const paddingString = padding.join(\"\");\r\n    return paddingString.concat(str);\r\n}\r\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\r\nfunction toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {\r\n    let i = 0;\r\n    let flag1 = 0;\r\n    let flag2 = 0;\r\n    let output = \"\";\r\n    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n    if (skipLeadingZeros) {\r\n        let nonZeroPosition = 0;\r\n        for (let i = 0; i < input.length; i++) {\r\n            if (input.charCodeAt(i) !== 0) {\r\n                nonZeroPosition = i;\r\n                break;\r\n            }\r\n        }\r\n        input = input.slice(nonZeroPosition);\r\n    }\r\n    while (i < input.length) {\r\n        const chr1 = input.charCodeAt(i++);\r\n        if (i >= input.length) {\r\n            flag1 = 1;\r\n        }\r\n        const chr2 = input.charCodeAt(i++);\r\n        if (i >= input.length) {\r\n            flag2 = 1;\r\n        }\r\n        const chr3 = input.charCodeAt(i++);\r\n        const enc1 = chr1 >> 2;\r\n        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);\r\n        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);\r\n        let enc4 = chr3 & 0x3F;\r\n        if (flag1 === 1) {\r\n            enc3 = enc4 = 64;\r\n        }\r\n        else {\r\n            if (flag2 === 1) {\r\n                enc4 = 64;\r\n            }\r\n        }\r\n        if (skipPadding) {\r\n            if (enc3 === 64) {\r\n                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;\r\n            }\r\n            else {\r\n                if (enc4 === 64) {\r\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\r\n                }\r\n                else {\r\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {\r\n    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n    function indexOf(toSearch) {\r\n        for (let i = 0; i < 64; i++) {\r\n            if (template.charAt(i) === toSearch)\r\n                return i;\r\n        }\r\n        return 64;\r\n    }\r\n    function test(incoming) {\r\n        return ((incoming === 64) ? 0x00 : incoming);\r\n    }\r\n    let i = 0;\r\n    let output = \"\";\r\n    while (i < input.length) {\r\n        const enc1 = indexOf(input.charAt(i++));\r\n        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);\r\n        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);\r\n        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);\r\n        output += String.fromCharCode(chr1);\r\n        if (enc3 !== 64) {\r\n            output += String.fromCharCode(chr2);\r\n        }\r\n        if (enc4 !== 64) {\r\n            output += String.fromCharCode(chr3);\r\n        }\r\n    }\r\n    if (cutTailZeros) {\r\n        const outputLength = output.length;\r\n        let nonZeroStart = (-1);\r\n        for (let i = (outputLength - 1); i >= 0; i--) {\r\n            if (output.charCodeAt(i) !== 0) {\r\n                nonZeroStart = i;\r\n                break;\r\n            }\r\n        }\r\n        if (nonZeroStart !== (-1)) {\r\n            output = output.slice(0, nonZeroStart + 1);\r\n        }\r\n        else {\r\n            output = \"\";\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction arrayBufferToString(buffer) {\r\n    let resultString = \"\";\r\n    const view = new Uint8Array(buffer);\r\n    for (const element of view) {\r\n        resultString += String.fromCharCode(element);\r\n    }\r\n    return resultString;\r\n}\r\nfunction stringToArrayBuffer(str) {\r\n    const stringLength = str.length;\r\n    const resultBuffer = new ArrayBuffer(stringLength);\r\n    const resultView = new Uint8Array(resultBuffer);\r\n    for (let i = 0; i < stringLength; i++) {\r\n        resultView[i] = str.charCodeAt(i);\r\n    }\r\n    return resultBuffer;\r\n}\r\nconst log2 = Math.log(2);\r\nfunction nearestPowerOf2(length) {\r\n    const base = (Math.log(length) / log2);\r\n    const floor = Math.floor(base);\r\n    const round = Math.round(base);\r\n    return ((floor === round) ? floor : round);\r\n}\r\nfunction clearProps(object, propsArray) {\r\n    for (const prop of propsArray) {\r\n        delete object[prop];\r\n    }\r\n}\n\n\n\n\n//# sourceURL=webpack://ems/./node_modules/pvutils/build/utils.es.js?");

/***/ }),

/***/ "./node_modules/retimer/retimer.js":
/*!*****************************************!*\
  !*** ./node_modules/retimer/retimer.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst getTime = __webpack_require__(/*! ./time */ \"./node_modules/retimer/time-browser.js\")\n\nclass Retimer {\n  constructor (callback, timeout, args) {\n    const that = this\n\n    this._started = getTime()\n    this._rescheduled = 0\n    this._scheduled = timeout\n    this._args = args\n    this._triggered = false\n\n    this._timerWrapper = () => {\n      if (that._rescheduled > 0) {\n        that._scheduled = that._rescheduled - (getTime() - that._started)\n        that._schedule(that._scheduled)\n      } else {\n        that._triggered = true\n        callback.apply(null, that._args)\n      }\n    }\n\n    this._timer = setTimeout(this._timerWrapper, timeout)\n  }\n\n  reschedule (timeout) {\n    if (!timeout) {\n      timeout = this._scheduled\n    }\n    const now = getTime()\n    if ((now + timeout) - (this._started + this._scheduled) < 0) {\n      clearTimeout(this._timer)\n      this._schedule(timeout)\n    } else if (!this._triggered) {\n      this._started = now\n      this._rescheduled = timeout\n    } else {\n      this._schedule(timeout)\n    }\n  }\n\n  _schedule (timeout) {\n    this._triggered = false\n    this._started = getTime()\n    this._rescheduled = 0\n    this._scheduled = timeout\n    this._timer = setTimeout(this._timerWrapper, timeout)\n  }\n\n  clear () {\n    clearTimeout(this._timer)\n  }\n}\n\nfunction retimer () {\n  if (typeof arguments[0] !== 'function') {\n    throw new Error('callback needed')\n  }\n\n  if (typeof arguments[1] !== 'number') {\n    throw new Error('timeout needed')\n  }\n\n  let args\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2)\n\n    /* eslint-disable no-var */\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2]\n    }\n  }\n\n  return new Retimer(arguments[0], arguments[1], args)\n}\n\nmodule.exports = retimer\n\n\n//# sourceURL=webpack://ems/./node_modules/retimer/retimer.js?");

/***/ }),

/***/ "./node_modules/retimer/time-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/retimer/time-browser.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function getTime () {\n  return Date.now()\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/retimer/time-browser.js?");

/***/ }),

/***/ "./node_modules/timeout-abort-controller/index.js":
/*!********************************************************!*\
  !*** ./node_modules/timeout-abort-controller/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { AbortController } = globalThis\n\n// @ts-expect-error no types\nconst retimer = __webpack_require__(/*! retimer */ \"./node_modules/retimer/retimer.js\")\n\nclass TimeoutController extends AbortController {\n  /**\n   * @constructor\n   * @param {number} ms milliseconds\n   */\n  constructor (ms) {\n    super()\n    this._ms = ms\n    this._timer = retimer(() => this.abort(), ms)\n    // Patch for safari not supported extending built in classes\n    Object.setPrototypeOf(this, TimeoutController.prototype)\n  }\n\n  /**\n   * Aborts the controller and clears the timer\n   */\n  abort () {\n    this._timer.clear()\n    return super.abort()\n  }\n\n  /**\n   * Clears the timer\n   */\n  clear () {\n    this._timer.clear()\n  }\n\n  /**\n   * Resets the timer\n   */\n  reset () {\n    this._timer.clear()\n    this._timer = retimer(() => this.abort(), this._ms)\n  }\n}\n\nmodule.exports = {\n  TimeoutController\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/timeout-abort-controller/index.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/decode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/decode.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/decode.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/encode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/encode.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/encode.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n    encode: __webpack_require__(/*! ./encode.js */ \"./node_modules/varint-decoder/node_modules/varint/encode.js\")\n  , decode: __webpack_require__(/*! ./decode.js */ \"./node_modules/varint-decoder/node_modules/varint/decode.js\")\n  , encodingLength: __webpack_require__(/*! ./length.js */ \"./node_modules/varint-decoder/node_modules/varint/length.js\")\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/index.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/node_modules/varint/length.js":
/*!*******************************************************************!*\
  !*** ./node_modules/varint-decoder/node_modules/varint/length.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/node_modules/varint/length.js?");

/***/ }),

/***/ "./node_modules/varint-decoder/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/varint-decoder/src/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst varint = __webpack_require__(/*! varint */ \"./node_modules/varint-decoder/node_modules/varint/index.js\")\n\nmodule.exports = (buf) => {\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('arg needs to be a Uint8Array')\n  }\n\n  const result = []\n\n  while (buf.length > 0) {\n    const num = varint.decode(buf)\n    result.push(num)\n    buf = buf.slice(varint.decode.bytes)\n  }\n\n  return result\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint-decoder/src/index.js?");

/***/ }),

/***/ "./node_modules/varint/decode.js":
/*!***************************************!*\
  !*** ./node_modules/varint/decode.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/decode.js?");

/***/ }),

/***/ "./node_modules/varint/encode.js":
/*!***************************************!*\
  !*** ./node_modules/varint/encode.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/encode.js?");

/***/ }),

/***/ "./node_modules/varint/index.js":
/*!**************************************!*\
  !*** ./node_modules/varint/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n    encode: __webpack_require__(/*! ./encode.js */ \"./node_modules/varint/encode.js\")\n  , decode: __webpack_require__(/*! ./decode.js */ \"./node_modules/varint/decode.js\")\n  , encodingLength: __webpack_require__(/*! ./length.js */ \"./node_modules/varint/length.js\")\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/index.js?");

/***/ }),

/***/ "./node_modules/varint/length.js":
/*!***************************************!*\
  !*** ./node_modules/varint/length.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n\n\n//# sourceURL=webpack://ems/./node_modules/varint/length.js?");

/***/ }),

/***/ "./node_modules/timestamp-nano/dist/timestamp.min.js":
/*!***********************************************************!*\
  !*** ./node_modules/timestamp-nano/dist/timestamp.min.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("var Timestamp=function(){ true&&(module.exports=d);var l=86400,s=3200,T=146097*s/400,e=l*T,f=1e3*e,c=864e13,g=4294967296,h=1e6,u=\"000000000\",m=Math.trunc||function(n){var t=n-n%1;return 0==t&&(n<0||0===n&&1/n!=1/0)?-0:t},n=d.prototype,o=(d.fromDate=function(n){return new d(+n)},d.fromInt64BE=r(0,1,2,3,0,4),d.fromInt64LE=r(3,2,1,0,4,0),d.fromString=function(n){var e,r=new d,n=(n+=\"\").replace(/^\\s*[+\\-]?\\d+/,function(n){var n=+n,t=1970+(n-1970)%400;return r.year=n-t,t}).replace(/(?:Z|([+\\-]\\d{2}):?(\\d{2}))$/,function(n,t,r){return t<0&&(r*=-1),e=6e4*(60*+t+ +r),\"\"}).replace(/\\.\\d+$/,function(n){return r.nano=+(n+u).substr(1,9),\"\"}).split(/\\D+/);1<n.length?n[1]--:n[1]=0;if(r.time=e=Date.UTC.apply(Date,n)-(e||0),isNaN(e))throw new TypeError(\"Invalid Date\");return p(r)},d.fromTimeT=function(n){return y(n,0)},n.year=0,n.time=0,n.nano=0,n.addNano=function(n){return this.nano+=+n||0,this},n.getNano=function(){var n=p(this);return(n.time%1e3*h+ +n.nano+1e9)%1e9},n.getTimeT=function(){var n=p(this),t=Math.floor(n.time/1e3),n=n.year;n&&(t+=n*T*l/s);return t},n.getYear=function(){return this.toDate().getUTCFullYear()+this.year},n.toDate=function(){return M(p(this).time)},n.toJSON=function(){return this.toString().replace(/0{1,6}Z$/,\"Z\")},n.toString=function(n){var t=this,r=t.toDate(),u={H:function(){return C(r.getUTCHours())},L:function(){return D(r.getUTCMilliseconds(),3)},M:function(){return C(r.getUTCMinutes())},N:function(){return D(t.getNano(),9)},S:function(){return C(r.getUTCSeconds())},Y:function(){var n=t.getYear();return 999999<n?\"+\"+n:9999<n?\"+\"+D(n,6):0<=n?D(n,4):-999999<=n?\"-\"+D(-n,6):n},a:function(){return a[r.getUTCDay()]},b:function(){return i[r.getUTCMonth()]},d:function(){return C(r.getUTCDate())},e:function(){return function(n){return(9<n?\"\":\" \")+(0|n)}(r.getUTCDate())},m:function(){return C(r.getUTCMonth()+1)}};return function e(n){return n.replace(/%./g,function(n){var t=n[1],r=v[t],t=u[t];return r?e(r):t?t():n})}(n||o)},n.writeInt64BE=t(0,1,2,3,0,4),n.writeInt64LE=t(3,2,1,0,4,0),\"%Y-%m-%dT%H:%M:%S.%NZ\"),i=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],a=[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],v={\"%\":\"%\",F:\"%Y-%m-%d\",n:\"\\n\",R:\"%H:%M\",T:\"%H:%M:%S\",t:\"\\t\",X:\"%T\",Z:\"GMT\",z:\"+0000\"};return d;function d(n,t,r){var e=this;if(!(e instanceof d))return new d(n,t,r);e.time=+n||0,e.nano=+t||0,e.year=+r||0,p(e)}function p(n){var t,r,e,u=n.year,o=n.time,i=n.nano,a=((i<0||h<=i)&&(i-=(r=Math.floor(i/h))*h,o+=r,r=1),u%s);return(o<-c||c<o||a)&&((t=m(o/f))&&(u+=t*s,o-=t*f),(e=M(o)).setUTCFullYear(a+e.getUTCFullYear()),e=(o=+e)+(t=m((u-=a)/s))*f,t&&-c<=e&&e<=c&&(u-=t*s,o=e),r=1),r&&(n.year=u,n.time=o,n.nano=i),n}function M(n){var t=new Date(0);return t.setTime(n),t}function y(n,t){n=+n||0;var r=m((t=(t|0)*g)/e)+m(n/e),t=t%e+n%e,n=m(t/e);return n&&(r+=n,t-=n*e),new d(1e3*t,0,r*s)}function t(e,u,o,i,a,f){return function(n,t){var r=p(this);n=n||new Array(8);w(n,t|=0);var e=Math.floor(r.time/1e3),r=r.year*(T*l/s),u=m(r/g)+m(e/g),r=r%g+e%g,e=Math.floor(r/g);e&&(u+=e,r-=e*g);return c(n,t+a,u),c(n,t+f,r),n};function c(n,t,r){n[t+e]=r>>24&255,n[t+u]=r>>16&255,n[t+o]=r>>8&255,n[t+i]=255&r}}function r(r,e,u,o,i,a){return function(n,t){w(n,t|=0);var r=f(n,t+i);return y(f(n,t+a),r)};function f(n,t){return 16777216*n[t+r]+(n[t+e]<<16|n[t+u]<<8|n[t+o])}}function w(n,t){n=n&&n.length;if(null==n)throw new TypeError(\"Invalid Buffer\");if(n<t+8)throw new RangeError(\"Out of range\")}function C(n){return(9<n?\"\":\"0\")+(0|n)}function D(n,t){return(u+(0|n)).substr(-t)}}();\n\n//# sourceURL=webpack://ems/./node_modules/timestamp-nano/dist/timestamp.min.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/is-ip/lib/is-ip.js":
/*!****************************************************!*\
  !*** ./node_modules/@chainsafe/is-ip/lib/is-ip.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ipVersion: () => (/* binding */ ipVersion),\n/* harmony export */   isIP: () => (/* binding */ isIP),\n/* harmony export */   isIPv4: () => (/* binding */ isIPv4),\n/* harmony export */   isIPv6: () => (/* binding */ isIPv6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/@chainsafe/is-ip/lib/parse.js\");\n\n/** Check if `input` is IPv4. */\nfunction isIPv4(input) {\n    return Boolean((0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.parseIPv4)(input));\n}\n/** Check if `input` is IPv6. */\nfunction isIPv6(input) {\n    return Boolean((0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.parseIPv6)(input));\n}\n/** Check if `input` is IPv4 or IPv6. */\nfunction isIP(input) {\n    return Boolean((0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.parseIP)(input));\n}\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nfunction ipVersion(input) {\n    if (isIPv4(input)) {\n        return 4;\n    }\n    else if (isIPv6(input)) {\n        return 6;\n    }\n    else {\n        return undefined;\n    }\n}\n//# sourceMappingURL=is-ip.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/is-ip/lib/is-ip.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/is-ip/lib/parse.js":
/*!****************************************************!*\
  !*** ./node_modules/@chainsafe/is-ip/lib/parse.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseIP: () => (/* binding */ parseIP),\n/* harmony export */   parseIPv4: () => (/* binding */ parseIPv4),\n/* harmony export */   parseIPv6: () => (/* binding */ parseIPv6)\n/* harmony export */ });\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser.js */ \"./node_modules/@chainsafe/is-ip/lib/parser.js\");\n\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\nconst parser = new _parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser();\n/** Parse `input` into IPv4 bytes. */\nfunction parseIPv4(input) {\n    if (input.length > MAX_IPV4_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n/** Parse `input` into IPv6 bytes. */\nfunction parseIPv6(input) {\n    // strip zone index if it is present\n    if (input.includes(\"%\")) {\n        input = input.split(\"%\")[0];\n    }\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n/** Parse `input` into IPv4 or IPv6 bytes. */\nfunction parseIP(input) {\n    // strip zone index if it is present\n    if (input.includes(\"%\")) {\n        input = input.split(\"%\")[0];\n    }\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPAddr());\n}\n//# sourceMappingURL=parse.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/is-ip/lib/parse.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/is-ip/lib/parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@chainsafe/is-ip/lib/parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-unsafe-return */\nclass Parser {\n    index = 0;\n    input = \"\";\n    new(input) {\n        this.index = 0;\n        this.input = input;\n        return this;\n    }\n    /** Run a parser, and restore the pre-parse state if it fails. */\n    readAtomically(fn) {\n        const index = this.index;\n        const result = fn();\n        if (result === undefined) {\n            this.index = index;\n        }\n        return result;\n    }\n    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n    parseWith(fn) {\n        const result = fn();\n        if (this.index !== this.input.length) {\n            return undefined;\n        }\n        return result;\n    }\n    /** Peek the next character from the input */\n    peekChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index];\n    }\n    /** Read the next character from the input */\n    readChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index++];\n    }\n    /** Read the next character from the input if it matches the target. */\n    readGivenChar(target) {\n        return this.readAtomically(() => {\n            const char = this.readChar();\n            if (char !== target) {\n                return undefined;\n            }\n            return char;\n        });\n    }\n    /**\n     * Helper for reading separators in an indexed loop. Reads the separator\n     * character iff index > 0, then runs the parser. When used in a loop,\n     * the separator character will only be read on index > 0 (see\n     * readIPv4Addr for an example)\n     */\n    readSeparator(sep, index, inner) {\n        return this.readAtomically(() => {\n            if (index > 0) {\n                if (this.readGivenChar(sep) === undefined) {\n                    return undefined;\n                }\n            }\n            return inner();\n        });\n    }\n    /**\n     * Read a number off the front of the input in the given radix, stopping\n     * at the first non-digit character or eof. Fails if the number has more\n     * digits than max_digits or if there is no number.\n     */\n    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {\n        return this.readAtomically(() => {\n            let result = 0;\n            let digitCount = 0;\n            const leadingChar = this.peekChar();\n            if (leadingChar === undefined) {\n                return undefined;\n            }\n            const hasLeadingZero = leadingChar === \"0\";\n            const maxValue = 2 ** (8 * maxBytes) - 1;\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const digit = this.readAtomically(() => {\n                    const char = this.readChar();\n                    if (char === undefined) {\n                        return undefined;\n                    }\n                    const num = Number.parseInt(char, radix);\n                    if (Number.isNaN(num)) {\n                        return undefined;\n                    }\n                    return num;\n                });\n                if (digit === undefined) {\n                    break;\n                }\n                result *= radix;\n                result += digit;\n                if (result > maxValue) {\n                    return undefined;\n                }\n                digitCount += 1;\n                if (maxDigits !== undefined) {\n                    if (digitCount > maxDigits) {\n                        return undefined;\n                    }\n                }\n            }\n            if (digitCount === 0) {\n                return undefined;\n            }\n            else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n                return undefined;\n            }\n            else {\n                return result;\n            }\n        });\n    }\n    /** Read an IPv4 address. */\n    readIPv4Addr() {\n        return this.readAtomically(() => {\n            const out = new Uint8Array(4);\n            for (let i = 0; i < out.length; i++) {\n                const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n                if (ix === undefined) {\n                    return undefined;\n                }\n                out[i] = ix;\n            }\n            return out;\n        });\n    }\n    /** Read an IPv6 Address. */\n    readIPv6Addr() {\n        /**\n         * Read a chunk of an IPv6 address into `groups`. Returns the number\n         * of groups read, along with a bool indicating if an embedded\n         * trailing IPv4 address was read. Specifically, read a series of\n         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n         * trailing embedded IPv4 address.\n         */\n        const readGroups = (groups) => {\n            for (let i = 0; i < groups.length / 2; i++) {\n                const ix = i * 2;\n                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n                if (i < groups.length - 3) {\n                    const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n                    if (ipv4 !== undefined) {\n                        groups[ix] = ipv4[0];\n                        groups[ix + 1] = ipv4[1];\n                        groups[ix + 2] = ipv4[2];\n                        groups[ix + 3] = ipv4[3];\n                        return [ix + 4, true];\n                    }\n                }\n                const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n                if (group === undefined) {\n                    return [ix, false];\n                }\n                groups[ix] = group >> 8;\n                groups[ix + 1] = group & 255;\n            }\n            return [groups.length, false];\n        };\n        return this.readAtomically(() => {\n            // Read the front part of the address; either the whole thing, or up to the first ::\n            const head = new Uint8Array(16);\n            const [headSize, headIp4] = readGroups(head);\n            if (headSize === 16) {\n                return head;\n            }\n            // IPv4 part is not allowed before `::`\n            if (headIp4) {\n                return undefined;\n            }\n            // Read `::` if previous code parsed less than 8 groups.\n            // `::` indicates one or more groups of 16 bits of zeros.\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            // Read the back part of the address. The :: must contain at least one\n            // set of zeroes, so our max length is 7.\n            const tail = new Uint8Array(14);\n            const limit = 16 - (headSize + 2);\n            const [tailSize] = readGroups(tail.subarray(0, limit));\n            // Concat the head and tail of the IP address\n            head.set(tail.subarray(0, tailSize), 16 - tailSize);\n            return head;\n        });\n    }\n    /** Read an IP Address, either IPv4 or IPv6. */\n    readIPAddr() {\n        return this.readIPv4Addr() ?? this.readIPv6Addr();\n    }\n}\n//# sourceMappingURL=parser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/is-ip/lib/parser.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/cidr.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/cidr.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cidrMask: () => (/* binding */ cidrMask),\n/* harmony export */   parseCidr: () => (/* binding */ parseCidr)\n/* harmony export */ });\n/* harmony import */ var _chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip/parse */ \"./node_modules/@chainsafe/is-ip/lib/parse.js\");\n/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ip.js */ \"./node_modules/@chainsafe/netmask/dist/src/ip.js\");\n\n\nfunction parseCidr(s) {\n    const [address, maskString] = s.split(\"/\");\n    if (!address || !maskString)\n        throw new Error(\"Failed to parse given CIDR: \" + s);\n    let ipLength = _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv4Len;\n    let ip = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIPv4)(address);\n    if (ip == null) {\n        ipLength = _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv6Len;\n        ip = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIPv6)(address);\n        if (ip == null)\n            throw new Error(\"Failed to parse given CIDR: \" + s);\n    }\n    const m = parseInt(maskString, 10);\n    if (Number.isNaN(m) ||\n        String(m).length !== maskString.length ||\n        m < 0 ||\n        m > ipLength * 8) {\n        throw new Error(\"Failed to parse given CIDR: \" + s);\n    }\n    const mask = cidrMask(m, 8 * ipLength);\n    return {\n        network: (0,_ip_js__WEBPACK_IMPORTED_MODULE_1__.maskIp)(ip, mask),\n        mask,\n    };\n}\nfunction cidrMask(ones, bits) {\n    if (bits !== 8 * _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv4Len && bits !== 8 * _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv6Len)\n        throw new Error(\"Invalid CIDR mask\");\n    if (ones < 0 || ones > bits)\n        throw new Error(\"Invalid CIDR mask\");\n    const l = bits / 8;\n    const m = new Uint8Array(l);\n    for (let i = 0; i < l; i++) {\n        if (ones >= 8) {\n            m[i] = 0xff;\n            ones -= 8;\n            continue;\n        }\n        m[i] = 255 - (0xff >> ones);\n        ones = 0;\n    }\n    return m;\n}\n//# sourceMappingURL=cidr.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/netmask/dist/src/cidr.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpNet: () => (/* reexport safe */ _ipnet_js__WEBPACK_IMPORTED_MODULE_0__.IpNet),\n/* harmony export */   cidrContains: () => (/* binding */ cidrContains),\n/* harmony export */   iPv4FromIPv6: () => (/* reexport safe */ _ip_js__WEBPACK_IMPORTED_MODULE_2__.iPv4FromIPv6),\n/* harmony export */   ipToString: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.ipToString),\n/* harmony export */   isIPv4mappedIPv6: () => (/* reexport safe */ _ip_js__WEBPACK_IMPORTED_MODULE_2__.isIPv4mappedIPv6),\n/* harmony export */   maskIp: () => (/* reexport safe */ _ip_js__WEBPACK_IMPORTED_MODULE_2__.maskIp),\n/* harmony export */   parseCidr: () => (/* reexport safe */ _cidr_js__WEBPACK_IMPORTED_MODULE_3__.parseCidr)\n/* harmony export */ });\n/* harmony import */ var _ipnet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ipnet.js */ \"./node_modules/@chainsafe/netmask/dist/src/ipnet.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@chainsafe/netmask/dist/src/util.js\");\n/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ip.js */ \"./node_modules/@chainsafe/netmask/dist/src/ip.js\");\n/* harmony import */ var _cidr_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cidr.js */ \"./node_modules/@chainsafe/netmask/dist/src/cidr.js\");\n\n\n\n\n\n/**\n * Checks if cidr block contains ip address\n * @param cidr ipv4 or ipv6 formatted cidr . Example 198.51.100.14/24 or 2001:db8::/48\n * @param ip ipv4 or ipv6 address Example 198.51.100.14 or 2001:db8::\n *\n */\nfunction cidrContains(cidr, ip) {\n    const ipnet = new _ipnet_js__WEBPACK_IMPORTED_MODULE_0__.IpNet(cidr);\n    return ipnet.contains(ip);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/netmask/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/ip.js":
/*!********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/ip.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IPv4Len: () => (/* binding */ IPv4Len),\n/* harmony export */   IPv6Len: () => (/* binding */ IPv6Len),\n/* harmony export */   containsIp: () => (/* binding */ containsIp),\n/* harmony export */   iPv4FromIPv6: () => (/* binding */ iPv4FromIPv6),\n/* harmony export */   ipv4Prefix: () => (/* binding */ ipv4Prefix),\n/* harmony export */   isIPv4mappedIPv6: () => (/* binding */ isIPv4mappedIPv6),\n/* harmony export */   maskIp: () => (/* binding */ maskIp),\n/* harmony export */   maxIPv6Octet: () => (/* binding */ maxIPv6Octet)\n/* harmony export */ });\n/* harmony import */ var _chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip/parse */ \"./node_modules/@chainsafe/is-ip/lib/parse.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@chainsafe/netmask/dist/src/util.js\");\n\n\nconst IPv4Len = 4;\nconst IPv6Len = 16;\nconst maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nconst ipv4Prefix = new Uint8Array([\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\nfunction maskIp(ip, mask) {\n    if (mask.length === IPv6Len && ip.length === IPv4Len && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.allFF)(mask, 0, 11)) {\n        mask = mask.slice(12);\n    }\n    if (mask.length === IPv4Len &&\n        ip.length === IPv6Len &&\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(ip, ipv4Prefix, 0, 11)) {\n        ip = ip.slice(12);\n    }\n    const n = ip.length;\n    if (n != mask.length) {\n        throw new Error(\"Failed to mask ip\");\n    }\n    const out = new Uint8Array(n);\n    for (let i = 0; i < n; i++) {\n        out[i] = ip[i] & mask[i];\n    }\n    return out;\n}\nfunction containsIp(net, ip) {\n    if (typeof ip === \"string\") {\n        ip = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIP)(ip);\n    }\n    if (ip == null)\n        throw new Error(\"Invalid ip\");\n    if (ip.length !== net.network.length) {\n        return false;\n    }\n    for (let i = 0; i < ip.length; i++) {\n        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction iPv4FromIPv6(ip) {\n    if (!isIPv4mappedIPv6(ip)) {\n        throw new Error(\"Must have 0xffff prefix\");\n    }\n    return ip.slice(12);\n}\nfunction isIPv4mappedIPv6(ip) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(ip, ipv4Prefix, 0, 11);\n}\n//# sourceMappingURL=ip.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/netmask/dist/src/ip.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/ipnet.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/ipnet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpNet: () => (/* binding */ IpNet)\n/* harmony export */ });\n/* harmony import */ var _chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip/parse */ \"./node_modules/@chainsafe/is-ip/lib/parse.js\");\n/* harmony import */ var _cidr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cidr.js */ \"./node_modules/@chainsafe/netmask/dist/src/cidr.js\");\n/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ip.js */ \"./node_modules/@chainsafe/netmask/dist/src/ip.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@chainsafe/netmask/dist/src/util.js\");\n\n\n\n\nclass IpNet {\n    /**\n     *\n     * @param ipOrCidr either network ip or full cidr address\n     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address\n     */\n    constructor(ipOrCidr, mask) {\n        if (mask == null) {\n            ({ network: this.network, mask: this.mask } = (0,_cidr_js__WEBPACK_IMPORTED_MODULE_1__.parseCidr)(ipOrCidr));\n        }\n        else {\n            const ipResult = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIP)(ipOrCidr);\n            if (ipResult == null) {\n                throw new Error(\"Failed to parse network\");\n            }\n            mask = String(mask);\n            const m = parseInt(mask, 10);\n            if (Number.isNaN(m) ||\n                String(m).length !== mask.length ||\n                m < 0 ||\n                m > ipResult.length * 8) {\n                const maskResult = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIP)(mask);\n                if (maskResult == null) {\n                    throw new Error(\"Failed to parse mask\");\n                }\n                this.mask = maskResult;\n            }\n            else {\n                this.mask = (0,_cidr_js__WEBPACK_IMPORTED_MODULE_1__.cidrMask)(m, 8 * ipResult.length);\n            }\n            this.network = (0,_ip_js__WEBPACK_IMPORTED_MODULE_2__.maskIp)(ipResult, this.mask);\n        }\n    }\n    /**\n     * Checks if netmask contains ip address\n     * @param ip\n     * @returns\n     */\n    contains(ip) {\n        return (0,_ip_js__WEBPACK_IMPORTED_MODULE_2__.containsIp)({ network: this.network, mask: this.mask }, ip);\n    }\n    /**Serializes back to string format */\n    toString() {\n        const l = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.simpleMaskLength)(this.mask);\n        const mask = l !== -1 ? String(l) : (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.maskToHex)(this.mask);\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.ipToString)(this.network) + \"/\" + mask;\n    }\n}\n//# sourceMappingURL=ipnet.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/netmask/dist/src/ipnet.js?");

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allFF: () => (/* binding */ allFF),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   ipToString: () => (/* binding */ ipToString),\n/* harmony export */   maskToHex: () => (/* binding */ maskToHex),\n/* harmony export */   simpleMaskLength: () => (/* binding */ simpleMaskLength)\n/* harmony export */ });\n/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ip.js */ \"./node_modules/@chainsafe/netmask/dist/src/ip.js\");\n\nfunction allFF(a, from, to) {\n    let i = 0;\n    for (const e of a) {\n        if (i < from)\n            continue;\n        if (i > to)\n            break;\n        if (e !== 0xff)\n            return false;\n        i++;\n    }\n    return true;\n}\nfunction deepEqual(a, b, from, to) {\n    let i = 0;\n    for (const e of a) {\n        if (i < from)\n            continue;\n        if (i > to)\n            break;\n        if (e !== b[i])\n            return false;\n        i++;\n    }\n    return true;\n}\n/***\n * Returns long ip format\n */\nfunction ipToString(ip) {\n    switch (ip.length) {\n        case _ip_js__WEBPACK_IMPORTED_MODULE_0__.IPv4Len: {\n            return ip.join(\".\");\n        }\n        case _ip_js__WEBPACK_IMPORTED_MODULE_0__.IPv6Len: {\n            const result = [];\n            for (let i = 0; i < ip.length; i++) {\n                if (i % 2 === 0) {\n                    result.push(ip[i].toString(16).padStart(2, \"0\") +\n                        ip[i + 1].toString(16).padStart(2, \"0\"));\n                }\n            }\n            return result.join(\":\");\n        }\n        default: {\n            throw new Error(\"Invalid ip length\");\n        }\n    }\n}\n/**\n * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1\n */\nfunction simpleMaskLength(mask) {\n    let ones = 0;\n    // eslint-disable-next-line prefer-const\n    for (let [index, byte] of mask.entries()) {\n        if (byte === 0xff) {\n            ones += 8;\n            continue;\n        }\n        while ((byte & 0x80) != 0) {\n            ones++;\n            byte = byte << 1;\n        }\n        if ((byte & 0x80) != 0) {\n            return -1;\n        }\n        for (let i = index + 1; i < mask.length; i++) {\n            if (mask[i] != 0) {\n                return -1;\n            }\n        }\n        break;\n    }\n    return ones;\n}\nfunction maskToHex(mask) {\n    let hex = \"0x\";\n    for (const byte of mask) {\n        hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);\n    }\n    return hex;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@chainsafe/netmask/dist/src/util.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/bitswap.js":
/*!***************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/bitswap.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitswap: () => (/* binding */ bitswap)\n/* harmony export */ });\n/* harmony import */ var ipfs_bitswap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-bitswap */ \"./node_modules/ipfs-bitswap/dist/src/index.js\");\n\nclass BitswapBlockBroker {\n    bitswap;\n    started;\n    constructor(components, init = {}) {\n        const { libp2p, blockstore, hashers } = components;\n        this.bitswap = (0,ipfs_bitswap__WEBPACK_IMPORTED_MODULE_0__.createBitswap)(libp2p, blockstore, {\n            hashLoader: {\n                getHasher: async (codecOrName) => {\n                    let hasher;\n                    if (typeof codecOrName === 'string') {\n                        hasher = Object.values(hashers).find(hasher => {\n                            return hasher.name === codecOrName;\n                        });\n                    }\n                    else {\n                        hasher = hashers[codecOrName];\n                    }\n                    if (hasher != null) {\n                        return hasher;\n                    }\n                    throw new Error(`Could not load hasher for code/name \"${codecOrName}\"`);\n                }\n            },\n            ...init\n        });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await this.bitswap.start();\n        this.started = true;\n    }\n    async stop() {\n        await this.bitswap.stop();\n        this.started = false;\n    }\n    announce(cid, block, options) {\n        this.bitswap.notify(cid, block, options);\n    }\n    async retrieve(cid, { validateFn, ...options } = {}) {\n        return this.bitswap.want(cid, options);\n    }\n}\n/**\n * A helper factory for users who want to override Helia `blockBrokers` but\n * still want to use the default `BitswapBlockBroker`.\n */\nfunction bitswap(init = {}) {\n    return (components) => new BitswapBlockBroker(components, init);\n}\n//# sourceMappingURL=bitswap.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/bitswap.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitswap: () => (/* reexport safe */ _bitswap_js__WEBPACK_IMPORTED_MODULE_0__.bitswap),\n/* harmony export */   trustlessGateway: () => (/* reexport safe */ _trustless_gateway_index_js__WEBPACK_IMPORTED_MODULE_1__.trustlessGateway)\n/* harmony export */ });\n/* harmony import */ var _bitswap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitswap.js */ \"./node_modules/@helia/block-brokers/dist/src/bitswap.js\");\n/* harmony import */ var _trustless_gateway_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trustless-gateway/index.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrustlessGatewayBlockBroker: () => (/* binding */ TrustlessGatewayBlockBroker)\n/* harmony export */ });\n/* harmony import */ var _trustless_gateway_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trustless-gateway.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js\");\n\n\n/**\n * A class that accepts a list of trustless gateways that are queried\n * for blocks.\n */\nclass TrustlessGatewayBlockBroker {\n    gateways;\n    log;\n    constructor(components, init = {}) {\n        this.log = components.logger.forComponent('helia:trustless-gateway-block-broker');\n        this.gateways = (init.gateways ?? _index_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TRUSTLESS_GATEWAYS)\n            .map((gatewayOrUrl) => {\n            return new _trustless_gateway_js__WEBPACK_IMPORTED_MODULE_0__.TrustlessGateway(gatewayOrUrl);\n        });\n    }\n    async retrieve(cid, options = {}) {\n        // Loop through the gateways until we get a block or run out of gateways\n        // TODO: switch to toSorted when support is better\n        const sortedGateways = this.gateways.sort((a, b) => b.reliability() - a.reliability());\n        const aggregateErrors = [];\n        for (const gateway of sortedGateways) {\n            this.log('getting block for %c from %s', cid, gateway.url);\n            try {\n                const block = await gateway.getRawBlock(cid, options.signal);\n                this.log.trace('got block for %c from %s', cid, gateway.url);\n                try {\n                    await options.validateFn?.(block);\n                }\n                catch (err) {\n                    this.log.error('failed to validate block for %c from %s', cid, gateway.url, err);\n                    gateway.incrementInvalidBlocks();\n                    throw new Error(`unable to validate block for CID ${cid} from gateway ${gateway.url}`);\n                }\n                return block;\n            }\n            catch (err) {\n                this.log.error('failed to get block for %c from %s', cid, gateway.url, err);\n                if (err instanceof Error) {\n                    aggregateErrors.push(err);\n                }\n                else {\n                    aggregateErrors.push(new Error(`unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));\n                }\n                // if signal was aborted, exit the loop\n                if (options.signal?.aborted === true) {\n                    this.log.trace('request aborted while fetching raw block for CID %c from gateway %s', cid, gateway.url);\n                    break;\n                }\n            }\n        }\n        throw new AggregateError(aggregateErrors, `unable to fetch raw block for CID ${cid} from any gateway`);\n    }\n}\n//# sourceMappingURL=broker.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TRUSTLESS_GATEWAYS: () => (/* binding */ DEFAULT_TRUSTLESS_GATEWAYS),\n/* harmony export */   trustlessGateway: () => (/* binding */ trustlessGateway)\n/* harmony export */ });\n/* harmony import */ var _broker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broker.js */ \"./node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js\");\n\nconst DEFAULT_TRUSTLESS_GATEWAYS = [\n    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/\n    'https://trustless-gateway.link',\n    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/\n    'https://cloudflare-ipfs.com',\n    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/\n    'https://4everland.io'\n];\nfunction trustlessGateway(init = {}) {\n    return (components) => new _broker_js__WEBPACK_IMPORTED_MODULE_0__.TrustlessGatewayBlockBroker(components, init);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js?");

/***/ }),

/***/ "./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrustlessGateway: () => (/* binding */ TrustlessGateway)\n/* harmony export */ });\n/**\n * A `TrustlessGateway` keeps track of the number of attempts, errors, and\n * successes for a given gateway url so that we can prioritize gateways that\n * have been more reliable in the past, and ensure that requests are distributed\n * across all gateways within a given `TrustlessGatewayBlockBroker` instance.\n */\nclass TrustlessGateway {\n    url;\n    /**\n     * The number of times this gateway has been attempted to be used to fetch a\n     * block. This includes successful, errored, and aborted attempts. By counting\n     * even aborted attempts, slow gateways that are out-raced by others will be\n     * considered less reliable.\n     */\n    #attempts = 0;\n    /**\n     * The number of times this gateway has errored while attempting to fetch a\n     * block. This includes `response.ok === false` and any other errors that\n     * throw while attempting to fetch a block. This does not include aborted\n     * attempts.\n     */\n    #errors = 0;\n    /**\n     * The number of times this gateway has returned an invalid block. A gateway\n     * that returns the wrong blocks for a CID should be considered for removal\n     * from the list of gateways to fetch blocks from.\n     */\n    #invalidBlocks = 0;\n    /**\n     * The number of times this gateway has successfully fetched a block.\n     */\n    #successes = 0;\n    constructor(url) {\n        this.url = url instanceof URL ? url : new URL(url);\n    }\n    /**\n     * Fetch a raw block from `this.url` following the specification defined at\n     * https://specs.ipfs.tech/http-gateways/trustless-gateway/\n     */\n    async getRawBlock(cid, signal) {\n        const gwUrl = this.url;\n        gwUrl.pathname = `/ipfs/${cid.toString()}`;\n        // necessary as not every gateway supports dag-cbor, but every should support\n        // sending raw block as-is\n        gwUrl.search = '?format=raw';\n        if (signal?.aborted === true) {\n            throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);\n        }\n        try {\n            this.#attempts++;\n            const res = await fetch(gwUrl.toString(), {\n                signal,\n                headers: {\n                    // also set header, just in case ?format= is filtered out by some\n                    // reverse proxy\n                    Accept: 'application/vnd.ipld.raw'\n                },\n                cache: 'force-cache'\n            });\n            if (!res.ok) {\n                this.#errors++;\n                throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);\n            }\n            this.#successes++;\n            return new Uint8Array(await res.arrayBuffer());\n        }\n        catch (cause) {\n            // @ts-expect-error - TS thinks signal?.aborted can only be false now\n            // because it was checked for true above.\n            if (signal?.aborted === true) {\n                throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);\n            }\n            this.#errors++;\n            throw new Error(`unable to fetch raw block for CID ${cid}`);\n        }\n    }\n    /**\n     * Encapsulate the logic for determining whether a gateway is considered\n     * reliable, for prioritization. This is based on the number of successful attempts made\n     * and the number of errors encountered.\n     *\n     * Unused gateways have 100% reliability; They will be prioritized over\n     * gateways with a 100% success rate to ensure that we attempt all gateways.\n     */\n    reliability() {\n        /**\n         * if we have never tried to use this gateway, it is considered the most\n         * reliable until we determine otherwise (prioritize unused gateways)\n         */\n        if (this.#attempts === 0) {\n            return 1;\n        }\n        if (this.#invalidBlocks > 0) {\n            // this gateway may not be trustworthy..\n            return -Infinity;\n        }\n        /**\n         * We have attempted the gateway, so we need to calculate the reliability\n         * based on the number of attempts, errors, and successes. Gateways that\n         * return a single error should drop their reliability score more than a\n         * single success increases it.\n         *\n         * Play around with the below reliability function at https://www.desmos.com/calculator/d6hfhf5ukm\n         */\n        return this.#successes / (this.#attempts + (this.#errors * 3));\n    }\n    /**\n     * Increment the number of invalid blocks returned by this gateway.\n     */\n    incrementInvalidBlocks() {\n        this.#invalidBlocks++;\n    }\n}\n//# sourceMappingURL=trustless-gateway.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js?");

/***/ }),

/***/ "./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultDelegatedRoutingV1HttpApiClient: () => (/* binding */ DefaultDelegatedRoutingV1HttpApiClient)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/events.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/content-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/peer-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @libp2p/peer-id */ \"./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ \"./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! any-signal */ \"./node_modules/any-signal/dist/src/index.js\");\n/* harmony import */ var browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! browser-readablestream-to-it */ \"./node_modules/browser-readablestream-to-it/dist/src/index.js\");\n/* harmony import */ var ipns__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ipns */ \"./node_modules/ipns/dist/src/utils.js\");\n/* harmony import */ var ipns_validator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ipns/validator */ \"./node_modules/ipns/dist/src/validator.js\");\n/* harmony import */ var it_ndjson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-ndjson */ \"./node_modules/it-ndjson/dist/src/index.js\");\n/* harmony import */ var p_defer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! p-defer */ \"./node_modules/p-defer/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _routings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./routings.js */ \"./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_4__.logger)('delegated-routing-v1-http-api-client');\nconst defaultValues = {\n    concurrentRequests: 4,\n    timeout: 30e3\n};\nclass DefaultDelegatedRoutingV1HttpApiClient {\n    started;\n    httpQueue;\n    shutDownController;\n    clientUrl;\n    timeout;\n    contentRouting;\n    peerRouting;\n    /**\n     * Create a new DelegatedContentRouting instance\n     */\n    constructor(url, init = {}) {\n        this.started = false;\n        this.shutDownController = new AbortController();\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_5__.setMaxListeners)(Infinity, this.shutDownController.signal);\n        this.httpQueue = new p_queue__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({\n            concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests\n        });\n        this.clientUrl = url instanceof URL ? url : new URL(url);\n        this.timeout = init.timeout ?? defaultValues.timeout;\n        this.contentRouting = new _routings_js__WEBPACK_IMPORTED_MODULE_7__.DelegatedRoutingV1HttpApiClientContentRouting(this);\n        this.peerRouting = new _routings_js__WEBPACK_IMPORTED_MODULE_7__.DelegatedRoutingV1HttpApiClientPeerRouting(this);\n    }\n    get [_libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.contentRoutingSymbol]() {\n        return this.contentRouting;\n    }\n    get [_libp2p_interface__WEBPACK_IMPORTED_MODULE_9__.peerRoutingSymbol]() {\n        return this.peerRouting;\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    stop() {\n        this.httpQueue.clear();\n        this.shutDownController.abort();\n        this.started = false;\n    }\n    async *getProviders(cid, options = {}) {\n        log('getProviders starts: %c', cid);\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_1__.anySignal)([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);\n        const onStart = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        const onFinish = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        void this.httpQueue.add(async () => {\n            onStart.resolve();\n            return onFinish.promise;\n        });\n        try {\n            await onStart.promise;\n            // https://specs.ipfs.tech/routing/http-routing-v1/\n            const resource = `${this.clientUrl}routing/v1/providers/${cid.toString()}`;\n            const getOptions = { headers: { Accept: 'application/x-ndjson' }, signal };\n            const res = await fetch(resource, getOptions);\n            if (res.status === 404) {\n                // https://specs.ipfs.tech/routing/http-routing-v1/#response-status-codes\n                // 404 (Not Found): must be returned if no matching records are found.\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('No matching records found.', 'ERR_NOT_FOUND');\n            }\n            if (res.status === 422) {\n                // https://specs.ipfs.tech/routing/http-routing-v1/#response-status-codes\n                // 422 (Unprocessable Entity): request does not conform to schema or semantic constraints.\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('Request does not conform to schema or semantic constraints.', 'ERR_INVALID_REQUEST');\n            }\n            if (res.body == null) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('Routing response had no body', 'ERR_BAD_RESPONSE');\n            }\n            const contentType = res.headers.get('Content-Type');\n            if (contentType === 'application/json') {\n                const body = await res.json();\n                for (const provider of body.Providers) {\n                    const record = this.#conformToPeerSchema(provider);\n                    if (record != null) {\n                        yield record;\n                    }\n                }\n            }\n            else {\n                for await (const provider of (0,it_ndjson__WEBPACK_IMPORTED_MODULE_3__.parse)((0,browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(res.body))) {\n                    const record = this.#conformToPeerSchema(provider);\n                    if (record != null) {\n                        yield record;\n                    }\n                }\n            }\n        }\n        catch (err) {\n            log.error('getProviders errored:', err);\n        }\n        finally {\n            signal.clear();\n            onFinish.resolve();\n            log('getProviders finished: %c', cid);\n        }\n    }\n    async *getPeers(peerId, options = {}) {\n        log('getPeers starts: %c', peerId);\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_1__.anySignal)([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);\n        const onStart = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        const onFinish = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        void this.httpQueue.add(async () => {\n            onStart.resolve();\n            return onFinish.promise;\n        });\n        try {\n            await onStart.promise;\n            // https://specs.ipfs.tech/routing/http-routing-v1/\n            const resource = `${this.clientUrl}routing/v1/peers/${peerId.toCID().toString()}`;\n            const getOptions = { headers: { Accept: 'application/x-ndjson' }, signal };\n            const res = await fetch(resource, getOptions);\n            if (res.status === 404) {\n                // https://specs.ipfs.tech/routing/http-routing-v1/#response-status-codes\n                // 404 (Not Found): must be returned if no matching records are found.\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('No matching records found.', 'ERR_NOT_FOUND');\n            }\n            if (res.status === 422) {\n                // https://specs.ipfs.tech/routing/http-routing-v1/#response-status-codes\n                // 422 (Unprocessable Entity): request does not conform to schema or semantic constraints.\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('Request does not conform to schema or semantic constraints.', 'ERR_INVALID_REQUEST');\n            }\n            if (res.body == null) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('Routing response had no body', 'ERR_BAD_RESPONSE');\n            }\n            const contentType = res.headers.get('Content-Type');\n            if (contentType === 'application/json') {\n                const body = await res.json();\n                for (const peer of body.Peers) {\n                    const record = this.#conformToPeerSchema(peer);\n                    if (record != null) {\n                        yield record;\n                    }\n                }\n            }\n            else {\n                for await (const peer of (0,it_ndjson__WEBPACK_IMPORTED_MODULE_3__.parse)((0,browser_readablestream_to_it__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(res.body))) {\n                    const record = this.#conformToPeerSchema(peer);\n                    if (record != null) {\n                        yield record;\n                    }\n                }\n            }\n        }\n        catch (err) {\n            log.error('getPeers errored:', err);\n        }\n        finally {\n            signal.clear();\n            onFinish.resolve();\n            log('getPeers finished: %c', peerId);\n        }\n    }\n    async getIPNS(peerId, options = {}) {\n        log('getIPNS starts: %c', peerId);\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_1__.anySignal)([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);\n        const onStart = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        const onFinish = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        void this.httpQueue.add(async () => {\n            onStart.resolve();\n            return onFinish.promise;\n        });\n        // https://specs.ipfs.tech/routing/http-routing-v1/\n        const resource = `${this.clientUrl}routing/v1/ipns/${peerId.toCID().toString()}`;\n        try {\n            await onStart.promise;\n            const getOptions = { headers: { Accept: 'application/vnd.ipfs.ipns-record' }, signal };\n            const res = await fetch(resource, getOptions);\n            log('getIPNS GET %s %d', resource, res.status);\n            if (res.status === 404) {\n                // https://specs.ipfs.tech/routing/http-routing-v1/#response-status-codes\n                // 404 (Not Found): must be returned if no matching records are found.\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('No matching records found.', 'ERR_NOT_FOUND');\n            }\n            if (res.status === 422) {\n                // https://specs.ipfs.tech/routing/http-routing-v1/#response-status-codes\n                // 422 (Unprocessable Entity): request does not conform to schema or semantic constraints.\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('Request does not conform to schema or semantic constraints.', 'ERR_INVALID_REQUEST');\n            }\n            if (res.body == null) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('GET ipns response had no body', 'ERR_BAD_RESPONSE');\n            }\n            const buf = await res.arrayBuffer();\n            const body = new Uint8Array(buf, 0, buf.byteLength);\n            if (options.validate !== false) {\n                await (0,ipns_validator__WEBPACK_IMPORTED_MODULE_12__.ipnsValidator)((0,ipns__WEBPACK_IMPORTED_MODULE_13__.peerIdToRoutingKey)(peerId), body);\n            }\n            return (0,ipns__WEBPACK_IMPORTED_MODULE_13__.unmarshal)(body);\n        }\n        catch (err) {\n            log.error('getIPNS GET %s error:', resource, err);\n            throw err;\n        }\n        finally {\n            signal.clear();\n            onFinish.resolve();\n            log('getIPNS finished: %c', peerId);\n        }\n    }\n    async putIPNS(peerId, record, options = {}) {\n        log('putIPNS starts: %c', peerId);\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_1__.anySignal)([this.shutDownController.signal, options.signal, AbortSignal.timeout(this.timeout)]);\n        const onStart = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        const onFinish = (0,p_defer__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n        void this.httpQueue.add(async () => {\n            onStart.resolve();\n            return onFinish.promise;\n        });\n        // https://specs.ipfs.tech/routing/http-routing-v1/\n        const resource = `${this.clientUrl}routing/v1/ipns/${peerId.toCID().toString()}`;\n        try {\n            await onStart.promise;\n            const body = (0,ipns__WEBPACK_IMPORTED_MODULE_13__.marshal)(record);\n            const getOptions = { method: 'PUT', headers: { 'Content-Type': 'application/vnd.ipfs.ipns-record' }, body, signal };\n            const res = await fetch(resource, getOptions);\n            log('putIPNS PUT %s %d', resource, res.status);\n            if (res.status !== 200) {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.CodeError('PUT ipns response had status other than 200', 'ERR_BAD_RESPONSE');\n            }\n        }\n        catch (err) {\n            log.error('putIPNS PUT %s error:', resource, err.stack);\n            throw err;\n        }\n        finally {\n            signal.clear();\n            onFinish.resolve();\n            log('putIPNS finished: %c', peerId);\n        }\n    }\n    #conformToPeerSchema(record) {\n        const protocols = [];\n        const multiaddrs = record.Addrs?.map(_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr) ?? [];\n        if (record.Protocols != null) {\n            protocols.push(...record.Protocols);\n        }\n        if (record.Protocol != null) {\n            protocols.push(record.Protocol);\n            delete record.Protocol;\n        }\n        return {\n            ...record,\n            Schema: 'peer',\n            ID: (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_14__.peerIdFromString)(record.ID),\n            Addrs: multiaddrs,\n            Protocols: protocols\n        };\n    }\n}\n//# sourceMappingURL=client.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js?");

/***/ }),

/***/ "./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDelegatedRoutingV1HttpApiClient: () => (/* binding */ createDelegatedRoutingV1HttpApiClient)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js\");\n/**\n * @packageDocumentation\n *\n * A client implementation of the IPFS [Delegated Routing V1 HTTP API](https://specs.ipfs.tech/routing/http-routing-v1/) that can be used to interact with any compliant server implementation.\n *\n * @example\n *\n * ```typescript\n * import { createDelegatedRoutingV1HttpApiClient } from '@helia/delegated-routing-v1-http-api-client'\n * import { CID } from 'multiformats/cid'\n *\n * const client = createDelegatedRoutingV1HttpApiClient('https://example.org')\n *\n * for await (const prov of getProviders(CID.parse('QmFoo'))) {\n *   // ...\n * }\n * ```\n *\n * ### How to use with libp2p\n *\n * The client can be configured as a libp2p service, this will enable it as both a {@link https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.content_routing.ContentRouting.html | ContentRouting} and a {@link https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.peer_routing.PeerRouting.html | PeerRouting} implementation\n *\n * @example\n *\n * ```typescript\n * import { createDelegatedRoutingV1HttpApiClient } from '@helia/delegated-routing-v1-http-api-client'\n * import { createLibp2p } from 'libp2p'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const client = createDelegatedRoutingV1HttpApiClient('https://example.org')\n * const libp2p = await createLibp2p({\n *   // other config here\n *   services: {\n *     delegatedRouting: client\n *   }\n * })\n *\n * // later this will use the configured HTTP gateway\n * await libp2p.peerRouting.findPeer(peerIdFromString('QmFoo'))\n * ```\n */\n\n/**\n * Create and return a client to use with a Routing V1 HTTP API server\n */\nfunction createDelegatedRoutingV1HttpApiClient(url, init = {}) {\n    return new _client_js__WEBPACK_IMPORTED_MODULE_0__.DefaultDelegatedRoutingV1HttpApiClient(new URL(url), init);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DelegatedRoutingV1HttpApiClientContentRouting: () => (/* binding */ DelegatedRoutingV1HttpApiClientContentRouting),\n/* harmony export */   DelegatedRoutingV1HttpApiClientPeerRouting: () => (/* binding */ DelegatedRoutingV1HttpApiClientPeerRouting)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/peer-id */ \"./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var ipns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ipns */ \"./node_modules/ipns/dist/src/utils.js\");\n/* harmony import */ var it_first__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-first */ \"./node_modules/it-first/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n\n\n\n\n\n\n\n\nconst IPNS_PREFIX = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)('/ipns/');\nfunction isIPNSKey(key) {\n    return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__.equals)(key.subarray(0, IPNS_PREFIX.byteLength), IPNS_PREFIX);\n}\nconst peerIdFromRoutingKey = (key) => {\n    return (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_4__.peerIdFromBytes)(key.slice(IPNS_PREFIX.length));\n};\n/**\n * Wrapper class to convert [http-routing-v1 content events](https://specs.ipfs.tech/routing/http-routing-v1/#response-body) into returned values\n */\nclass DelegatedRoutingV1HttpApiClientContentRouting {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async *findProviders(cid, options = {}) {\n        yield* (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.client.getProviders(cid, options), (record) => {\n            return {\n                id: record.ID,\n                multiaddrs: record.Addrs ?? []\n            };\n        });\n    }\n    async provide() {\n        // noop\n    }\n    async put(key, value, options) {\n        if (!isIPNSKey(key)) {\n            return;\n        }\n        const peerId = peerIdFromRoutingKey(key);\n        const record = (0,ipns__WEBPACK_IMPORTED_MODULE_5__.unmarshal)(value);\n        await this.client.putIPNS(peerId, record, options);\n    }\n    async get(key, options) {\n        if (!isIPNSKey(key)) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Not found', 'ERR_NOT_FOUND');\n        }\n        const peerId = peerIdFromRoutingKey(key);\n        try {\n            const record = await this.client.getIPNS(peerId, options);\n            return (0,ipns__WEBPACK_IMPORTED_MODULE_5__.marshal)(record);\n        }\n        catch (err) {\n            // ERR_BAD_RESPONSE is thrown when the response had no body, which means\n            // the record couldn't be found\n            if (err.code === 'ERR_BAD_RESPONSE') {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Not found', 'ERR_NOT_FOUND');\n            }\n            throw err;\n        }\n    }\n}\n/**\n * Wrapper class to convert [http-routing-v1](https://specs.ipfs.tech/routing/http-routing-v1/#response-body-0) events into expected libp2p values\n */\nclass DelegatedRoutingV1HttpApiClientPeerRouting {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async findPeer(peerId, options = {}) {\n        const peer = await (0,it_first__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.client.getPeers(peerId, options));\n        if (peer != null) {\n            return {\n                id: peer.ID,\n                multiaddrs: peer.Addrs ?? []\n            };\n        }\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n    async *getClosestPeers(key, options = {}) {\n        // noop\n    }\n}\n//# sourceMappingURL=routings.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js?");

/***/ }),

/***/ "./node_modules/@helia/http/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@helia/http/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHeliaHTTP: () => (/* binding */ createHeliaHTTP)\n/* harmony export */ });\n/* harmony import */ var _helia_block_brokers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @helia/block-brokers */ \"./node_modules/@helia/block-brokers/dist/src/index.js\");\n/* harmony import */ var _helia_routers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @helia/routers */ \"./node_modules/@helia/routers/dist/src/delegated-http-routing.js\");\n/* harmony import */ var _helia_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @helia/utils */ \"./node_modules/@helia/utils/dist/src/index.js\");\n/* harmony import */ var blockstore_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blockstore-core */ \"./node_modules/blockstore-core/dist/src/index.js\");\n/* harmony import */ var datastore_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! datastore-core */ \"./node_modules/datastore-core/dist/src/index.js\");\n/* harmony import */ var _helia_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @helia/interface */ \"./node_modules/@helia/interface/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Exports a `createHeliaHTTP` function that returns an object that implements a lightweight version of the {@link Helia} API that functions only over HTTP.\n *\n * By default, content and peer routing are requests are resolved using the [Delegated HTTP Routing API](https://specs.ipfs.tech/routing/http-routing-v1/) and blocks are fetched from [Trustless Gateways](https://specs.ipfs.tech/http-gateways/trustless-gateway/).\n *\n * Pass it to other modules like {@link https://www.npmjs.com/package/@helia/unixfs | @helia/unixfs} to fetch files from the distributed web.\n *\n * @example\n *\n * ```typescript\n * import { createHeliaHTTP } from '@helia/http'\n * import { unixfs } from '@helia/unixfs'\n * import { CID } from 'multiformats/cid'\n *\n * const helia = await createHeliaHTTP()\n *\n * const fs = unixfs(helia)\n * fs.cat(CID.parse('bafyFoo'))\n * ```\n * @example with custom gateways and delegated routing endpoints\n * ```typescript\n * import { createHeliaHTTP } from '@helia/http'\n * import { trustlessGateway } from '@helia/block-brokers'\n * import { delegatedHTTPRouting } from '@helia/routers'\n * import { unixfs } from '@helia/unixfs'\n * import { CID } from 'multiformats/cid'\n *\n * const helia = await createHeliaHTTP({\n *   blockBrokers: [\n *     trustlessGateway({\n *       gateways: ['https://cloudflare-ipfs.com', 'https://ipfs.io'],\n *     }),\n *   ],\n *   routers: [\n *     delegatedHTTPRouting('https://delegated-ipfs.dev')\n *   ]\n * })\n *\n * const fs = unixfs(helia)\n * fs.cat(CID.parse('bafyFoo'))\n * ```\n */\n\n\n\n\n\n// re-export interface types so people don't have to depend on @helia/interface\n// if they don't want to\n\n/**\n/**\n * Create and return a Helia node\n */\nasync function createHeliaHTTP(init = {}) {\n    const datastore = init.datastore ?? new datastore_core__WEBPACK_IMPORTED_MODULE_3__.MemoryDatastore();\n    const blockstore = init.blockstore ?? new blockstore_core__WEBPACK_IMPORTED_MODULE_2__.MemoryBlockstore();\n    const helia = new _helia_utils__WEBPACK_IMPORTED_MODULE_1__.Helia({\n        ...init,\n        datastore,\n        blockstore,\n        blockBrokers: init.blockBrokers ?? [\n            (0,_helia_block_brokers__WEBPACK_IMPORTED_MODULE_0__.trustlessGateway)()\n        ],\n        routers: init.routers ?? [\n            (0,_helia_routers__WEBPACK_IMPORTED_MODULE_5__.delegatedHTTPRouting)('https://delegated-ipfs.dev')\n        ]\n    });\n    if (init.start !== false) {\n        await helia.start();\n    }\n    return helia;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/http/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/blocks.js":
/*!**********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/blocks.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=blocks.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/blocks.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks.js */ \"./node_modules/@helia/interface/dist/src/blocks.js\");\n/* harmony import */ var _pins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pins.js */ \"./node_modules/@helia/interface/dist/src/pins.js\");\n/* harmony import */ var _routing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./routing.js */ \"./node_modules/@helia/interface/dist/src/routing.js\");\n/**\n * @packageDocumentation\n *\n * The API defined by a {@link Helia} node\n *\n * @example\n *\n * ```typescript\n * import type { Helia } from '@helia/interface'\n *\n * export function doSomething(helia: Helia) {\n *   // use helia node functions here\n * }\n * ```\n */\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/pins.js":
/*!********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/pins.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=pins.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/pins.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/routing.js":
/*!***********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/routing.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=routing.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/routing.js?");

/***/ }),

/***/ "./node_modules/@helia/routers/dist/src/delegated-http-routing.js":
/*!************************************************************************!*\
  !*** ./node_modules/@helia/routers/dist/src/delegated-http-routing.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   delegatedHTTPRouting: () => (/* binding */ delegatedHTTPRouting)\n/* harmony export */ });\n/* harmony import */ var _helia_delegated_routing_v1_http_api_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @helia/delegated-routing-v1-http-api-client */ \"./node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var ipns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ipns */ \"./node_modules/ipns/dist/src/utils.js\");\n/* harmony import */ var it_first__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-first */ \"./node_modules/it-first/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n\n\n\n\n\n\n\nconst IPNS_PREFIX = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_3__.fromString)('/ipns/');\nfunction isIPNSKey(key) {\n    return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__.equals)(key.subarray(0, IPNS_PREFIX.byteLength), IPNS_PREFIX);\n}\nclass DelegatedHTTPRouter {\n    client;\n    constructor(url) {\n        this.client = (0,_helia_delegated_routing_v1_http_api_client__WEBPACK_IMPORTED_MODULE_4__.createDelegatedRoutingV1HttpApiClient)(url);\n    }\n    async provide(cid, options) {\n        // noop\n    }\n    async *findProviders(cid, options) {\n        yield* (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.client.getProviders(cid, options), (record) => {\n            return {\n                id: record.ID,\n                multiaddrs: record.Addrs,\n                protocols: record.Protocols\n            };\n        });\n    }\n    async put(key, value, options) {\n        if (!isIPNSKey(key)) {\n            return;\n        }\n        const peerId = (0,ipns__WEBPACK_IMPORTED_MODULE_5__.peerIdFromRoutingKey)(key);\n        const record = (0,ipns__WEBPACK_IMPORTED_MODULE_5__.unmarshal)(value);\n        await this.client.putIPNS(peerId, record, options);\n    }\n    async get(key, options) {\n        if (!isIPNSKey(key)) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Not found', 'ERR_NOT_FOUND');\n        }\n        const peerId = (0,ipns__WEBPACK_IMPORTED_MODULE_5__.peerIdFromRoutingKey)(key);\n        try {\n            const record = await this.client.getIPNS(peerId, options);\n            return (0,ipns__WEBPACK_IMPORTED_MODULE_5__.marshal)(record);\n        }\n        catch (err) {\n            // ERR_BAD_RESPONSE is thrown when the response had no body, which means\n            // the record couldn't be found\n            if (err.code === 'ERR_BAD_RESPONSE') {\n                throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Not found', 'ERR_NOT_FOUND');\n            }\n            throw err;\n        }\n    }\n    async findPeer(peerId, options) {\n        const peer = await (0,it_first__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.client.getPeers(peerId, options));\n        if (peer != null) {\n            return {\n                id: peer.ID,\n                multiaddrs: peer.Addrs ?? []\n            };\n        }\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n    async *getClosestPeers(key, options) {\n        // noop\n    }\n}\n/**\n * Creates a Helia Router that connects to an endpoint that supports the [Delegated Routing V1 HTTP API](https://specs.ipfs.tech/routing/http-routing-v1/) spec.\n */\nfunction delegatedHTTPRouting(url) {\n    return new DelegatedHTTPRouter(new URL(url));\n}\n//# sourceMappingURL=delegated-http-routing.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/routers/dist/src/delegated-http-routing.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Helia: () => (/* binding */ Helia)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/content-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/peer-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var _multiformats_dns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/dns */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _pins_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pins.js */ \"./node_modules/@helia/utils/dist/src/pins.js\");\n/* harmony import */ var _routing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./routing.js */ \"./node_modules/@helia/utils/dist/src/routing.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage.js */ \"./node_modules/@helia/utils/dist/src/storage.js\");\n/* harmony import */ var _utils_dag_walkers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/dag-walkers.js */ \"./node_modules/@helia/utils/dist/src/utils/dag-walkers.js\");\n/* harmony import */ var _utils_datastore_version_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/datastore-version.js */ \"./node_modules/@helia/utils/dist/src/utils/datastore-version.js\");\n/* harmony import */ var _utils_default_hashers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/default-hashers.js */ \"./node_modules/@helia/utils/dist/src/utils/default-hashers.js\");\n/* harmony import */ var _utils_networked_storage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/networked-storage.js */ \"./node_modules/@helia/utils/dist/src/utils/networked-storage.js\");\n/**\n * @packageDocumentation\n *\n * Exports a `Helia` class that implements the {@link HeliaInterface} API.\n *\n * In general you should use the `helia` or `@helia/http` modules instead which\n * pre-configure Helia for certain use-cases (p2p or pure-HTTP).\n *\n * @example\n *\n * ```typescript\n * import { Helia } from '@helia/utils'\n *\n * const node = new Helia({\n *   // ...options\n * })\n * ```\n */\n\n\n\n\n\n\n\n\n\n\n\n\nclass Helia {\n    blockstore;\n    datastore;\n    pins;\n    logger;\n    routing;\n    dagWalkers;\n    hashers;\n    dns;\n    log;\n    constructor(init) {\n        this.logger = init.logger ?? (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_10__.defaultLogger)();\n        this.log = this.logger.forComponent('helia');\n        this.hashers = (0,_utils_default_hashers_js__WEBPACK_IMPORTED_MODULE_8__.defaultHashers)(init.hashers);\n        this.dagWalkers = (0,_utils_dag_walkers_js__WEBPACK_IMPORTED_MODULE_6__.defaultDagWalkers)(init.dagWalkers);\n        this.dns = init.dns ?? (0,_multiformats_dns__WEBPACK_IMPORTED_MODULE_0__.dns)();\n        const components = {\n            blockstore: init.blockstore,\n            datastore: init.datastore,\n            hashers: this.hashers,\n            dagWalkers: this.dagWalkers,\n            logger: this.logger,\n            blockBrokers: [],\n            dns: this.dns,\n            ...(init.components ?? {})\n        };\n        components.blockBrokers = init.blockBrokers.map((fn) => {\n            return fn(components);\n        });\n        const networkedStorage = new _utils_networked_storage_js__WEBPACK_IMPORTED_MODULE_9__.NetworkedStorage(components);\n        this.pins = new _pins_js__WEBPACK_IMPORTED_MODULE_3__.PinsImpl(init.datastore, networkedStorage, this.dagWalkers);\n        this.blockstore = new _storage_js__WEBPACK_IMPORTED_MODULE_5__.BlockStorage(networkedStorage, this.pins, {\n            holdGcLock: init.holdGcLock ?? true\n        });\n        this.datastore = init.datastore;\n        this.routing = new _routing_js__WEBPACK_IMPORTED_MODULE_4__.Routing(components, {\n            routers: (init.routers ?? []).flatMap((router) => {\n                // if the router itself is a router\n                const routers = [\n                    router\n                ];\n                // if the router provides a libp2p-style ContentRouter\n                if (router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.contentRoutingSymbol] != null) {\n                    routers.push(router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.contentRoutingSymbol]);\n                }\n                // if the router provides a libp2p-style PeerRouter\n                if (router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.peerRoutingSymbol] != null) {\n                    routers.push(router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.peerRoutingSymbol]);\n                }\n                return routers;\n            })\n        });\n    }\n    async start() {\n        await (0,_utils_datastore_version_js__WEBPACK_IMPORTED_MODULE_7__.assertDatastoreVersionIsCurrent)(this.datastore);\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_13__.start)(this.blockstore, this.datastore, this.routing);\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_13__.stop)(this.blockstore, this.datastore, this.routing);\n    }\n    async gc(options = {}) {\n        const releaseLock = await this.blockstore.lock.writeLock();\n        try {\n            const helia = this;\n            const blockstore = this.blockstore.unwrap();\n            this.log('gc start');\n            await (0,it_drain__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(blockstore.deleteMany((async function* () {\n                for await (const { cid } of blockstore.getAll()) {\n                    try {\n                        if (await helia.pins.isPinned(cid, options)) {\n                            continue;\n                        }\n                        yield cid;\n                        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_2__.CustomProgressEvent('helia:gc:deleted', cid));\n                    }\n                    catch (err) {\n                        helia.log.error('Error during gc', err);\n                        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_2__.CustomProgressEvent('helia:gc:error', err));\n                    }\n                }\n            }())));\n        }\n        finally {\n            releaseLock();\n        }\n        this.log('gc finished');\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/pins.js":
/*!****************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/pins.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PinsImpl: () => (/* binding */ PinsImpl)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/utils/queue */ \"./node_modules/@libp2p/utils/dist/src/queue/index.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base36 */ \"./node_modules/multiformats/dist/src/bases/base36.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n\n\n\n\n\n\n\nconst DATASTORE_PIN_PREFIX = '/pin/';\nconst DATASTORE_BLOCK_PREFIX = '/pinned-block/';\nconst DATASTORE_ENCODING = multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36;\nconst DAG_WALK_QUEUE_CONCURRENCY = 1;\nfunction toDSKey(cid) {\n    if (cid.version === 0) {\n        cid = cid.toV1();\n    }\n    return new interface_datastore__WEBPACK_IMPORTED_MODULE_1__.Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);\n}\nclass PinsImpl {\n    datastore;\n    blockstore;\n    dagWalkers;\n    constructor(datastore, blockstore, dagWalkers) {\n        this.datastore = datastore;\n        this.blockstore = blockstore;\n        this.dagWalkers = dagWalkers;\n    }\n    async *add(cid, options = {}) {\n        const pinKey = toDSKey(cid);\n        if (await this.datastore.has(pinKey)) {\n            throw new Error('Already pinned');\n        }\n        const depth = Math.round(options.depth ?? Infinity);\n        if (depth < 0) {\n            throw new Error('Depth must be greater than or equal to 0');\n        }\n        // use a queue to walk the DAG instead of recursion so we can traverse very large DAGs\n        const queue = new _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_6__.Queue({\n            concurrency: DAG_WALK_QUEUE_CONCURRENCY\n        });\n        for await (const childCid of this.#walkDag(cid, queue, {\n            ...options,\n            depth\n        })) {\n            await this.#updatePinnedBlock(childCid, (pinnedBlock) => {\n                // do not update pinned block if this block is already pinned by this CID\n                if (pinnedBlock.pinnedBy.find(c => (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(c, cid.bytes)) != null) {\n                    return false;\n                }\n                pinnedBlock.pinCount++;\n                pinnedBlock.pinnedBy.push(cid.bytes);\n                return true;\n            }, options);\n            yield childCid;\n        }\n        const pin = {\n            depth,\n            metadata: options.metadata ?? {}\n        };\n        await this.datastore.put(pinKey, cborg__WEBPACK_IMPORTED_MODULE_0__.encode(pin), options);\n    }\n    /**\n     * Walk a DAG in an iterable fashion\n     */\n    async *#walkDag(cid, queue, options) {\n        if (options.depth === -1) {\n            return;\n        }\n        const dagWalker = this.dagWalkers[cid.code];\n        if (dagWalker == null) {\n            throw new Error(`No dag walker found for cid codec ${cid.code}`);\n        }\n        const block = await this.blockstore.get(cid, options);\n        yield cid;\n        // walk dag, ensure all blocks are present\n        for await (const cid of dagWalker.walk(block)) {\n            yield* await queue.add(async () => {\n                return this.#walkDag(cid, queue, {\n                    ...options,\n                    depth: options.depth - 1\n                });\n            });\n        }\n    }\n    /**\n     * Update the pin count for the CID\n     */\n    async #updatePinnedBlock(cid, withPinnedBlock, options) {\n        const blockKey = new interface_datastore__WEBPACK_IMPORTED_MODULE_1__.Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);\n        let pinnedBlock = {\n            pinCount: 0,\n            pinnedBy: []\n        };\n        try {\n            pinnedBlock = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(await this.datastore.get(blockKey, options));\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        const shouldContinue = withPinnedBlock(pinnedBlock);\n        if (!shouldContinue) {\n            return;\n        }\n        if (pinnedBlock.pinCount === 0) {\n            if (await this.datastore.has(blockKey)) {\n                await this.datastore.delete(blockKey);\n                return;\n            }\n        }\n        await this.datastore.put(blockKey, cborg__WEBPACK_IMPORTED_MODULE_0__.encode(pinnedBlock), options);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_4__.CustomProgressEvent('helia:pin:add', cid));\n    }\n    async *rm(cid, options = {}) {\n        const pinKey = toDSKey(cid);\n        const buf = await this.datastore.get(pinKey, options);\n        const pin = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(buf);\n        await this.datastore.delete(pinKey, options);\n        // use a queue to walk the DAG instead of recursion so we can traverse very large DAGs\n        const queue = new _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_6__.Queue({\n            concurrency: DAG_WALK_QUEUE_CONCURRENCY\n        });\n        for await (const childCid of this.#walkDag(cid, queue, {\n            ...options,\n            depth: pin.depth\n        })) {\n            await this.#updatePinnedBlock(childCid, (pinnedBlock) => {\n                pinnedBlock.pinCount--;\n                pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter(c => (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(c, cid.bytes));\n                return true;\n            }, {\n                ...options,\n                depth: pin.depth\n            });\n            yield childCid;\n        }\n    }\n    async *ls(options = {}) {\n        for await (const { key, value } of this.datastore.query({\n            prefix: DATASTORE_PIN_PREFIX + (options.cid != null ? `${options.cid.toString(multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36)}` : '')\n        }, options)) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.parse(key.toString().substring(5), multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36);\n            const pin = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(value);\n            yield {\n                cid,\n                ...pin\n            };\n        }\n    }\n    async isPinned(cid, options = {}) {\n        const blockKey = new interface_datastore__WEBPACK_IMPORTED_MODULE_1__.Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);\n        return this.datastore.has(blockKey, options);\n    }\n}\n//# sourceMappingURL=pins.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/pins.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/routing.js":
/*!*******************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/routing.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Routing: () => (/* binding */ Routing)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-collections */ \"./node_modules/@libp2p/peer-collections/dist/src/set.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n\n\n\nclass Routing {\n    log;\n    routers;\n    constructor(components, init) {\n        this.log = components.logger.forComponent('helia:routing');\n        this.routers = init.routers ?? [];\n    }\n    async start() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.start)(...this.routers);\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.stop)(...this.routers);\n    }\n    /**\n     * Iterates over all content routers in parallel to find providers of the given key\n     */\n    async *findProviders(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No content routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        const seen = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__.PeerSet();\n        for await (const peer of (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...supports(this.routers, 'findProviders')\n            .map(router => router.findProviders(key, options)))) {\n            // the peer was yielded by a content router without multiaddrs and we\n            // failed to load them\n            if (peer == null) {\n                continue;\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key\n     */\n    async provide(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No content routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        await Promise.all(supports(this.routers, 'provide')\n            .map(async (router) => {\n            await router.provide(key, options);\n        }));\n    }\n    /**\n     * Store the given key/value pair in the available content routings\n     */\n    async put(key, value, options) {\n        await Promise.all(supports(this.routers, 'put')\n            .map(async (router) => {\n            await router.put(key, value, options);\n        }));\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     */\n    async get(key, options) {\n        return Promise.any(supports(this.routers, 'get')\n            .map(async (router) => {\n            return router.get(key, options);\n        }));\n    }\n    /**\n     * Iterates over all peer routers in parallel to find the given peer\n     */\n    async findPeer(id, options) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No peer routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        const self = this;\n        const source = (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...supports(this.routers, 'findPeer')\n            .map(router => (async function* () {\n            try {\n                yield await router.findPeer(id, options);\n            }\n            catch (err) {\n                self.log.error(err);\n            }\n        })()));\n        for await (const peer of source) {\n            if (peer == null) {\n                continue;\n            }\n            return peer;\n        }\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('Could not find peer in routing', 'ERR_NOT_FOUND');\n    }\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     */\n    async *getClosestPeers(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No peer routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        const seen = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__.PeerSet();\n        for await (const peer of (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...supports(this.routers, 'getClosestPeers')\n            .map(router => router.getClosestPeers(key, options)))) {\n            if (peer == null) {\n                continue;\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n}\nfunction supports(routers, key) {\n    return routers.filter(router => router[key] != null);\n}\n//# sourceMappingURL=routing.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/routing.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/storage.js":
/*!*******************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/storage.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockStorage: () => (/* binding */ BlockStorage)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var mortice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mortice */ \"./node_modules/mortice/dist/src/index.js\");\n\n\n/**\n * BlockStorage is a hybrid blockstore that puts/gets blocks from a configured\n * blockstore (that may be on disk, s3, or something else). If the blocks are\n * not present Bitswap will be used to fetch them from network peers.\n */\nclass BlockStorage {\n    lock;\n    child;\n    pins;\n    started;\n    /**\n     * Create a new BlockStorage\n     */\n    constructor(blockstore, pins, options = {}) {\n        this.child = blockstore;\n        this.pins = pins;\n        this.lock = (0,mortice__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            singleProcess: options.holdGcLock\n        });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.start)(this.child);\n        this.started = true;\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.stop)(this.child);\n        this.started = false;\n    }\n    unwrap() {\n        return this.child;\n    }\n    /**\n     * Put a block to the underlying datastore\n     */\n    async put(cid, block, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            return await this.child.put(cid, block, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore\n     */\n    async *putMany(blocks, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            yield* this.child.putMany(blocks, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Get a block by cid\n     */\n    async get(cid, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            return await this.child.get(cid, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Get multiple blocks back from an (async) iterable of cids\n     */\n    async *getMany(cids, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            yield* this.child.getMany(cids, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Delete a block from the blockstore\n     */\n    async delete(cid, options = {}) {\n        const releaseLock = await this.lock.writeLock();\n        try {\n            if (await this.pins.isPinned(cid)) {\n                throw new Error('CID was pinned');\n            }\n            await this.child.delete(cid, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Delete multiple blocks from the blockstore\n     */\n    async *deleteMany(cids, options = {}) {\n        const releaseLock = await this.lock.writeLock();\n        try {\n            const storage = this;\n            yield* this.child.deleteMany((async function* () {\n                for await (const cid of cids) {\n                    if (await storage.pins.isPinned(cid)) {\n                        throw new Error('CID was pinned');\n                    }\n                    yield cid;\n                }\n            }()), options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    async has(cid, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            return await this.child.has(cid, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    async *getAll(options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            yield* this.child.getAll(options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n}\n//# sourceMappingURL=storage.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/storage.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/dag-walkers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/dag-walkers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dagCborWalker: () => (/* binding */ dagCborWalker),\n/* harmony export */   dagJsonWalker: () => (/* binding */ dagJsonWalker),\n/* harmony export */   dagPbWalker: () => (/* binding */ dagPbWalker),\n/* harmony export */   defaultDagWalkers: () => (/* binding */ defaultDagWalkers),\n/* harmony export */   jsonWalker: () => (/* binding */ jsonWalker),\n/* harmony export */   rawWalker: () => (/* binding */ rawWalker)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-cbor */ \"./node_modules/@ipld/dag-cbor/src/index.js\");\n/* harmony import */ var _ipld_dag_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ipld/dag-json */ \"./node_modules/@ipld/dag-json/src/index.js\");\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/* harmony import */ var cborg_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cborg/json */ \"./node_modules/cborg/lib/json/json.js\");\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats */ \"./node_modules/multiformats/dist/src/index.js\");\n/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/bases/base64 */ \"./node_modules/multiformats/dist/src/bases/base64.js\");\n/* harmony import */ var multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! multiformats/codecs/json */ \"./node_modules/multiformats/dist/src/codecs/json.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* eslint max-depth: [\"error\", 7] */\n\n\n\n\n\n\n\n\n\n\n/**\n * Dag walker for dag-pb CIDs\n */\nconst dagPbWalker = {\n    codec: _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__.code,\n    *walk(block) {\n        const node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__.decode(block);\n        yield* node.Links.map(l => l.Hash);\n    }\n};\n/**\n * Dag walker for raw CIDs\n */\nconst rawWalker = {\n    codec: multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_8__.code,\n    *walk() {\n        // no embedded CIDs in a raw block\n    }\n};\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_TAG = 42;\n/**\n * Dag walker for dag-cbor CIDs. Does not actually use dag-cbor since\n * all we are interested in is extracting the the CIDs from the block\n * so we can just use cborg for that.\n */\nconst dagCborWalker = {\n    codec: _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__.code,\n    *walk(block) {\n        const cids = [];\n        const tags = [];\n        tags[CID_TAG] = (bytes) => {\n            if (bytes[0] !== 0) {\n                throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n            }\n            const cid = multiformats__WEBPACK_IMPORTED_MODULE_5__.CID.decode(bytes.subarray(1)); // ignore leading 0x00\n            cids.push(cid);\n            return cid;\n        };\n        cborg__WEBPACK_IMPORTED_MODULE_3__.decode(block, {\n            tags\n        });\n        yield* cids;\n    }\n};\n/**\n * Borrowed from @ipld/dag-json\n */\nclass DagJsonTokenizer extends cborg_json__WEBPACK_IMPORTED_MODULE_4__.Tokenizer {\n    tokenBuffer;\n    constructor(data, options) {\n        super(data, options);\n        this.tokenBuffer = [];\n    }\n    done() {\n        return this.tokenBuffer.length === 0 && super.done();\n    }\n    _next() {\n        if (this.tokenBuffer.length > 0) {\n            // @ts-expect-error https://github.com/Microsoft/TypeScript/issues/30406\n            return this.tokenBuffer.pop();\n        }\n        return super.next();\n    }\n    /**\n     * Implements rules outlined in https://github.com/ipld/specs/pull/356\n     */\n    next() {\n        const token = this._next();\n        if (token.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.map) {\n            const keyToken = this._next();\n            if (keyToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string && keyToken.value === '/') {\n                const valueToken = this._next();\n                if (valueToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string) { // *must* be a CID\n                    const breakToken = this._next(); // swallow the end-of-map token\n                    if (breakToken.type !== cborg__WEBPACK_IMPORTED_MODULE_3__.Type.break) {\n                        throw new Error('Invalid encoded CID form');\n                    }\n                    this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token\n                    return new cborg__WEBPACK_IMPORTED_MODULE_3__.Token(cborg__WEBPACK_IMPORTED_MODULE_3__.Type.tag, 42, 0);\n                }\n                if (valueToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.map) {\n                    const innerKeyToken = this._next();\n                    if (innerKeyToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string && innerKeyToken.value === 'bytes') {\n                        const innerValueToken = this._next();\n                        if (innerValueToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string) { // *must* be Bytes\n                            for (let i = 0; i < 2; i++) {\n                                const breakToken = this._next(); // swallow two end-of-map tokens\n                                if (breakToken.type !== cborg__WEBPACK_IMPORTED_MODULE_3__.Type.break) {\n                                    throw new Error('Invalid encoded Bytes form');\n                                }\n                            }\n                            const bytes = multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_6__.base64.decode(`m${innerValueToken.value}`);\n                            return new cborg__WEBPACK_IMPORTED_MODULE_3__.Token(cborg__WEBPACK_IMPORTED_MODULE_3__.Type.bytes, bytes, innerValueToken.value.length);\n                        }\n                        this.tokenBuffer.push(innerValueToken); // bail\n                    }\n                    this.tokenBuffer.push(innerKeyToken); // bail\n                }\n                this.tokenBuffer.push(valueToken); // bail\n            }\n            this.tokenBuffer.push(keyToken); // bail\n        }\n        return token;\n    }\n}\n/**\n * Dag walker for dag-json CIDs. Does not actually use dag-json since\n * all we are interested in is extracting the the CIDs from the block\n * so we can just use cborg/json for that.\n */\nconst dagJsonWalker = {\n    codec: _ipld_dag_json__WEBPACK_IMPORTED_MODULE_1__.code,\n    *walk(block) {\n        const cids = [];\n        const tags = [];\n        tags[CID_TAG] = (string) => {\n            const cid = multiformats__WEBPACK_IMPORTED_MODULE_5__.CID.parse(string);\n            cids.push(cid);\n            return cid;\n        };\n        cborg_json__WEBPACK_IMPORTED_MODULE_4__.decode(block, {\n            tags,\n            tokenizer: new DagJsonTokenizer(block, {\n                tags,\n                allowIndefinite: true,\n                allowUndefined: true,\n                allowNaN: true,\n                allowInfinity: true,\n                allowBigInt: true,\n                strict: false,\n                rejectDuplicateMapKeys: false\n            })\n        });\n        yield* cids;\n    }\n};\n/**\n * Dag walker for json CIDs. JSON has no facility for linking to\n * external blocks so the walker is a no-op.\n */\nconst jsonWalker = {\n    codec: multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_7__.code,\n    *walk() { }\n};\nfunction defaultDagWalkers(walkers = []) {\n    const output = {};\n    [\n        dagPbWalker,\n        rawWalker,\n        dagCborWalker,\n        dagJsonWalker,\n        jsonWalker,\n        ...walkers\n    ].forEach(dagWalker => {\n        output[dagWalker.codec] = dagWalker;\n    });\n    return output;\n}\n//# sourceMappingURL=dag-walkers.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/dag-walkers.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/datastore-version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/datastore-version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertDatastoreVersionIsCurrent: () => (/* binding */ assertDatastoreVersionIsCurrent)\n/* harmony export */ });\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n\n\n\nconst DS_VERSION_KEY = new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key('/version');\nconst CURRENT_VERSION = 1;\nasync function assertDatastoreVersionIsCurrent(datastore) {\n    if (!(await datastore.has(DS_VERSION_KEY))) {\n        await datastore.put(DS_VERSION_KEY, (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(`${CURRENT_VERSION}`));\n        return;\n    }\n    const buf = await datastore.get(DS_VERSION_KEY);\n    const str = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(buf);\n    const version = parseInt(str, 10);\n    if (version !== CURRENT_VERSION) {\n        // TODO: write migrations when we break compatibility - for an example, see https://github.com/ipfs/js-ipfs-repo/tree/master/packages/ipfs-repo-migrations\n        throw new Error('Unknown datastore version, a datastore migration may be required');\n    }\n}\n//# sourceMappingURL=datastore-version.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/datastore-version.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/default-hashers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/default-hashers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultHashers: () => (/* binding */ defaultHashers)\n/* harmony export */ });\n/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/hashes/identity */ \"./node_modules/multiformats/dist/src/hashes/identity.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n\n\nfunction defaultHashers(hashers = []) {\n    const output = {};\n    [\n        multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha256,\n        multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_0__.identity,\n        ...hashers\n    ].forEach(hasher => {\n        output[hasher.code] = hasher;\n    });\n    return output;\n}\n//# sourceMappingURL=default-hashers.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/default-hashers.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/networked-storage.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/networked-storage.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkedStorage: () => (/* binding */ NetworkedStorage),\n/* harmony export */   getCidBlockVerifierFunction: () => (/* binding */ getCidBlockVerifierFunction)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! any-signal */ \"./node_modules/any-signal/dist/src/index.js\");\n/* harmony import */ var blockstore_core_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blockstore-core/identity */ \"./node_modules/blockstore-core/dist/src/identity.js\");\n/* harmony import */ var blockstore_core_tiered__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blockstore-core/tiered */ \"./node_modules/blockstore-core/dist/src/tiered.js\");\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_foreach__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-foreach */ \"./node_modules/it-foreach/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n\n\n\n\n\n\n\n\nfunction isBlockRetriever(b) {\n    return typeof b.retrieve === 'function';\n}\nfunction isBlockAnnouncer(b) {\n    return typeof b.announce === 'function';\n}\n/**\n * Networked storage wraps a regular blockstore - when getting blocks if the\n * blocks are not present Bitswap will be used to fetch them from network peers.\n */\nclass NetworkedStorage {\n    child;\n    blockRetrievers;\n    blockAnnouncers;\n    hashers;\n    started;\n    log;\n    /**\n     * Create a new BlockStorage\n     */\n    constructor(components) {\n        this.log = components.logger.forComponent('helia:networked-storage');\n        this.child = new blockstore_core_tiered__WEBPACK_IMPORTED_MODULE_2__.TieredBlockstore([\n            new blockstore_core_identity__WEBPACK_IMPORTED_MODULE_1__.IdentityBlockstore(),\n            components.blockstore\n        ]);\n        this.blockRetrievers = (components.blockBrokers ?? []).filter(isBlockRetriever);\n        this.blockAnnouncers = (components.blockBrokers ?? []).filter(isBlockAnnouncer);\n        this.hashers = components.hashers ?? {};\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.start)(this.child, ...new Set([...this.blockRetrievers, ...this.blockAnnouncers]));\n        this.started = true;\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.stop)(this.child, ...new Set([...this.blockRetrievers, ...this.blockAnnouncers]));\n        this.started = false;\n    }\n    unwrap() {\n        return this.child;\n    }\n    /**\n     * Put a block to the underlying datastore\n     */\n    async put(cid, block, options = {}) {\n        if (await this.child.has(cid)) {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put:duplicate', cid));\n            return cid;\n        }\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put:providers:notify', cid));\n        this.blockAnnouncers.forEach(provider => {\n            provider.announce(cid, block, options);\n        });\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put:blockstore:put', cid));\n        return this.child.put(cid, block, options);\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore\n     */\n    async *putMany(blocks, options = {}) {\n        const missingBlocks = (0,it_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(blocks, async ({ cid }) => {\n            const has = await this.child.has(cid);\n            if (has) {\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put-many:duplicate', cid));\n            }\n            return !has;\n        });\n        const notifyEach = (0,it_foreach__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(missingBlocks, ({ cid, block }) => {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put-many:providers:notify', cid));\n            this.blockAnnouncers.forEach(provider => {\n                provider.announce(cid, block, options);\n            });\n        });\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put-many:blockstore:put-many'));\n        yield* this.child.putMany(notifyEach, options);\n    }\n    /**\n     * Get a block by cid\n     */\n    async get(cid, options = {}) {\n        if (options.offline !== true && !(await this.child.has(cid))) {\n            // we do not have the block locally, get it from a block provider\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:providers:get', cid));\n            const block = await raceBlockRetrievers(cid, this.blockRetrievers, this.hashers[cid.multihash.code], {\n                ...options,\n                log: this.log\n            });\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:blockstore:put', cid));\n            await this.child.put(cid, block, options);\n            // notify other block providers of the new block\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:providers:notify', cid));\n            this.blockAnnouncers.forEach(provider => {\n                provider.announce(cid, block, options);\n            });\n            return block;\n        }\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:blockstore:get', cid));\n        return this.child.get(cid, options);\n    }\n    /**\n     * Get multiple blocks back from an (async) iterable of cids\n     */\n    async *getMany(cids, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:blockstore:get-many'));\n        yield* this.child.getMany((0,it_foreach__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(cids, async (cid) => {\n            if (options.offline !== true && !(await this.child.has(cid))) {\n                // we do not have the block locally, get it from a block provider\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:providers:get', cid));\n                const block = await raceBlockRetrievers(cid, this.blockRetrievers, this.hashers[cid.multihash.code], {\n                    ...options,\n                    log: this.log\n                });\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:blockstore:put', cid));\n                await this.child.put(cid, block, options);\n                // notify other block providers of the new block\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:providers:notify', cid));\n                this.blockAnnouncers.forEach(provider => {\n                    provider.announce(cid, block, options);\n                });\n            }\n        }));\n    }\n    /**\n     * Delete a block from the blockstore\n     */\n    async delete(cid, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:delete:blockstore:delete', cid));\n        await this.child.delete(cid, options);\n    }\n    /**\n     * Delete multiple blocks from the blockstore\n     */\n    async *deleteMany(cids, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:delete-many:blockstore:delete-many'));\n        yield* this.child.deleteMany((async function* () {\n            for await (const cid of cids) {\n                yield cid;\n            }\n        }()), options);\n    }\n    async has(cid, options = {}) {\n        return this.child.has(cid, options);\n    }\n    async *getAll(options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-all:blockstore:get-many'));\n        yield* this.child.getAll(options);\n    }\n}\nconst getCidBlockVerifierFunction = (cid, hasher) => {\n    if (hasher == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`, 'ERR_UNKNOWN_HASH_ALG');\n    }\n    return async (block) => {\n        // verify block\n        const hash = await hasher.digest(block);\n        if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__.equals)(hash.digest, cid.multihash.digest)) {\n            // if a hash mismatch occurs for a TrustlessGatewayBlockBroker, we should try another gateway\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('Hash of downloaded block did not match multihash from passed CID', 'ERR_HASH_MISMATCH');\n        }\n    };\n};\n/**\n * Race block providers cancelling any pending requests once the block has been\n * found.\n */\nasync function raceBlockRetrievers(cid, providers, hasher, options) {\n    const validateFn = getCidBlockVerifierFunction(cid, hasher);\n    const controller = new AbortController();\n    const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_0__.anySignal)([controller.signal, options.signal]);\n    try {\n        return await Promise.any(providers.map(async (provider) => {\n            try {\n                let blocksWereValidated = false;\n                const block = await provider.retrieve(cid, {\n                    ...options,\n                    signal,\n                    validateFn: async (block) => {\n                        await validateFn(block);\n                        blocksWereValidated = true;\n                    }\n                });\n                if (!blocksWereValidated) {\n                    // the blockBroker either did not throw an error when attempting to validate the block\n                    // or did not call the validateFn at all. We should validate the block ourselves\n                    await validateFn(block);\n                }\n                return block;\n            }\n            catch (err) {\n                options.log.error('could not retrieve verified block for %c', cid, err);\n                throw err;\n            }\n        }));\n    }\n    finally {\n        signal.clear();\n    }\n}\n//# sourceMappingURL=networked-storage.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/networked-storage.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   derivedEmptyPasswordKey: () => (/* binding */ derivedEmptyPasswordKey)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webcrypto.js */ \"./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js\");\n\n\n\n// WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\nconst derivedEmptyPasswordKey = { alg: 'A128GCM', ext: true, k: 'scm9jmO_4BJAgdwWGVulLg', key_ops: ['encrypt', 'decrypt'], kty: 'oct' };\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\nfunction create(opts) {\n    const algorithm = opts?.algorithm ?? 'AES-GCM';\n    let keyLength = opts?.keyLength ?? 16;\n    const nonceLength = opts?.nonceLength ?? 12;\n    const digest = opts?.digest ?? 'SHA-256';\n    const saltLength = opts?.saltLength ?? 16;\n    const iterations = opts?.iterations ?? 32767;\n    const crypto = _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get();\n    keyLength *= 8; // Browser crypto uses bits instead of bytes\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to encrypt the data.\n     */\n    async function encrypt(data, password) {\n        const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n        const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['encrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            }\n        }\n        else {\n            // Derive a key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt']);\n        }\n        // Encrypt the string.\n        const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n        return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n    }\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to decrypt the data. The options used to create\n     * this decryption cipher must be the same as those used to create\n     * the encryption cipher.\n     */\n    async function decrypt(data, password) {\n        const salt = data.subarray(0, saltLength);\n        const nonce = data.subarray(saltLength, saltLength + nonceLength);\n        const ciphertext = data.subarray(saltLength + nonceLength);\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['decrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['decrypt']);\n            }\n        }\n        else {\n            // Derive the key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt']);\n        }\n        // Decrypt the string.\n        const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n        return new Uint8Array(plaintext);\n    }\n    const cipher = {\n        encrypt,\n        decrypt\n    };\n    return cipher;\n}\n//# sourceMappingURL=aes-gcm.browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webcrypto.js */ \"./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js\");\n/* harmony import */ var _lengths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lengths.js */ \"./node_modules/@libp2p/crypto/dist/src/hmac/lengths.js\");\n\n\nconst hashTypes = {\n    SHA1: 'SHA-1',\n    SHA256: 'SHA-256',\n    SHA512: 'SHA-512'\n};\nconst sign = async (key, data) => {\n    const buf = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get().subtle.sign({ name: 'HMAC' }, key, data);\n    return new Uint8Array(buf, 0, buf.byteLength);\n};\nasync function create(hashType, secret) {\n    const hash = hashTypes[hashType];\n    const key = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get().subtle.importKey('raw', secret, {\n        name: 'HMAC',\n        hash: { name: hash }\n    }, false, ['sign']);\n    return {\n        async digest(data) {\n            return sign(key, data);\n        },\n        length: _lengths_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][hashType]\n    };\n}\n//# sourceMappingURL=index-browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/hmac/lengths.js":
/*!**************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/hmac/lengths.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    SHA1: 20,\n    SHA256: 32,\n    SHA512: 64\n});\n//# sourceMappingURL=lengths.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/hmac/lengths.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateEphmeralKeyPair: () => (/* binding */ generateEphmeralKeyPair)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ \"./node_modules/@libp2p/crypto/dist/src/util.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webcrypto.js */ \"./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js\");\n\n\n\n\n\n\nconst bits = {\n    'P-256': 256,\n    'P-384': 384,\n    'P-521': 521\n};\nconst curveTypes = Object.keys(bits);\nconst names = curveTypes.join(' / ');\nasync function generateEphmeralKeyPair(curve) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const pair = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get().subtle.generateKey({\n        name: 'ECDH',\n        namedCurve: curve\n    }, true, ['deriveBits']);\n    // forcePrivate is used for testing only\n    const genSharedKey = async (theirPub, forcePrivate) => {\n        let privateKey;\n        if (forcePrivate != null) {\n            privateKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n                name: 'ECDH',\n                namedCurve: curve\n            }, false, ['deriveBits']);\n        }\n        else {\n            privateKey = pair.privateKey;\n        }\n        const key = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n            name: 'ECDH',\n            namedCurve: curve\n        }, false, []);\n        const buffer = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get().subtle.deriveBits({\n            name: 'ECDH',\n            // @ts-expect-error namedCurve is missing from the types\n            namedCurve: curve,\n            public: key\n        }, privateKey, bits[curve]);\n        return new Uint8Array(buffer, 0, buffer.byteLength);\n    };\n    const publicKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get().subtle.exportKey('jwk', pair.publicKey);\n    const ecdhKey = {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n    };\n    return ecdhKey;\n}\nconst curveLengths = {\n    'P-256': 32,\n    'P-384': 48,\n    'P-521': 66\n};\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey(jwk) {\n    if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const byteLen = curveLengths[jwk.crv];\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        Uint8Array.from([4]), // uncompressed point\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.base64urlToBuffer)(jwk.x, byteLen),\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.base64urlToBuffer)(jwk.y, byteLen)\n    ], 1 + byteLen * 2);\n}\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey(curve, key) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const byteLen = curveLengths[curve];\n    if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__.equals)(key.subarray(0, 1), Uint8Array.from([4]))) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT');\n    }\n    return {\n        kty: 'EC',\n        crv: curve,\n        x: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(key.subarray(1, byteLen + 1), 'base64url'),\n        y: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(key.subarray(1 + byteLen), 'base64url'),\n        ext: true\n    };\n}\nconst unmarshalPrivateKey = (curve, key) => ({\n    ...unmarshalPublicKey(curve, key.public),\n    d: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(key.private, 'base64url')\n});\n//# sourceMappingURL=ecdh-browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   generateKeyFromSeed: () => (/* binding */ generateKeyFromSeed),\n/* harmony export */   hashAndSign: () => (/* binding */ hashAndSign),\n/* harmony export */   hashAndVerify: () => (/* binding */ hashAndVerify),\n/* harmony export */   privateKeyLength: () => (/* binding */ PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   publicKeyLength: () => (/* binding */ PUBLIC_KEY_BYTE_LENGTH)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"./node_modules/@noble/curves/esm/ed25519.js\");\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32;\nconst PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32;\n\n\nfunction generateKey() {\n    // the actual private key (32 bytes)\n    const privateKeyRaw = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_0__.ed25519.utils.randomPrivateKey();\n    const publicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_0__.ed25519.getPublicKey(privateKeyRaw);\n    // concatenated the public key to the private key\n    const privateKey = concatKeys(privateKeyRaw, publicKey);\n    return {\n        privateKey,\n        publicKey\n    };\n}\n/**\n * Generate keypair from a 32 byte uint8array\n */\nfunction generateKeyFromSeed(seed) {\n    if (seed.length !== KEYS_BYTE_LENGTH) {\n        throw new TypeError('\"seed\" must be 32 bytes in length.');\n    }\n    else if (!(seed instanceof Uint8Array)) {\n        throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n    }\n    // based on node forges algorithm, the seed is used directly as private key\n    const privateKeyRaw = seed;\n    const publicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_0__.ed25519.getPublicKey(privateKeyRaw);\n    const privateKey = concatKeys(privateKeyRaw, publicKey);\n    return {\n        privateKey,\n        publicKey\n    };\n}\nfunction hashAndSign(privateKey, msg) {\n    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);\n    return _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_0__.ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);\n}\nfunction hashAndVerify(publicKey, sig, msg) {\n    return _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_0__.ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);\n}\nfunction concatKeys(privateKeyRaw, publicKey) {\n    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);\n    for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n        privateKey[i] = privateKeyRaw[i];\n        privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n    }\n    return privateKey;\n}\n//# sourceMappingURL=ed25519-browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js":
/*!********************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519PrivateKey: () => (/* binding */ Ed25519PrivateKey),\n/* harmony export */   Ed25519PublicKey: () => (/* binding */ Ed25519PublicKey),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateKeyPairFromSeed: () => (/* binding */ generateKeyPairFromSeed),\n/* harmony export */   unmarshalEd25519PrivateKey: () => (/* binding */ unmarshalEd25519PrivateKey),\n/* harmony export */   unmarshalEd25519PublicKey: () => (/* binding */ unmarshalEd25519PublicKey)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/hashes/identity */ \"./node_modules/multiformats/dist/src/hashes/identity.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util.js */ \"./node_modules/@libp2p/crypto/dist/src/util.js\");\n/* harmony import */ var _ed25519_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ed25519.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js\");\n/* harmony import */ var _exporter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exporter.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/exporter.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keys.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/keys.js\");\n\n\n\n\n\n\n\n\n\nclass Ed25519PublicKey {\n    _key;\n    constructor(key) {\n        this._key = ensureKey(key, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.publicKeyLength);\n    }\n    verify(data, sig) {\n        return _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.hashAndVerify(this._key, sig, data);\n    }\n    marshal() {\n        return this._key;\n    }\n    get bytes() {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_5__.PublicKey.encode({\n            Type: _keys_js__WEBPACK_IMPORTED_MODULE_5__.KeyType.Ed25519,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_3__.equals)(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(this.bytes);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.isPromise)(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n}\nclass Ed25519PrivateKey {\n    _key;\n    _publicKey;\n    // key       - 64 byte Uint8Array containing private key\n    // publicKey - 32 byte Uint8Array containing public key\n    constructor(key, publicKey) {\n        this._key = ensureKey(key, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength);\n        this._publicKey = ensureKey(publicKey, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.publicKeyLength);\n    }\n    sign(message) {\n        return _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.hashAndSign(this._key, message);\n    }\n    get public() {\n        return new Ed25519PublicKey(this._publicKey);\n    }\n    marshal() {\n        return this._key;\n    }\n    get bytes() {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_5__.PrivateKey.encode({\n            Type: _keys_js__WEBPACK_IMPORTED_MODULE_5__.KeyType.Ed25519,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_3__.equals)(this.bytes, key.bytes);\n    }\n    async hash() {\n        const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(this.bytes);\n        let bytes;\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.isPromise)(p)) {\n            ({ bytes } = await p);\n        }\n        else {\n            bytes = p.bytes;\n        }\n        return bytes;\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the identity multihash containing its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n    async id() {\n        const encoding = multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_1__.identity.digest(this.public.bytes);\n        return multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc.encode(encoding.bytes).substring(1);\n    }\n    /**\n     * Exports the key into a password protected `format`\n     */\n    async export(password, format = 'libp2p-key') {\n        if (format === 'libp2p-key') {\n            return (0,_exporter_js__WEBPACK_IMPORTED_MODULE_7__.exporter)(this.bytes, password);\n        }\n        else {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n        }\n    }\n}\nfunction unmarshalEd25519PrivateKey(bytes) {\n    // Try the old, redundant public key version\n    if (bytes.length > _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength) {\n        bytes = ensureKey(bytes, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength + _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.publicKeyLength);\n        const privateKeyBytes = bytes.subarray(0, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength);\n        const publicKeyBytes = bytes.subarray(_ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength, bytes.length);\n        return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n    }\n    bytes = ensureKey(bytes, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength);\n    const privateKeyBytes = bytes.subarray(0, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.privateKeyLength);\n    const publicKeyBytes = bytes.subarray(_ed25519_js__WEBPACK_IMPORTED_MODULE_4__.publicKeyLength);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\nfunction unmarshalEd25519PublicKey(bytes) {\n    bytes = ensureKey(bytes, _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.publicKeyLength);\n    return new Ed25519PublicKey(bytes);\n}\nasync function generateKeyPair() {\n    const { privateKey, publicKey } = _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.generateKey();\n    return new Ed25519PrivateKey(privateKey, publicKey);\n}\nasync function generateKeyPairFromSeed(seed) {\n    const { privateKey, publicKey } = _ed25519_js__WEBPACK_IMPORTED_MODULE_4__.generateKeyFromSeed(seed);\n    return new Ed25519PrivateKey(privateKey, publicKey);\n}\nfunction ensureKey(key, length) {\n    key = Uint8Array.from(key ?? []);\n    if (key.length !== length) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError(`Key must be a Uint8Array of length ${length}, got ${key.length}`, 'ERR_INVALID_KEY_TYPE');\n    }\n    return key;\n}\n//# sourceMappingURL=ed25519-class.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ecdh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ecdh.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js\");\n\n/**\n * Generates an ephemeral public key and returns a function that will compute\n * the shared secret key.\n *\n * Focuses only on ECDH now, but can be made more general in the future.\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_ecdh_js__WEBPACK_IMPORTED_MODULE_0__.generateEphmeralKeyPair);\n//# sourceMappingURL=ephemeral-keys.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/exporter.js":
/*!***************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/exporter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exporter: () => (/* binding */ exporter)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base64 */ \"./node_modules/multiformats/dist/src/bases/base64.js\");\n/* harmony import */ var _ciphers_aes_gcm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ciphers/aes-gcm.js */ \"./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js\");\n\n\n/**\n * Exports the given PrivateKey as a base64 encoded string.\n * The PrivateKey is encrypted via a password derived PBKDF2 key\n * leveraging the aes-gcm cipher algorithm.\n */\nasync function exporter(privateKey, password) {\n    const cipher = _ciphers_aes_gcm_js__WEBPACK_IMPORTED_MODULE_1__.create();\n    const encryptedKey = await cipher.encrypt(privateKey, password);\n    return multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__.base64.encode(encryptedKey);\n}\n//# sourceMappingURL=exporter.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/exporter.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/importer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/importer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   importer: () => (/* binding */ importer)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base64 */ \"./node_modules/multiformats/dist/src/bases/base64.js\");\n/* harmony import */ var _ciphers_aes_gcm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ciphers/aes-gcm.js */ \"./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js\");\n\n\n/**\n * Attempts to decrypt a base64 encoded PrivateKey string\n * with the given password. The privateKey must have been exported\n * using the same password and underlying cipher (aes-gcm)\n */\nasync function importer(privateKey, password) {\n    const encryptedKey = multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_0__.base64.decode(privateKey);\n    const cipher = _ciphers_aes_gcm_js__WEBPACK_IMPORTED_MODULE_1__.create();\n    return cipher.decrypt(encryptedKey, password);\n}\n//# sourceMappingURL=importer.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/importer.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519PrivateKey: () => (/* reexport safe */ _ed25519_class_js__WEBPACK_IMPORTED_MODULE_4__.Ed25519PrivateKey),\n/* harmony export */   Ed25519PublicKey: () => (/* reexport safe */ _ed25519_class_js__WEBPACK_IMPORTED_MODULE_4__.Ed25519PublicKey),\n/* harmony export */   MAX_RSA_KEY_SIZE: () => (/* reexport safe */ _rsa_class_js__WEBPACK_IMPORTED_MODULE_3__.MAX_RSA_KEY_SIZE),\n/* harmony export */   RsaPrivateKey: () => (/* reexport safe */ _rsa_class_js__WEBPACK_IMPORTED_MODULE_3__.RsaPrivateKey),\n/* harmony export */   RsaPublicKey: () => (/* reexport safe */ _rsa_class_js__WEBPACK_IMPORTED_MODULE_3__.RsaPublicKey),\n/* harmony export */   Secp256k1PrivateKey: () => (/* reexport safe */ _secp256k1_class_js__WEBPACK_IMPORTED_MODULE_5__.Secp256k1PrivateKey),\n/* harmony export */   Secp256k1PublicKey: () => (/* reexport safe */ _secp256k1_class_js__WEBPACK_IMPORTED_MODULE_5__.Secp256k1PublicKey),\n/* harmony export */   generateEphemeralKeyPair: () => (/* reexport safe */ _ephemeral_keys_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateKeyPairFromSeed: () => (/* binding */ generateKeyPairFromSeed),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   keyStretcher: () => (/* reexport safe */ _key_stretcher_js__WEBPACK_IMPORTED_MODULE_0__.keyStretcher),\n/* harmony export */   keysPBM: () => (/* reexport module object */ _keys_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   marshalPrivateKey: () => (/* binding */ marshalPrivateKey),\n/* harmony export */   marshalPublicKey: () => (/* binding */ marshalPublicKey),\n/* harmony export */   supportedKeys: () => (/* binding */ supportedKeys),\n/* harmony export */   unmarshalPrivateKey: () => (/* binding */ unmarshalPrivateKey),\n/* harmony export */   unmarshalPublicKey: () => (/* binding */ unmarshalPublicKey)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _ed25519_class_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ed25519-class.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js\");\n/* harmony import */ var _ephemeral_keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ephemeral-keys.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js\");\n/* harmony import */ var _importer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./importer.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/importer.js\");\n/* harmony import */ var _key_stretcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./key-stretcher.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/keys.js\");\n/* harmony import */ var _rsa_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rsa-class.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js\");\n/* harmony import */ var _rsa_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rsa-utils.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js\");\n/* harmony import */ var _secp256k1_class_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./secp256k1-class.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js\");\n/**\n * @packageDocumentation\n *\n * **Supported Key Types**\n *\n * The {@link generateKeyPair}, {@link marshalPublicKey}, and {@link marshalPrivateKey} functions accept a string `type` argument.\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst supportedKeys = {\n    rsa: _rsa_class_js__WEBPACK_IMPORTED_MODULE_3__,\n    ed25519: _ed25519_class_js__WEBPACK_IMPORTED_MODULE_4__,\n    secp256k1: _secp256k1_class_js__WEBPACK_IMPORTED_MODULE_5__\n};\nfunction unsupportedKey(type) {\n    const supported = Object.keys(supportedKeys).join(' / ');\n    return new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, 'ERR_UNSUPPORTED_KEY_TYPE');\n}\nfunction typeToKey(type) {\n    type = type.toLowerCase();\n    if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n        return supportedKeys[type];\n    }\n    throw unsupportedKey(type);\n}\n/**\n * Generates a keypair of the given type and bitsize\n *\n * @param type\n * @param bits -  Minimum of 1024\n */\nasync function generateKeyPair(type, bits) {\n    return typeToKey(type).generateKeyPair(bits ?? 2048);\n}\n/**\n * Generates a keypair of the given type and bitsize.\n *\n * Seed is a 32 byte uint8array\n */\nasync function generateKeyPairFromSeed(type, seed, bits) {\n    if (type.toLowerCase() !== 'ed25519') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n    }\n    return _ed25519_class_js__WEBPACK_IMPORTED_MODULE_4__.generateKeyPairFromSeed(seed);\n}\n/**\n * Converts a protobuf serialized public key into its representative object\n */\nfunction unmarshalPublicKey(buf) {\n    const decoded = _keys_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey.decode(buf);\n    const data = decoded.Data ?? new Uint8Array();\n    switch (decoded.Type) {\n        case _keys_js__WEBPACK_IMPORTED_MODULE_2__.KeyType.RSA:\n            return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n        case _keys_js__WEBPACK_IMPORTED_MODULE_2__.KeyType.Ed25519:\n            return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n        case _keys_js__WEBPACK_IMPORTED_MODULE_2__.KeyType.Secp256k1:\n            return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n        default:\n            throw unsupportedKey(decoded.Type ?? 'unknown');\n    }\n}\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nfunction marshalPublicKey(key, type) {\n    type = (type ?? 'rsa').toLowerCase();\n    typeToKey(type); // check type\n    return key.bytes;\n}\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nasync function unmarshalPrivateKey(buf) {\n    const decoded = _keys_js__WEBPACK_IMPORTED_MODULE_2__.PrivateKey.decode(buf);\n    const data = decoded.Data ?? new Uint8Array();\n    switch (decoded.Type) {\n        case _keys_js__WEBPACK_IMPORTED_MODULE_2__.KeyType.RSA:\n            return supportedKeys.rsa.unmarshalRsaPrivateKey(data);\n        case _keys_js__WEBPACK_IMPORTED_MODULE_2__.KeyType.Ed25519:\n            return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);\n        case _keys_js__WEBPACK_IMPORTED_MODULE_2__.KeyType.Secp256k1:\n            return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);\n        default:\n            throw unsupportedKey(decoded.Type ?? 'RSA');\n    }\n}\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nfunction marshalPrivateKey(key, type) {\n    type = (type ?? 'rsa').toLowerCase();\n    typeToKey(type); // check type\n    return key.bytes;\n}\n/**\n * Converts an exported private key into its representative object.\n *\n * Supported formats are 'pem' (RSA only) and 'libp2p-key'.\n */\nasync function importKey(encryptedKey, password) {\n    try {\n        const key = await (0,_importer_js__WEBPACK_IMPORTED_MODULE_7__.importer)(encryptedKey, password);\n        return await unmarshalPrivateKey(key);\n    }\n    catch (_) {\n        // Ignore and try the old pem decrypt\n    }\n    if (!encryptedKey.includes('BEGIN')) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Encrypted key was not a libp2p-key or a PEM file', 'ERR_INVALID_IMPORT_FORMAT');\n    }\n    return (0,_rsa_utils_js__WEBPACK_IMPORTED_MODULE_8__.importFromPem)(encryptedKey, password);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keyStretcher: () => (/* binding */ keyStretcher)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var _hmac_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hmac/index.js */ \"./node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js\");\n\n\n\n\nconst cipherMap = {\n    'AES-128': {\n        ivSize: 16,\n        keySize: 16\n    },\n    'AES-256': {\n        ivSize: 16,\n        keySize: 32\n    },\n    Blowfish: {\n        ivSize: 8,\n        keySize: 32\n    }\n};\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nasync function keyStretcher(cipherType, hash, secret) {\n    const cipher = cipherMap[cipherType];\n    if (cipher == null) {\n        const allowed = Object.keys(cipherMap).join(' / ');\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, 'ERR_INVALID_CIPHER_TYPE');\n    }\n    if (hash == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('missing hash type', 'ERR_MISSING_HASH_TYPE');\n    }\n    const cipherKeySize = cipher.keySize;\n    const ivSize = cipher.ivSize;\n    const hmacKeySize = 20;\n    const seed = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)('key expansion');\n    const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n    const m = await _hmac_index_js__WEBPACK_IMPORTED_MODULE_3__.create(hash, secret);\n    let a = await m.digest(seed);\n    const result = [];\n    let j = 0;\n    while (j < resultLength) {\n        const b = await m.digest((0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)([a, seed]));\n        let todo = b.length;\n        if (j + todo > resultLength) {\n            todo = resultLength - j;\n        }\n        result.push(b);\n        j += todo;\n        a = await m.digest(a);\n    }\n    const half = resultLength / 2;\n    const resultBuffer = (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)(result);\n    const r1 = resultBuffer.subarray(0, half);\n    const r2 = resultBuffer.subarray(half, resultLength);\n    const createKey = (res) => ({\n        iv: res.subarray(0, ivSize),\n        cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n        macKey: res.subarray(ivSize + cipherKeySize)\n    });\n    return {\n        k1: createKey(r1),\n        k2: createKey(r2)\n    };\n}\n//# sourceMappingURL=key-stretcher.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/keys.js":
/*!***********************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/keys.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyType: () => (/* binding */ KeyType),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey)\n/* harmony export */ });\n/* harmony import */ var protons_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protons-runtime */ \"./node_modules/protons-runtime/dist/src/index.js\");\n/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nvar KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nvar PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nvar PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/keys.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   getRandomValues: () => (/* reexport safe */ _random_bytes_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   hashAndSign: () => (/* binding */ hashAndSign),\n/* harmony export */   hashAndVerify: () => (/* binding */ hashAndVerify),\n/* harmony export */   keySize: () => (/* binding */ keySize),\n/* harmony export */   unmarshalPrivateKey: () => (/* binding */ unmarshalPrivateKey),\n/* harmony export */   utils: () => (/* reexport module object */ _rsa_utils_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var _random_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../random-bytes.js */ \"./node_modules/@libp2p/crypto/dist/src/random-bytes.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webcrypto.js */ \"./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js\");\n/* harmony import */ var _rsa_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rsa-utils.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js\");\n\n\n\n\n\n\nasync function generateKey(bits) {\n    const pair = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.generateKey({\n        name: 'RSASSA-PKCS1-v1_5',\n        modulusLength: bits,\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: { name: 'SHA-256' }\n    }, true, ['sign', 'verify']);\n    const keys = await exportKey(pair);\n    return {\n        privateKey: keys[0],\n        publicKey: keys[1]\n    };\n}\n// Takes a jwk key\nasync function unmarshalPrivateKey(key) {\n    const privateKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, true, ['sign']);\n    const pair = [\n        privateKey,\n        await derivePublicFromPrivate(key)\n    ];\n    const keys = await exportKey({\n        privateKey: pair[0],\n        publicKey: pair[1]\n    });\n    return {\n        privateKey: keys[0],\n        publicKey: keys[1]\n    };\n}\n\nasync function hashAndSign(key, msg) {\n    const privateKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, false, ['sign']);\n    const sig = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.sign({ name: 'RSASSA-PKCS1-v1_5' }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());\n    return new Uint8Array(sig, 0, sig.byteLength);\n}\nasync function hashAndVerify(key, sig, msg) {\n    const publicKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, false, ['verify']);\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.verify({ name: 'RSASSA-PKCS1-v1_5' }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());\n}\nasync function exportKey(pair) {\n    if (pair.privateKey == null || pair.publicKey == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError('Private and public key are required', 'ERR_INVALID_PARAMETERS');\n    }\n    return Promise.all([\n        _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.exportKey('jwk', pair.privateKey),\n        _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.exportKey('jwk', pair.publicKey)\n    ]);\n}\nasync function derivePublicFromPrivate(jwKey) {\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get().subtle.importKey('jwk', {\n        kty: jwKey.kty,\n        n: jwKey.n,\n        e: jwKey.e\n    }, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, true, ['verify']);\n}\nfunction keySize(jwk) {\n    if (jwk.kty !== 'RSA') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError('invalid key type', 'ERR_INVALID_KEY_TYPE');\n    }\n    else if (jwk.n == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError('invalid key modulus', 'ERR_INVALID_KEY_MODULUS');\n    }\n    const bytes = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(jwk.n, 'base64url');\n    return bytes.length * 8;\n}\n//# sourceMappingURL=rsa-browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js":
/*!****************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_RSA_KEY_SIZE: () => (/* binding */ MAX_RSA_KEY_SIZE),\n/* harmony export */   RsaPrivateKey: () => (/* binding */ RsaPrivateKey),\n/* harmony export */   RsaPublicKey: () => (/* binding */ RsaPublicKey),\n/* harmony export */   fromJwk: () => (/* binding */ fromJwk),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   unmarshalRsaPrivateKey: () => (/* binding */ unmarshalRsaPrivateKey),\n/* harmony export */   unmarshalRsaPublicKey: () => (/* binding */ unmarshalRsaPublicKey)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util.js */ \"./node_modules/@libp2p/crypto/dist/src/util.js\");\n/* harmony import */ var _exporter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./exporter.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/exporter.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keys.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/keys.js\");\n/* harmony import */ var _rsa_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rsa.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js\");\n/* harmony import */ var _rsa_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rsa.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js\");\n/* harmony import */ var _rsa_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rsa.js */ \"./node_modules/@libp2p/crypto/dist/src/random-bytes.js\");\n\n\n\n\n\n\n\n\nconst MAX_RSA_KEY_SIZE = 8192;\nclass RsaPublicKey {\n    _key;\n    constructor(key) {\n        this._key = key;\n    }\n    verify(data, sig) {\n        return _rsa_js__WEBPACK_IMPORTED_MODULE_3__.hashAndVerify(this._key, sig, data);\n    }\n    marshal() {\n        return _rsa_js__WEBPACK_IMPORTED_MODULE_4__.jwkToPkix(this._key);\n    }\n    get bytes() {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_5__.PublicKey.encode({\n            Type: _keys_js__WEBPACK_IMPORTED_MODULE_5__.KeyType.RSA,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__.equals)(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256.digest(this.bytes);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.isPromise)(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n}\nclass RsaPrivateKey {\n    _key;\n    _publicKey;\n    constructor(key, publicKey) {\n        this._key = key;\n        this._publicKey = publicKey;\n    }\n    genSecret() {\n        return _rsa_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](16);\n    }\n    sign(message) {\n        return _rsa_js__WEBPACK_IMPORTED_MODULE_3__.hashAndSign(this._key, message);\n    }\n    get public() {\n        if (this._publicKey == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('public key not provided', 'ERR_PUBKEY_NOT_PROVIDED');\n        }\n        return new RsaPublicKey(this._publicKey);\n    }\n    marshal() {\n        return _rsa_js__WEBPACK_IMPORTED_MODULE_4__.jwkToPkcs1(this._key);\n    }\n    get bytes() {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_5__.PrivateKey.encode({\n            Type: _keys_js__WEBPACK_IMPORTED_MODULE_5__.KeyType.RSA,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__.equals)(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256.digest(this.bytes);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.isPromise)(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     */\n    async id() {\n        const hash = await this.public.hash();\n        return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(hash, 'base58btc');\n    }\n    /**\n     * Exports the key as libp2p-key - a aes-gcm encrypted value with the key\n     * derived from the password.\n     *\n     * To export it as a password protected PEM file, please use the `exportPEM`\n     * function from `@libp2p/rsa`.\n     */\n    async export(password, format = 'pkcs-8') {\n        if (format === 'pkcs-8') {\n            return _rsa_js__WEBPACK_IMPORTED_MODULE_4__.exportToPem(this, password);\n        }\n        else if (format === 'libp2p-key') {\n            return (0,_exporter_js__WEBPACK_IMPORTED_MODULE_9__.exporter)(this.bytes, password);\n        }\n        else {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n        }\n    }\n}\nasync function unmarshalRsaPrivateKey(bytes) {\n    const jwk = _rsa_js__WEBPACK_IMPORTED_MODULE_4__.pkcs1ToJwk(bytes);\n    if (_rsa_js__WEBPACK_IMPORTED_MODULE_3__.keySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    const keys = await _rsa_js__WEBPACK_IMPORTED_MODULE_3__.unmarshalPrivateKey(jwk);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\nfunction unmarshalRsaPublicKey(bytes) {\n    const jwk = _rsa_js__WEBPACK_IMPORTED_MODULE_4__.pkixToJwk(bytes);\n    if (_rsa_js__WEBPACK_IMPORTED_MODULE_3__.keySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    return new RsaPublicKey(jwk);\n}\nasync function fromJwk(jwk) {\n    if (_rsa_js__WEBPACK_IMPORTED_MODULE_3__.keySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    const keys = await _rsa_js__WEBPACK_IMPORTED_MODULE_3__.unmarshalPrivateKey(jwk);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\nasync function generateKeyPair(bits) {\n    if (bits > MAX_RSA_KEY_SIZE) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    const keys = await _rsa_js__WEBPACK_IMPORTED_MODULE_3__.generateKey(bits);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n//# sourceMappingURL=rsa-class.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportToPem: () => (/* binding */ exportToPem),\n/* harmony export */   importFromPem: () => (/* binding */ importFromPem),\n/* harmony export */   jwkToPkcs1: () => (/* binding */ jwkToPkcs1),\n/* harmony export */   jwkToPkix: () => (/* binding */ jwkToPkix),\n/* harmony export */   pkcs1ToJwk: () => (/* binding */ pkcs1ToJwk),\n/* harmony export */   pkixToJwk: () => (/* binding */ pkixToJwk)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ \"./node_modules/asn1js/build/index.es.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _random_bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../random-bytes.js */ \"./node_modules/@libp2p/crypto/dist/src/random-bytes.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webcrypto.js */ \"./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js\");\n/* harmony import */ var _rsa_class_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rsa-class.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK key\n */\nfunction pkcs1ToJwk(bytes) {\n    const { result } = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(bytes);\n    // @ts-expect-error this looks fragile but DER is a canonical format so we are\n    // safe to have deeply property chains like this\n    const values = result.valueBlock.value;\n    const key = {\n        n: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[1].toBigInt()), 'base64url'),\n        e: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[2].toBigInt()), 'base64url'),\n        d: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[3].toBigInt()), 'base64url'),\n        p: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[4].toBigInt()), 'base64url'),\n        q: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[5].toBigInt()), 'base64url'),\n        dp: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[6].toBigInt()), 'base64url'),\n        dq: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[7].toBigInt()), 'base64url'),\n        qi: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[8].toBigInt()), 'base64url'),\n        kty: 'RSA',\n        alg: 'RS256'\n    };\n    return key;\n}\n/**\n * Convert a JWK key into PKCS#1 in ASN1 DER format\n */\nfunction jwkToPkcs1(jwk) {\n    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    const root = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n        value: [\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer({ value: 0 }),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.n, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.e, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.d, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.p, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.q, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.dp, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.dq, 'base64url'))),\n            asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.qi, 'base64url')))\n        ]\n    });\n    const der = root.toBER();\n    return new Uint8Array(der, 0, der.byteLength);\n}\n/**\n * Convert a PKCIX in ASN1 DER format to a JWK key\n */\nfunction pkixToJwk(bytes) {\n    const { result } = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(bytes);\n    // @ts-expect-error this looks fragile but DER is a canonical format so we are\n    // safe to have deeply property chains like this\n    const values = result.valueBlock.value[1].valueBlock.value[0].valueBlock.value;\n    return {\n        kty: 'RSA',\n        n: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[0].toBigInt()), 'base64url'),\n        e: (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bnToBuf(values[1].toBigInt()), 'base64url')\n    };\n}\n/**\n * Convert a JWK key to PKCIX in ASN1 DER format\n */\nfunction jwkToPkix(jwk) {\n    if (jwk.n == null || jwk.e == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    const root = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n        value: [\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                value: [\n                    // rsaEncryption\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({\n                        value: '1.2.840.113549.1.1.1'\n                    }),\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.Null()\n                ]\n            }),\n            // this appears to be a bug in asn1js.js - this should really be a Sequence\n            // and not a BitString but it generates the same bytes as node-forge so \n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.BitString({\n                valueHex: new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                    value: [\n                        asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.n, 'base64url'))),\n                        asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer.fromBigInt(bufToBn((0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(jwk.e, 'base64url')))\n                    ]\n                }).toBER()\n            })\n        ]\n    });\n    const der = root.toBER();\n    return new Uint8Array(der, 0, der.byteLength);\n}\nfunction bnToBuf(bn) {\n    let hex = bn.toString(16);\n    if (hex.length % 2 > 0) {\n        hex = `0${hex}`;\n    }\n    const len = hex.length / 2;\n    const u8 = new Uint8Array(len);\n    let i = 0;\n    let j = 0;\n    while (i < len) {\n        u8[i] = parseInt(hex.slice(j, j + 2), 16);\n        i += 1;\n        j += 2;\n    }\n    return u8;\n}\nfunction bufToBn(u8) {\n    const hex = [];\n    u8.forEach(function (i) {\n        let h = i.toString(16);\n        if (h.length % 2 > 0) {\n            h = `0${h}`;\n        }\n        hex.push(h);\n    });\n    return BigInt('0x' + hex.join(''));\n}\nconst SALT_LENGTH = 16;\nconst KEY_SIZE = 32;\nconst ITERATIONS = 10000;\nasync function exportToPem(privateKey, password) {\n    const crypto = _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get();\n    // PrivateKeyInfo\n    const keyWrapper = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n        value: [\n            // version (0)\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer({ value: 0 }),\n            // privateKeyAlgorithm\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                value: [\n                    // rsaEncryption OID\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({\n                        value: '1.2.840.113549.1.1.1'\n                    }),\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.Null()\n                ]\n            }),\n            // PrivateKey\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({\n                valueHex: privateKey.marshal()\n            })\n        ]\n    });\n    const keyBuf = keyWrapper.toBER();\n    const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);\n    const salt = (0,_random_bytes_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(SALT_LENGTH);\n    const encryptionKey = await (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_6__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__.sha512, password, salt, {\n        c: ITERATIONS,\n        dkLen: KEY_SIZE\n    });\n    const iv = (0,_random_bytes_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(16);\n    const cryptoKey = await crypto.subtle.importKey('raw', encryptionKey, 'AES-CBC', false, ['encrypt']);\n    const encrypted = await crypto.subtle.encrypt({\n        name: 'AES-CBC',\n        iv\n    }, cryptoKey, keyArr);\n    const pbkdf2Params = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n        value: [\n            // salt\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({ valueHex: salt }),\n            // iteration count\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer({ value: ITERATIONS }),\n            // key length\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Integer({ value: KEY_SIZE }),\n            // AlgorithmIdentifier\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                value: [\n                    // hmacWithSHA512\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({ value: '1.2.840.113549.2.11' }),\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.Null()\n                ]\n            })\n        ]\n    });\n    const encryptionAlgorithm = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n        value: [\n            // pkcs5PBES2\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({\n                value: '1.2.840.113549.1.5.13'\n            }),\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                value: [\n                    // keyDerivationFunc\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                        value: [\n                            // pkcs5PBKDF2\n                            new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({\n                                value: '1.2.840.113549.1.5.12'\n                            }),\n                            // PBKDF2-params\n                            pbkdf2Params\n                        ]\n                    }),\n                    // encryptionScheme\n                    new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n                        value: [\n                            // aes256-CBC\n                            new asn1js__WEBPACK_IMPORTED_MODULE_0__.ObjectIdentifier({\n                                value: '2.16.840.1.101.3.4.1.42'\n                            }),\n                            // iv\n                            new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({\n                                valueHex: iv\n                            })\n                        ]\n                    })\n                ]\n            })\n        ]\n    });\n    const finalWrapper = new asn1js__WEBPACK_IMPORTED_MODULE_0__.Sequence({\n        value: [\n            encryptionAlgorithm,\n            new asn1js__WEBPACK_IMPORTED_MODULE_0__.OctetString({ valueHex: encrypted })\n        ]\n    });\n    const finalWrapperBuf = finalWrapper.toBER();\n    const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);\n    return [\n        '-----BEGIN ENCRYPTED PRIVATE KEY-----',\n        ...(0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(finalWrapperArr, 'base64pad').split(/(.{64})/).filter(Boolean),\n        '-----END ENCRYPTED PRIVATE KEY-----'\n    ].join('\\n');\n}\nasync function importFromPem(pem, password) {\n    const crypto = _webcrypto_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get();\n    let plaintext;\n    if (pem.includes('-----BEGIN ENCRYPTED PRIVATE KEY-----')) {\n        const key = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(pem\n            .replace('-----BEGIN ENCRYPTED PRIVATE KEY-----', '')\n            .replace('-----END ENCRYPTED PRIVATE KEY-----', '')\n            .replace(/\\n/g, '')\n            .trim(), 'base64pad');\n        const { result } = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(key);\n        const { iv, salt, iterations, keySize, cipherText } = findEncryptedPEMData(result);\n        const encryptionKey = await (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_6__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__.sha512, password, salt, {\n            c: iterations,\n            dkLen: keySize\n        });\n        const cryptoKey = await crypto.subtle.importKey('raw', encryptionKey, 'AES-CBC', false, ['decrypt']);\n        const decrypted = toUint8Array(await crypto.subtle.decrypt({\n            name: 'AES-CBC',\n            iv\n        }, cryptoKey, cipherText));\n        const { result: decryptedResult } = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(decrypted);\n        plaintext = findPEMData(decryptedResult);\n    }\n    else if (pem.includes('-----BEGIN PRIVATE KEY-----')) {\n        const key = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(pem\n            .replace('-----BEGIN PRIVATE KEY-----', '')\n            .replace('-----END PRIVATE KEY-----', '')\n            .replace(/\\n/g, '')\n            .trim(), 'base64pad');\n        const { result } = asn1js__WEBPACK_IMPORTED_MODULE_0__.fromBER(key);\n        plaintext = findPEMData(result);\n    }\n    else {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('Could not parse private key from PEM data', 'ERR_INVALID_PARAMETERS');\n    }\n    return (0,_rsa_class_js__WEBPACK_IMPORTED_MODULE_8__.unmarshalRsaPrivateKey)(plaintext);\n}\nfunction findEncryptedPEMData(root) {\n    const encryptionAlgorithm = root.valueBlock.value[0];\n    const scheme = encryptionAlgorithm.valueBlock.value[0].toString();\n    if (scheme !== 'OBJECT IDENTIFIER : 1.2.840.113549.1.5.13') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('Only pkcs5PBES2 encrypted private keys are supported', 'ERR_INVALID_PARAMS');\n    }\n    const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];\n    const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();\n    if (keyDerivationFuncName !== 'OBJECT IDENTIFIER : 1.2.840.113549.1.5.12') {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('Only pkcs5PBKDF2 key derivation functions are supported', 'ERR_INVALID_PARAMS');\n    }\n    const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];\n    const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());\n    let iterations = ITERATIONS;\n    let keySize = KEY_SIZE;\n    if (pbkdf2Params.valueBlock.value.length === 3) {\n        iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());\n        keySize = Number((pbkdf2Params.valueBlock.value[2]).toBigInt());\n    }\n    else if (pbkdf2Params.valueBlock.value.length === 2) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key', 'ERR_INVALID_PARAMS');\n    }\n    const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];\n    const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();\n    if (encryptionSchemeName === 'OBJECT IDENTIFIER : 1.2.840.113549.3.7') {\n        // des-EDE3-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 1.3.14.3.2.7') {\n        // des-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2') {\n        // aes128-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22') {\n        // aes192-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42') {\n        // aes256-CBC\n    }\n    else {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError('Only AES-CBC encryption schemes are supported', 'ERR_INVALID_PARAMS');\n    }\n    const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());\n    return {\n        cipherText: toUint8Array(root.valueBlock.value[1].getValue()),\n        salt,\n        iterations,\n        keySize,\n        iv\n    };\n}\nfunction findPEMData(seq) {\n    return toUint8Array(seq.valueBlock.value[2].getValue());\n}\nfunction toUint8Array(buf) {\n    return new Uint8Array(buf, 0, buf.byteLength);\n}\n//# sourceMappingURL=rsa-utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compressPublicKey: () => (/* binding */ compressPublicKey),\n/* harmony export */   computePublicKey: () => (/* binding */ computePublicKey),\n/* harmony export */   decompressPublicKey: () => (/* binding */ decompressPublicKey),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hashAndSign: () => (/* binding */ hashAndSign),\n/* harmony export */   hashAndVerify: () => (/* binding */ hashAndVerify),\n/* harmony export */   privateKeyLength: () => (/* binding */ PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   validatePrivateKey: () => (/* binding */ validatePrivateKey),\n/* harmony export */   validatePublicKey: () => (/* binding */ validatePublicKey)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ \"./node_modules/@libp2p/crypto/dist/src/util.js\");\n\n\n\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32;\n\nfunction generateKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.utils.randomPrivateKey();\n}\n/**\n * Hash and sign message with private key\n */\nfunction hashAndSign(key, msg) {\n    const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isPromise)(p)) {\n        return p.then(({ digest }) => _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.sign(digest, key).toDERRawBytes())\n            .catch(err => {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_INPUT');\n        });\n    }\n    try {\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.sign(p.digest, key).toDERRawBytes();\n    }\n    catch (err) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_INPUT');\n    }\n}\n/**\n * Hash message and verify signature with public key\n */\nfunction hashAndVerify(key, sig, msg) {\n    const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isPromise)(p)) {\n        return p.then(({ digest }) => _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.verify(sig, digest, key))\n            .catch(err => {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_INPUT');\n        });\n    }\n    try {\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.verify(sig, p.digest, key);\n    }\n    catch (err) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_INPUT');\n    }\n}\nfunction compressPublicKey(key) {\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);\n    return point;\n}\nfunction decompressPublicKey(key) {\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(key).toRawBytes(false);\n    return point;\n}\nfunction validatePrivateKey(key) {\n    try {\n        _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.getPublicKey(key, true);\n    }\n    catch (err) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n    }\n}\nfunction validatePublicKey(key) {\n    try {\n        _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(key);\n    }\n    catch (err) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY');\n    }\n}\nfunction computePublicKey(privateKey) {\n    try {\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.getPublicKey(privateKey, true);\n    }\n    catch (err) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_3__.CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n    }\n}\n//# sourceMappingURL=secp256k1-browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Secp256k1PrivateKey: () => (/* binding */ Secp256k1PrivateKey),\n/* harmony export */   Secp256k1PublicKey: () => (/* binding */ Secp256k1PublicKey),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   unmarshalSecp256k1PrivateKey: () => (/* binding */ unmarshalSecp256k1PrivateKey),\n/* harmony export */   unmarshalSecp256k1PublicKey: () => (/* binding */ unmarshalSecp256k1PublicKey)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ \"./node_modules/@libp2p/crypto/dist/src/util.js\");\n/* harmony import */ var _exporter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./exporter.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/exporter.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/keys.js\");\n/* harmony import */ var _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./secp256k1.js */ \"./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-browser.js\");\n\n\n\n\n\n\n\n\nclass Secp256k1PublicKey {\n    _key;\n    constructor(key) {\n        _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.validatePublicKey(key);\n        this._key = key;\n    }\n    verify(data, sig) {\n        return _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.hashAndVerify(this._key, sig, data);\n    }\n    marshal() {\n        return _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.compressPublicKey(this._key);\n    }\n    get bytes() {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_4__.PublicKey.encode({\n            Type: _keys_js__WEBPACK_IMPORTED_MODULE_4__.KeyType.Secp256k1,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__.equals)(this.bytes, key.bytes);\n    }\n    async hash() {\n        const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256.digest(this.bytes);\n        let bytes;\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_5__.isPromise)(p)) {\n            ({ bytes } = await p);\n        }\n        else {\n            bytes = p.bytes;\n        }\n        return bytes;\n    }\n}\nclass Secp256k1PrivateKey {\n    _key;\n    _publicKey;\n    constructor(key, publicKey) {\n        this._key = key;\n        this._publicKey = publicKey ?? _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.computePublicKey(key);\n        _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.validatePrivateKey(this._key);\n        _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.validatePublicKey(this._publicKey);\n    }\n    sign(message) {\n        return _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.hashAndSign(this._key, message);\n    }\n    get public() {\n        return new Secp256k1PublicKey(this._publicKey);\n    }\n    marshal() {\n        return this._key;\n    }\n    get bytes() {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_4__.PrivateKey.encode({\n            Type: _keys_js__WEBPACK_IMPORTED_MODULE_4__.KeyType.Secp256k1,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_1__.equals)(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256.digest(this.bytes);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_5__.isPromise)(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     */\n    async id() {\n        const hash = await this.public.hash();\n        return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(hash, 'base58btc');\n    }\n    /**\n     * Exports the key into a password protected `format`\n     */\n    async export(password, format = 'libp2p-key') {\n        if (format === 'libp2p-key') {\n            return (0,_exporter_js__WEBPACK_IMPORTED_MODULE_6__.exporter)(this.bytes, password);\n        }\n        else {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n        }\n    }\n}\nfunction unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n}\nfunction unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n}\nasync function generateKeyPair() {\n    const privateKeyBytes = _secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.generateKey();\n    return new Secp256k1PrivateKey(privateKeyBytes);\n}\n//# sourceMappingURL=secp256k1-class.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/random-bytes.js":
/*!**************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/random-bytes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ randomBytes)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nfunction randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_0__.CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH');\n    }\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(length);\n}\n//# sourceMappingURL=random-bytes.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/random-bytes.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/util.js":
/*!******************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/util.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64urlToBuffer: () => (/* binding */ base64urlToBuffer),\n/* harmony export */   isPromise: () => (/* binding */ isPromise)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n\n\nfunction base64urlToBuffer(str, len) {\n    let buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(str, 'base64urlpad');\n    if (len != null) {\n        if (buf.length > len)\n            throw new Error('byte array longer than desired length');\n        buf = (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_0__.concat)([new Uint8Array(len - buf.length), buf]);\n    }\n    return buf;\n}\nfunction isPromise(thing) {\n    if (thing == null) {\n        return false;\n    }\n    return typeof thing.then === 'function' &&\n        typeof thing.catch === 'function' &&\n        typeof thing.finally === 'function';\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/util.js?");

/***/ }),

/***/ "./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-env browser */\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    get(win = globalThis) {\n        const nativeCrypto = win.crypto;\n        if (nativeCrypto == null || nativeCrypto.subtle == null) {\n            throw Object.assign(new Error('Missing Web Crypto API. ' +\n                'The most likely cause of this error is that this page is being accessed ' +\n                'from an insecure context (i.e. not HTTPS). For more information and ' +\n                'possible resolutions see ' +\n                'https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api'), { code: 'ERR_MISSING_WEB_CRYPTO' });\n        }\n        return nativeCrypto;\n    }\n});\n//# sourceMappingURL=webcrypto-browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/content-routing/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/content-routing/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   contentRoutingSymbol: () => (/* binding */ contentRoutingSymbol)\n/* harmony export */ });\n/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nconst contentRoutingSymbol = Symbol.for('@libp2p/content-routing');\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/content-routing/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/errors.js":
/*!***********************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/errors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AggregateCodeError: () => (/* binding */ AggregateCodeError),\n/* harmony export */   CodeError: () => (/* binding */ CodeError),\n/* harmony export */   ERR_INVALID_MESSAGE: () => (/* binding */ ERR_INVALID_MESSAGE),\n/* harmony export */   ERR_INVALID_PARAMETERS: () => (/* binding */ ERR_INVALID_PARAMETERS),\n/* harmony export */   ERR_NOT_FOUND: () => (/* binding */ ERR_NOT_FOUND),\n/* harmony export */   ERR_TIMEOUT: () => (/* binding */ ERR_TIMEOUT),\n/* harmony export */   InvalidCryptoExchangeError: () => (/* binding */ InvalidCryptoExchangeError),\n/* harmony export */   InvalidCryptoTransmissionError: () => (/* binding */ InvalidCryptoTransmissionError),\n/* harmony export */   UnexpectedPeerError: () => (/* binding */ UnexpectedPeerError)\n/* harmony export */ });\n/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nclass AbortError extends Error {\n    code;\n    type;\n    constructor(message = 'The operation was aborted') {\n        super(message);\n        this.name = 'AbortError';\n        this.code = AbortError.code;\n        this.type = AbortError.type;\n    }\n    static code = 'ABORT_ERR';\n    static type = 'aborted';\n}\nclass CodeError extends Error {\n    code;\n    props;\n    constructor(message, code, props) {\n        super(message);\n        this.code = code;\n        this.name = props?.name ?? 'CodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nclass AggregateCodeError extends AggregateError {\n    code;\n    props;\n    constructor(errors, message, code, props) {\n        super(errors, message);\n        this.code = code;\n        this.name = props?.name ?? 'AggregateCodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nclass UnexpectedPeerError extends Error {\n    code;\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.name = 'UnexpectedPeerError';\n        this.code = UnexpectedPeerError.code;\n    }\n    static code = 'ERR_UNEXPECTED_PEER';\n}\nclass InvalidCryptoExchangeError extends Error {\n    code;\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.name = 'InvalidCryptoExchangeError';\n        this.code = InvalidCryptoExchangeError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_EXCHANGE';\n}\nclass InvalidCryptoTransmissionError extends Error {\n    code;\n    constructor(message = 'Invalid crypto transmission') {\n        super(message);\n        this.name = 'InvalidCryptoTransmissionError';\n        this.code = InvalidCryptoTransmissionError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_TRANSMISSION';\n}\n// Error codes\nconst ERR_TIMEOUT = 'ERR_TIMEOUT';\nconst ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS';\nconst ERR_NOT_FOUND = 'ERR_NOT_FOUND';\nconst ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE';\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/event-target.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/event-target.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomEvent: () => (/* binding */ CustomEvent),\n/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@libp2p/interface/dist/src/events.js\");\n\n/**\n * An implementation of a typed event target\n * etc\n */\nclass TypedEventEmitter extends EventTarget {\n    #listeners = new Map();\n    constructor() {\n        super();\n        // silence MaxListenersExceededWarning warning on Node.js, this is a red\n        // herring almost all of the time\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.setMaxListeners)(Infinity, this);\n    }\n    listenerCount(type) {\n        const listeners = this.#listeners.get(type);\n        if (listeners == null) {\n            return 0;\n        }\n        return listeners.length;\n    }\n    addEventListener(type, listener, options) {\n        super.addEventListener(type, listener, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            list = [];\n            this.#listeners.set(type, list);\n        }\n        list.push({\n            callback: listener,\n            once: (options !== true && options !== false && options?.once) ?? false\n        });\n    }\n    removeEventListener(type, listener, options) {\n        super.removeEventListener(type.toString(), listener ?? null, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            return;\n        }\n        list = list.filter(({ callback }) => callback !== listener);\n        this.#listeners.set(type, list);\n    }\n    dispatchEvent(event) {\n        const result = super.dispatchEvent(event);\n        let list = this.#listeners.get(event.type);\n        if (list == null) {\n            return result;\n        }\n        list = list.filter(({ once }) => !once);\n        this.#listeners.set(event.type, list);\n        return result;\n    }\n    safeDispatchEvent(type, detail = {}) {\n        return this.dispatchEvent(new CustomEvent(type, detail));\n    }\n}\n/**\n * CustomEvent is a standard event but it's not supported by node.\n *\n * Remove this when https://github.com/nodejs/node/issues/40678 is closed.\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n */\nclass CustomEventPolyfill extends Event {\n    /** Returns any custom data event was created with. Typically used for synthetic events. */\n    detail;\n    constructor(message, data) {\n        super(message, data);\n        // @ts-expect-error could be undefined\n        this.detail = data?.detail;\n    }\n}\nconst CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;\n//# sourceMappingURL=event-target.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/event-target.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/events.browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/events.browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setMaxListeners: () => (/* binding */ setMaxListeners)\n/* harmony export */ });\n/** Noop for browser compatibility */\nfunction setMaxListeners() { }\n//# sourceMappingURL=events.browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/events.browser.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/events.js":
/*!***********************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/events.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setMaxListeners: () => (/* binding */ setMaxListeners)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/@libp2p/interface/dist/src/events.browser.js\");\n\n// create a setMaxListeners that doesn't break browser usage\nconst setMaxListeners = (n, ...eventTargets) => {\n    try {\n        (0,events__WEBPACK_IMPORTED_MODULE_0__.setMaxListeners)(n, ...eventTargets);\n    }\n    catch {\n        // swallow error, gulp\n    }\n};\n//# sourceMappingURL=events.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/events.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/peer-id/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/peer-id/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPeerId: () => (/* binding */ isPeerId),\n/* harmony export */   peerIdSymbol: () => (/* binding */ peerIdSymbol)\n/* harmony export */ });\nconst peerIdSymbol = Symbol.for('@libp2p/peer-id');\nfunction isPeerId(other) {\n    return other != null && Boolean(other[peerIdSymbol]);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/peer-id/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/peer-routing/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/peer-routing/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   peerRoutingSymbol: () => (/* binding */ peerRoutingSymbol)\n/* harmony export */ });\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nconst peerRoutingSymbol = Symbol.for('@libp2p/peer-routing');\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/peer-routing/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/startable.js":
/*!**************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/startable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isStartable: () => (/* binding */ isStartable),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   stop: () => (/* binding */ stop)\n/* harmony export */ });\nfunction isStartable(obj) {\n    return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function';\n}\nasync function start(...objs) {\n    const startables = [];\n    for (const obj of objs) {\n        if (isStartable(obj)) {\n            startables.push(obj);\n        }\n    }\n    await Promise.all(startables.map(async (s) => {\n        if (s.beforeStart != null) {\n            await s.beforeStart();\n        }\n    }));\n    await Promise.all(startables.map(async (s) => {\n        await s.start();\n    }));\n    await Promise.all(startables.map(async (s) => {\n        if (s.afterStart != null) {\n            await s.afterStart();\n        }\n    }));\n}\nasync function stop(...objs) {\n    const startables = [];\n    for (const obj of objs) {\n        if (isStartable(obj)) {\n            startables.push(obj);\n        }\n    }\n    await Promise.all(startables.map(async (s) => {\n        if (s.beforeStop != null) {\n            await s.beforeStop();\n        }\n    }));\n    await Promise.all(startables.map(async (s) => {\n        await s.stop();\n    }));\n    await Promise.all(startables.map(async (s) => {\n        if (s.afterStop != null) {\n            await s.afterStop();\n        }\n    }));\n}\n//# sourceMappingURL=startable.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/startable.js?");

/***/ }),

/***/ "./node_modules/@libp2p/peer-collections/dist/src/set.js":
/*!***************************************************************!*\
  !*** ./node_modules/@libp2p/peer-collections/dist/src/set.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PeerSet: () => (/* binding */ PeerSet),\n/* harmony export */   peerSet: () => (/* binding */ peerSet)\n/* harmony export */ });\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/peer-id */ \"./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@libp2p/peer-collections/dist/src/util.js\");\n\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nclass PeerSet {\n    set;\n    constructor(set) {\n        this.set = new Set();\n        if (set != null) {\n            for (const key of set) {\n                this.set.add(key.toString());\n            }\n        }\n    }\n    get size() {\n        return this.set.size;\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n    add(peer) {\n        this.set.add(peer.toString());\n    }\n    clear() {\n        this.set.clear();\n    }\n    delete(peer) {\n        this.set.delete(peer.toString());\n    }\n    entries() {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.mapIterable)(this.set.entries(), (val) => {\n            const peerId = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(val[0]);\n            return [peerId, peerId];\n        });\n    }\n    forEach(predicate) {\n        this.set.forEach((str) => {\n            const id = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(str);\n            predicate(id, id, this);\n        });\n    }\n    has(peer) {\n        return this.set.has(peer.toString());\n    }\n    values() {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.mapIterable)(this.set.values(), (val) => {\n            return (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(val);\n        });\n    }\n    intersection(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            if (this.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    difference(other) {\n        const output = new PeerSet();\n        for (const peerId of this) {\n            if (!other.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    union(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            output.add(peerId);\n        }\n        for (const peerId of this) {\n            output.add(peerId);\n        }\n        return output;\n    }\n}\nfunction peerSet() {\n    return new PeerSet();\n}\n//# sourceMappingURL=set.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/peer-collections/dist/src/set.js?");

/***/ }),

/***/ "./node_modules/@libp2p/peer-collections/dist/src/util.js":
/*!****************************************************************!*\
  !*** ./node_modules/@libp2p/peer-collections/dist/src/util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapIterable: () => (/* binding */ mapIterable)\n/* harmony export */ });\n/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nfunction mapIterable(iter, map) {\n    const iterator = {\n        [Symbol.iterator]: () => {\n            return iterator;\n        },\n        next: () => {\n            const next = iter.next();\n            const val = next.value;\n            if (next.done === true || val == null) {\n                const result = {\n                    done: true,\n                    value: undefined\n                };\n                return result;\n            }\n            return {\n                done: false,\n                value: map(val)\n            };\n        }\n    };\n    return iterator;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/peer-collections/dist/src/util.js?");

/***/ }),

/***/ "./node_modules/@libp2p/peer-id/dist/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@libp2p/peer-id/dist/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPeerId: () => (/* binding */ createPeerId),\n/* harmony export */   peerIdFromBytes: () => (/* binding */ peerIdFromBytes),\n/* harmony export */   peerIdFromCID: () => (/* binding */ peerIdFromCID),\n/* harmony export */   peerIdFromKeys: () => (/* binding */ peerIdFromKeys),\n/* harmony export */   peerIdFromPeerId: () => (/* binding */ peerIdFromPeerId),\n/* harmony export */   peerIdFromString: () => (/* binding */ peerIdFromString)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/peer-id/index.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/basics */ \"./node_modules/multiformats/dist/src/basics.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/digest */ \"./node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/hashes/identity */ \"./node_modules/multiformats/dist/src/hashes/identity.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\n\n\n\n\n\n\n\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(multiformats_basics__WEBPACK_IMPORTED_MODULE_1__.bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), multiformats_basics__WEBPACK_IMPORTED_MODULE_1__.bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [_libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.peerIdSymbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id == null) {\n            return false;\n        }\n        if (id instanceof Uint8Array) {\n            return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__.equals)(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__.equals)(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```TypeScript\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nfunction createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nfunction peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nfunction peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.decode(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nfunction peerIdFromBytes(buf) {\n    try {\n        const multihash = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.decode(buf);\n        if (multihash.code === multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__.sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nfunction peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__.sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nasync function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.create(multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.create(multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_4__.identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__.sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/peer-id/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/queue/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/queue/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/event-target.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var race_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! race-event */ \"./node_modules/race-event/dist/src/index.js\");\n/* harmony import */ var _job_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job.js */ \"./node_modules/@libp2p/utils/dist/src/queue/job.js\");\n\n\n\n\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n */\nclass Queue extends _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    concurrency;\n    queue;\n    pending;\n    constructor(init = {}) {\n        super();\n        this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;\n        this.pending = 0;\n        if (init.metricName != null) {\n            init.metrics?.registerMetricGroup(init.metricName, {\n                calculate: () => {\n                    return {\n                        size: this.queue.length,\n                        running: this.pending,\n                        queued: this.queue.length - this.pending\n                    };\n                }\n            });\n        }\n        this.queue = [];\n    }\n    tryToStartAnother() {\n        if (this.size === 0) {\n            // do this in the microtask queue so all job recipients receive the\n            // result before the \"empty\" event fires\n            queueMicrotask(() => {\n                this.safeDispatchEvent('empty');\n            });\n            if (this.running === 0) {\n                // do this in the microtask queue so all job recipients receive the\n                // result before the \"idle\" event fires\n                queueMicrotask(() => {\n                    this.safeDispatchEvent('idle');\n                });\n            }\n            return false;\n        }\n        if (this.pending < this.concurrency) {\n            let job;\n            for (const j of this.queue) {\n                if (j.status === 'queued') {\n                    job = j;\n                    break;\n                }\n            }\n            if (job == null) {\n                return false;\n            }\n            this.safeDispatchEvent('active');\n            this.pending++;\n            job.run()\n                .finally(() => {\n                // remove the job from the queue\n                for (let i = 0; i < this.queue.length; i++) {\n                    if (this.queue[i] === job) {\n                        this.queue.splice(i, 1);\n                        break;\n                    }\n                }\n                this.pending--;\n                this.tryToStartAnother();\n                this.safeDispatchEvent('next');\n            });\n            return true;\n        }\n        return false;\n    }\n    enqueue(job) {\n        if (this.queue[this.size - 1]?.priority >= job.priority) {\n            this.queue.push(job);\n            return;\n        }\n        const index = lowerBound(this.queue, job, (a, b) => b.priority - a.priority);\n        this.queue.splice(index, 0, job);\n    }\n    /**\n     * Adds a sync or async task to the queue. Always returns a promise.\n     */\n    async add(fn, options) {\n        options?.signal?.throwIfAborted();\n        const job = new _job_js__WEBPACK_IMPORTED_MODULE_3__.Job(fn, options, options?.priority);\n        const p = job.join(options)\n            .then(result => {\n            this.safeDispatchEvent('completed', { detail: result });\n            return result;\n        })\n            .catch(err => {\n            this.safeDispatchEvent('error', { detail: err });\n            throw err;\n        });\n        this.enqueue(job);\n        this.safeDispatchEvent('add');\n        this.tryToStartAnother();\n        return p;\n    }\n    /**\n     * Clear the queue\n     */\n    clear() {\n        this.queue.splice(0, this.queue.length);\n    }\n    /**\n     * Abort all jobs in the queue and clear it\n     */\n    abort() {\n        this.queue.forEach(job => {\n            job.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.AbortError());\n        });\n        this.clear();\n    }\n    /**\n     * Can be called multiple times. Useful if you for example add additional items at a later time.\n     *\n     * @returns A promise that settles when the queue becomes empty.\n     */\n    async onEmpty(options) {\n        // Instantly resolve if the queue is empty\n        if (this.size === 0) {\n            return;\n        }\n        await (0,race_event__WEBPACK_IMPORTED_MODULE_1__.raceEvent)(this, 'empty', options?.signal);\n    }\n    /**\n     * @returns A promise that settles when the queue size is less than the given\n     * limit: `queue.size < limit`.\n     *\n     * If you want to avoid having the queue grow beyond a certain size you can\n     * `await queue.onSizeLessThan()` before adding a new item.\n     *\n     * Note that this only limits the number of items waiting to start. There\n     * could still be up to `concurrency` jobs already running that this call does\n     * not include in its calculation.\n     */\n    async onSizeLessThan(limit, options) {\n        // Instantly resolve if the queue is empty.\n        if (this.size < limit) {\n            return;\n        }\n        await (0,race_event__WEBPACK_IMPORTED_MODULE_1__.raceEvent)(this, 'next', options?.signal, {\n            filter: () => this.size < limit\n        });\n    }\n    /**\n     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n     * from the queue has finished. `.onEmpty` merely signals that the queue is\n     * empty, but it could mean that some promises haven't completed yet.\n     *\n     * @returns A promise that settles when the queue becomes empty, and all\n     * promises have completed; `queue.size === 0 && queue.pending === 0`.\n     */\n    async onIdle(options) {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.pending === 0 && this.size === 0) {\n            return;\n        }\n        await (0,race_event__WEBPACK_IMPORTED_MODULE_1__.raceEvent)(this, 'idle', options?.signal);\n    }\n    /**\n     * Size of the queue including running items\n     */\n    get size() {\n        return this.queue.length;\n    }\n    /**\n     * The number of queued items waiting to run.\n     */\n    get queued() {\n        return this.queue.length - this.pending;\n    }\n    /**\n     * The number of items currently running.\n     */\n    get running() {\n        return this.pending;\n    }\n    /**\n     * Returns an async generator that makes it easy to iterate over the results\n     * of jobs added to the queue.\n     *\n     * The generator will end when the queue becomes idle, that is there are no\n     * jobs running and no jobs that have yet to run.\n     *\n     * If you need to keep the queue open indefinitely, consider using it-pushable\n     * instead.\n     */\n    async *toGenerator(options) {\n        options?.signal?.throwIfAborted();\n        const stream = (0,it_pushable__WEBPACK_IMPORTED_MODULE_0__.pushable)({\n            objectMode: true\n        });\n        const cleanup = (err) => {\n            if (err != null) {\n                this.abort();\n            }\n            else {\n                this.clear();\n            }\n            stream.end(err);\n        };\n        const onQueueJobComplete = (evt) => {\n            if (evt.detail != null) {\n                stream.push(evt.detail);\n            }\n        };\n        const onQueueError = (evt) => {\n            cleanup(evt.detail);\n        };\n        const onQueueIdle = () => {\n            cleanup();\n        };\n        // clear the queue and throw if the query is aborted\n        const onSignalAbort = () => {\n            cleanup(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError('Queue aborted', 'ERR_QUEUE_ABORTED'));\n        };\n        // add listeners\n        this.addEventListener('completed', onQueueJobComplete);\n        this.addEventListener('error', onQueueError);\n        this.addEventListener('idle', onQueueIdle);\n        options?.signal?.addEventListener('abort', onSignalAbort);\n        try {\n            yield* stream;\n        }\n        finally {\n            // remove listeners\n            this.removeEventListener('completed', onQueueJobComplete);\n            this.removeEventListener('error', onQueueError);\n            this.removeEventListener('idle', onQueueIdle);\n            options?.signal?.removeEventListener('abort', onSignalAbort);\n            // empty the queue for when the user has broken out of a loop early\n            cleanup();\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/queue/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/queue/job.js":
/*!**********************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/queue/job.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Job: () => (/* binding */ Job)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/events.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var race_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! race-signal */ \"./node_modules/race-signal/dist/src/index.js\");\n/* harmony import */ var _recipient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recipient.js */ \"./node_modules/@libp2p/utils/dist/src/queue/recipient.js\");\n\n\n\n/**\n * Returns a random string\n */\nfunction randomId() {\n    return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`;\n}\nclass Job {\n    id;\n    fn;\n    options;\n    priority;\n    recipients;\n    status;\n    timeline;\n    controller;\n    constructor(fn, options, priority = 0) {\n        this.id = randomId();\n        this.status = 'queued';\n        this.fn = fn;\n        this.priority = priority;\n        this.options = options;\n        this.recipients = [];\n        this.timeline = {\n            created: Date.now()\n        };\n        this.controller = new AbortController();\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.setMaxListeners)(Infinity, this.controller.signal);\n        this.onAbort = this.onAbort.bind(this);\n    }\n    abort(err) {\n        this.controller.abort(err);\n    }\n    onAbort() {\n        const allAborted = this.recipients.reduce((acc, curr) => {\n            return acc && (curr.signal?.aborted === true);\n        }, true);\n        // if all recipients have aborted the job, actually abort the job\n        if (allAborted) {\n            this.controller.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.AbortError());\n        }\n    }\n    async join(options = {}) {\n        const recipient = new _recipient_js__WEBPACK_IMPORTED_MODULE_3__.JobRecipient((new Error('where')).stack, options.signal);\n        this.recipients.push(recipient);\n        options.signal?.addEventListener('abort', this.onAbort);\n        return recipient.deferred.promise;\n    }\n    async run() {\n        this.status = 'running';\n        this.timeline.started = Date.now();\n        try {\n            this.controller.signal.throwIfAborted();\n            const result = await (0,race_signal__WEBPACK_IMPORTED_MODULE_0__.raceSignal)(this.fn({\n                ...(this.options ?? {}),\n                signal: this.controller.signal\n            }), this.controller.signal);\n            this.recipients.forEach(recipient => {\n                recipient.deferred.resolve(result);\n            });\n            this.status = 'complete';\n        }\n        catch (err) {\n            this.recipients.forEach(recipient => {\n                recipient.deferred.reject(err);\n            });\n            this.status = 'errored';\n        }\n        finally {\n            this.timeline.finished = Date.now();\n            this.cleanup();\n        }\n    }\n    cleanup() {\n        this.recipients.forEach(recipient => {\n            recipient.signal?.removeEventListener('abort', this.onAbort);\n        });\n    }\n}\n//# sourceMappingURL=job.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/queue/job.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/queue/recipient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/queue/recipient.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobRecipient: () => (/* binding */ JobRecipient)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var p_defer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-defer */ \"./node_modules/p-defer/index.js\");\n\n\nclass JobRecipient {\n    deferred;\n    signal;\n    where;\n    constructor(where, signal) {\n        this.signal = signal;\n        this.deferred = (0,p_defer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        this.where = where;\n        this.onAbort = this.onAbort.bind(this);\n        this.signal?.addEventListener('abort', this.onAbort);\n    }\n    onAbort() {\n        this.deferred.reject(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.AbortError());\n    }\n    cleanup() {\n        this.signal?.removeEventListener('abort', this.onAbort);\n    }\n}\n//# sourceMappingURL=recipient.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/queue/recipient.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/tracked-map.js":
/*!************************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/tracked-map.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trackedMap: () => (/* binding */ trackedMap)\n/* harmony export */ });\nclass TrackedMap extends Map {\n    metric;\n    constructor(init) {\n        super();\n        const { name, metrics } = init;\n        this.metric = metrics.registerMetric(name);\n        this.updateComponentMetric();\n    }\n    set(key, value) {\n        super.set(key, value);\n        this.updateComponentMetric();\n        return this;\n    }\n    delete(key) {\n        const deleted = super.delete(key);\n        this.updateComponentMetric();\n        return deleted;\n    }\n    clear() {\n        super.clear();\n        this.updateComponentMetric();\n    }\n    updateComponentMetric() {\n        this.metric.update(this.size);\n    }\n}\nfunction trackedMap(config) {\n    const { name, metrics } = config;\n    let map;\n    if (metrics != null) {\n        map = new TrackedMap({ name, metrics });\n    }\n    else {\n        map = new Map();\n    }\n    return map;\n}\n//# sourceMappingURL=tracked-map.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/tracked-map.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/dns.js":
/*!********************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/dns.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS)\n/* harmony export */ });\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _resolvers_default_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolvers/default.js */ \"./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js\");\n/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/cache.js */ \"./node_modules/@multiformats/dns/dist/src/utils/cache.js\");\n/* harmony import */ var _utils_get_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/get-types.js */ \"./node_modules/@multiformats/dns/dist/src/utils/get-types.js\");\n\n\n\n\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000;\nclass DNS {\n    resolvers;\n    cache;\n    constructor(init) {\n        this.resolvers = {};\n        this.cache = (0,_utils_cache_js__WEBPACK_IMPORTED_MODULE_2__.cache)(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);\n        Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n            if (!Array.isArray(resolver)) {\n                resolver = [resolver];\n            }\n            // convert `com` -> `com.`\n            if (!tld.endsWith('.')) {\n                tld = `${tld}.`;\n            }\n            this.resolvers[tld] = resolver;\n        });\n        // configure default resolver if none specified\n        if (this.resolvers['.'] == null) {\n            this.resolvers['.'] = (0,_resolvers_default_js__WEBPACK_IMPORTED_MODULE_1__.defaultResolver)();\n        }\n    }\n    /**\n     * Queries DNS resolvers for the passed record types for the passed domain.\n     *\n     * If cached records exist for all desired types they will be returned\n     * instead.\n     *\n     * Any new responses will be added to the cache for subsequent requests.\n     */\n    async query(domain, options = {}) {\n        const types = (0,_utils_get_types_js__WEBPACK_IMPORTED_MODULE_3__.getTypes)(options.types);\n        const cached = options.cached !== false ? this.cache.get(domain, types) : undefined;\n        if (cached != null) {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:cache', { detail: cached }));\n            return cached;\n        }\n        const tld = `${domain.split('.').pop()}.`;\n        const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n            return (Math.random() > 0.5) ? -1 : 1;\n        });\n        const errors = [];\n        for (const resolver of resolvers) {\n            // skip further resolutions if the user aborted the signal\n            if (options.signal?.aborted === true) {\n                break;\n            }\n            try {\n                const result = await resolver(domain, {\n                    ...options,\n                    types\n                });\n                for (const answer of result.Answer) {\n                    this.cache.add(domain, answer);\n                }\n                return result;\n            }\n            catch (err) {\n                errors.push(err);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:error', { detail: err }));\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);\n    }\n}\n//# sourceMappingURL=dns.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/dns.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_RECURSIVE_DEPTH: () => (/* binding */ MAX_RECURSIVE_DEPTH),\n/* harmony export */   RecordType: () => (/* binding */ RecordType),\n/* harmony export */   dns: () => (/* binding */ dns)\n/* harmony export */ });\n/* harmony import */ var _dns_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dns.js */ \"./node_modules/@multiformats/dns/dist/src/dns.js\");\n/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\n\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nvar RecordType;\n(function (RecordType) {\n    RecordType[RecordType[\"A\"] = 1] = \"A\";\n    RecordType[RecordType[\"CNAME\"] = 5] = \"CNAME\";\n    RecordType[RecordType[\"TXT\"] = 16] = \"TXT\";\n    RecordType[RecordType[\"AAAA\"] = 28] = \"AAAA\";\n})(RecordType || (RecordType = {}));\n/**\n * The default maximum amount of recursion allowed during a query\n */\nconst MAX_RECURSIVE_DEPTH = 32;\nfunction dns(init = {}) {\n    return new _dns_js__WEBPACK_IMPORTED_MODULE_0__.DNS(init);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultResolver: () => (/* binding */ defaultResolver)\n/* harmony export */ });\n/* harmony import */ var _dns_json_over_https_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dns-json-over-https.js */ \"./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js\");\n\nfunction defaultResolver() {\n    return [\n        (0,_dns_json_over_https_js__WEBPACK_IMPORTED_MODULE_0__.dnsJsonOverHttps)('https://cloudflare-dns.com/dns-query'),\n        (0,_dns_json_over_https_js__WEBPACK_IMPORTED_MODULE_0__.dnsJsonOverHttps)('https://dns.google/resolve')\n    ];\n}\n//# sourceMappingURL=default.browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_QUERY_CONCURRENCY: () => (/* binding */ DEFAULT_QUERY_CONCURRENCY),\n/* harmony export */   dnsJsonOverHttps: () => (/* binding */ dnsJsonOverHttps)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n/* harmony import */ var _utils_get_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/get-types.js */ \"./node_modules/@multiformats/dns/dist/src/utils/get-types.js\");\n/* harmony import */ var _utils_to_dns_response_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/to-dns-response.js */ \"./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js\");\n/* eslint-env browser */\n\n\n\n\n\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nconst DEFAULT_QUERY_CONCURRENCY = 4;\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nfunction dnsJsonOverHttps(url, init = {}) {\n    const httpQueue = new p_queue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n        concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n    });\n    return async (fqdn, options = {}) => {\n        const searchParams = new URLSearchParams();\n        searchParams.set('name', fqdn);\n        (0,_utils_get_types_js__WEBPACK_IMPORTED_MODULE_2__.getTypes)(options.types).forEach(type => {\n            // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n            searchParams.append('type', _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[type]);\n        });\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:query', { detail: fqdn }));\n        // query DNS-JSON over HTTPS server\n        const response = await httpQueue.add(async () => {\n            const res = await fetch(`${url}?${searchParams}`, {\n                headers: {\n                    accept: 'application/dns-json'\n                },\n                signal: options?.signal\n            });\n            if (res.status !== 200) {\n                throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);\n            }\n            const response = (0,_utils_to_dns_response_js__WEBPACK_IMPORTED_MODULE_3__.toDNSResponse)(await res.json());\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:response', { detail: response }));\n            return response;\n        }, {\n            signal: options.signal\n        });\n        if (response == null) {\n            throw new Error('No DNS response received');\n        }\n        return response;\n    };\n}\n//# sourceMappingURL=dns-json-over-https.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/utils/cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/utils/cache.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cache: () => (/* binding */ cache)\n/* harmony export */ });\n/* harmony import */ var hashlru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hashlru */ \"./node_modules/hashlru/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n/* harmony import */ var _to_dns_response_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./to-dns-response.js */ \"./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js\");\n\n\n\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n    lru;\n    constructor(maxSize) {\n        this.lru = hashlru__WEBPACK_IMPORTED_MODULE_0__(maxSize);\n    }\n    get(fqdn, types) {\n        let foundAllAnswers = true;\n        const answers = [];\n        for (const type of types) {\n            const cached = this.getAnswers(fqdn, type);\n            if (cached.length === 0) {\n                foundAllAnswers = false;\n                break;\n            }\n            answers.push(...cached);\n        }\n        if (foundAllAnswers) {\n            return (0,_to_dns_response_js__WEBPACK_IMPORTED_MODULE_2__.toDNSResponse)({ answers });\n        }\n    }\n    getAnswers(domain, type) {\n        const key = `${domain.toLowerCase()}-${type}`;\n        const answers = this.lru.get(key);\n        if (answers != null) {\n            const cachedAnswers = answers\n                .filter((entry) => {\n                return entry.expires > Date.now();\n            })\n                .map(({ expires, value }) => ({\n                ...value,\n                TTL: Math.round((expires - Date.now()) / 1000),\n                type: _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[value.type]\n            }));\n            if (cachedAnswers.length === 0) {\n                this.lru.remove(key);\n            }\n            // @ts-expect-error hashlru stringifies stored types which turns enums\n            // into strings, we convert back into enums above but tsc doesn't know\n            return cachedAnswers;\n        }\n        return [];\n    }\n    add(domain, answer) {\n        const key = `${domain.toLowerCase()}-${answer.type}`;\n        const answers = this.lru.get(key) ?? [];\n        answers.push({\n            expires: Date.now() + ((answer.TTL ?? _to_dns_response_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_TTL) * 1000),\n            value: answer\n        });\n        this.lru.set(key, answers);\n    }\n    remove(domain, type) {\n        const key = `${domain.toLowerCase()}-${type}`;\n        this.lru.remove(key);\n    }\n    clear() {\n        this.lru.clear();\n    }\n}\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nfunction cache(size) {\n    return new CachedAnswers(size);\n}\n//# sourceMappingURL=cache.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/utils/cache.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/utils/get-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/utils/get-types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTypes: () => (/* binding */ getTypes)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n\nfunction getTypes(types) {\n    const DEFAULT_TYPES = [\n        _index_js__WEBPACK_IMPORTED_MODULE_0__.RecordType.A\n    ];\n    if (types == null) {\n        return DEFAULT_TYPES;\n    }\n    if (Array.isArray(types)) {\n        if (types.length === 0) {\n            return DEFAULT_TYPES;\n        }\n        return types;\n    }\n    return [\n        types\n    ];\n}\n//# sourceMappingURL=get-types.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/utils/get-types.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TTL: () => (/* binding */ DEFAULT_TTL),\n/* harmony export */   toDNSResponse: () => (/* binding */ toDNSResponse)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n\n\n/**\n * This TTL will be used if the remote service does not return one\n */\nconst DEFAULT_TTL = 60;\nfunction toDNSResponse(obj) {\n    return {\n        Status: obj.Status ?? 0,\n        TC: obj.TC ?? obj.flag_tc ?? false,\n        RD: obj.RD ?? obj.flag_rd ?? false,\n        RA: obj.RA ?? obj.flag_ra ?? false,\n        AD: obj.AD ?? obj.flag_ad ?? false,\n        CD: obj.CD ?? obj.flag_cd ?? false,\n        Question: (obj.Question ?? obj.questions ?? []).map((question) => {\n            return {\n                name: question.name,\n                type: _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[question.type]\n            };\n        }),\n        Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {\n            return {\n                name: answer.name,\n                type: _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[answer.type],\n                TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n                data: answer.data instanceof Uint8Array ? (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_0__.toString)(answer.data) : answer.data\n            };\n        })\n    };\n}\n//# sourceMappingURL=to-dns-response.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/codec.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/codec.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParseError: () => (/* binding */ ParseError),\n/* harmony export */   bytesToMultiaddrParts: () => (/* binding */ bytesToMultiaddrParts),\n/* harmony export */   bytesToTuples: () => (/* binding */ bytesToTuples),\n/* harmony export */   cleanPath: () => (/* binding */ cleanPath),\n/* harmony export */   stringToMultiaddrParts: () => (/* binding */ stringToMultiaddrParts),\n/* harmony export */   tuplesToBytes: () => (/* binding */ tuplesToBytes)\n/* harmony export */ });\n/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8-varint */ \"./node_modules/uint8-varint/dist/src/index.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./convert.js */ \"./node_modules/@multiformats/multiaddr/dist/src/convert.js\");\n/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./protocols-table.js */ \"./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js\");\n\n\n\n\n\nfunction stringToMultiaddrParts(str) {\n    str = cleanPath(str);\n    const tuples = [];\n    const stringTuples = [];\n    let path = null;\n    const parts = str.split('/').slice(1);\n    if (parts.length === 1 && parts[0] === '') {\n        return {\n            bytes: new Uint8Array(),\n            string: '/',\n            tuples: [],\n            stringTuples: [],\n            path: null\n        };\n    }\n    for (let p = 0; p < parts.length; p++) {\n        const part = parts[p];\n        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(part);\n        if (proto.size === 0) {\n            tuples.push([proto.code]);\n            stringTuples.push([proto.code]);\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        p++; // advance addr part\n        if (p >= parts.length) {\n            throw ParseError('invalid address: ' + str);\n        }\n        // if it's a path proto, take the rest\n        if (proto.path === true) {\n            // should we need to check each path part to see if it's a proto?\n            // This would allow for other protocols to be added after a unix path,\n            // however it would have issues if the path had a protocol name in the path\n            path = cleanPath(parts.slice(p).join('/'));\n            tuples.push([proto.code, (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToBytes)(proto.code, path)]);\n            stringTuples.push([proto.code, path]);\n            break;\n        }\n        const bytes = (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToBytes)(proto.code, parts[p]);\n        tuples.push([proto.code, bytes]);\n        stringTuples.push([proto.code, (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToString)(proto.code, bytes)]);\n    }\n    return {\n        string: stringTuplesToString(stringTuples),\n        bytes: tuplesToBytes(tuples),\n        tuples,\n        stringTuples,\n        path\n    };\n}\nfunction bytesToMultiaddrParts(bytes) {\n    const tuples = [];\n    const stringTuples = [];\n    let path = null;\n    let i = 0;\n    while (i < bytes.length) {\n        const code = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.decode(bytes, i);\n        const n = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code);\n        const p = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(code);\n        const size = sizeForAddr(p, bytes.slice(i + n));\n        if (size === 0) {\n            tuples.push([code]);\n            stringTuples.push([code]);\n            i += n;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const addr = bytes.slice(i + n, i + n + size);\n        i += (size + n);\n        if (i > bytes.length) { // did not end _exactly_ at buffer.length\n            throw ParseError('Invalid address Uint8Array: ' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bytes, 'base16'));\n        }\n        // ok, tuple seems good.\n        tuples.push([code, addr]);\n        const stringAddr = (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToString)(code, addr);\n        stringTuples.push([code, stringAddr]);\n        if (p.path === true) {\n            // should we need to check each path part to see if it's a proto?\n            // This would allow for other protocols to be added after a unix path,\n            // however it would have issues if the path had a protocol name in the path\n            path = stringAddr;\n            break;\n        }\n    }\n    return {\n        bytes: Uint8Array.from(bytes),\n        string: stringTuplesToString(stringTuples),\n        tuples,\n        stringTuples,\n        path\n    };\n}\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString(tuples) {\n    const parts = [];\n    tuples.map((tup) => {\n        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(tup[0]);\n        parts.push(proto.name);\n        if (tup.length > 1 && tup[1] != null) {\n            parts.push(tup[1]);\n        }\n        return null;\n    });\n    return cleanPath(parts.join('/'));\n}\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nfunction tuplesToBytes(tuples) {\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(tuples.map((tup) => {\n        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(tup[0]);\n        let buf = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encode(proto.code));\n        if (tup.length > 1 && tup[1] != null) {\n            buf = (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)([buf, tup[1]]); // add address buffer\n        }\n        return buf;\n    }));\n}\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr(p, addr) {\n    if (p.size > 0) {\n        return p.size / 8;\n    }\n    else if (p.size === 0) {\n        return 0;\n    }\n    else {\n        const size = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));\n        return size + uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(size);\n    }\n}\nfunction bytesToTuples(buf) {\n    const tuples = [];\n    let i = 0;\n    while (i < buf.length) {\n        const code = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.decode(buf, i);\n        const n = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code);\n        const p = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(code);\n        const size = sizeForAddr(p, buf.slice(i + n));\n        if (size === 0) {\n            tuples.push([code]);\n            i += n;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const addr = buf.slice(i + n, i + n + size);\n        i += (size + n);\n        if (i > buf.length) { // did not end _exactly_ at buffer.length\n            throw ParseError('Invalid address Uint8Array: ' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(buf, 'base16'));\n        }\n        // ok, tuple seems good.\n        tuples.push([code, addr]);\n    }\n    return tuples;\n}\nfunction cleanPath(str) {\n    return '/' + str.trim().split('/').filter((a) => a).join('/');\n}\nfunction ParseError(str) {\n    return new Error('Error parsing address: ' + str);\n}\n//# sourceMappingURL=codec.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/codec.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/convert.js":
/*!******************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/convert.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   convertToBytes: () => (/* binding */ convertToBytes),\n/* harmony export */   convertToIpNet: () => (/* binding */ convertToIpNet),\n/* harmony export */   convertToString: () => (/* binding */ convertToString)\n/* harmony export */ });\n/* harmony import */ var _chainsafe_netmask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/netmask */ \"./node_modules/@chainsafe/netmask/dist/src/index.js\");\n/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/bases/base32 */ \"./node_modules/multiformats/dist/src/bases/base32.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/basics */ \"./node_modules/multiformats/dist/src/basics.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/hashes/digest */ \"./node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8-varint */ \"./node_modules/uint8-varint/dist/src/index.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ip.js */ \"./node_modules/@multiformats/multiaddr/dist/src/ip.js\");\n/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./protocols-table.js */ \"./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js\");\n/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst ip4Protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)('ip4');\nconst ip6Protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)('ip6');\nconst ipcidrProtocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)('ipcidr');\nfunction convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nfunction convertToString(proto, buf) {\n    const protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(buf, 'base16'); // no clue. convert to hex\n    }\n}\nfunction convertToBytes(proto, str) {\n    const protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_8__.fromString)(str, 'base16'); // no clue. convert from hex\n    }\n}\nfunction convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new _chainsafe_netmask__WEBPACK_IMPORTED_MODULE_0__.IpNet(addr, mask);\n}\nconst decoders = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_3__.bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!_ip_js__WEBPACK_IMPORTED_MODULE_10__.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return _ip_js__WEBPACK_IMPORTED_MODULE_10__.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = _ip_js__WEBPACK_IMPORTED_MODULE_10__.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!_ip_js__WEBPACK_IMPORTED_MODULE_10__.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_8__.fromString)(str);\n    const size = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encode(buf.length));\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = uint8_varint__WEBPACK_IMPORTED_MODULE_6__.decode(buf);\n    buf = buf.slice(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_5__.decode(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__.base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = multiformats_cid__WEBPACK_IMPORTED_MODULE_4__.CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encode(mh.length));\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encode(mb.length));\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = uint8_varint__WEBPACK_IMPORTED_MODULE_6__.decode(buf);\n    const hash = buf.slice(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = uint8_varint__WEBPACK_IMPORTED_MODULE_6__.decode(buf);\n    const address = buf.slice(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_1__.base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_1__.base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/convert.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiaddrFilter: () => (/* binding */ MultiaddrFilter)\n/* harmony export */ });\n/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../convert.js */ \"./node_modules/@multiformats/multiaddr/dist/src/convert.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n\n\n/**\n * A utility class to determine if a Multiaddr contains another\n * multiaddr.\n *\n * This can be used with ipcidr ranges to determine if a given\n * multiaddr is in a ipcidr range.\n *\n * @example\n *\n * ```js\n * import { multiaddr, MultiaddrFilter } from '@multiformats/multiaddr'\n *\n * const range = multiaddr('/ip4/192.168.10.10/ipcidr/24')\n * const filter = new MultiaddrFilter(range)\n *\n * const input = multiaddr('/ip4/192.168.10.2/udp/60')\n * console.info(filter.contains(input)) // true\n * ```\n */\nclass MultiaddrFilter {\n    multiaddr;\n    netmask;\n    constructor(input) {\n        this.multiaddr = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.multiaddr)(input);\n        this.netmask = (0,_convert_js__WEBPACK_IMPORTED_MODULE_0__.convertToIpNet)(this.multiaddr);\n    }\n    contains(input) {\n        if (input == null)\n            return false;\n        const m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.multiaddr)(input);\n        let ip;\n        for (const [code, value] of m.stringTuples()) {\n            if (code === 4 || code === 41) {\n                ip = value;\n                break;\n            }\n        }\n        if (ip === undefined)\n            return false;\n        return this.netmask.contains(ip);\n    }\n}\n//# sourceMappingURL=multiaddr-filter.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiaddrFilter: () => (/* reexport safe */ _filter_multiaddr_filter_js__WEBPACK_IMPORTED_MODULE_2__.MultiaddrFilter),\n/* harmony export */   fromNodeAddress: () => (/* binding */ fromNodeAddress),\n/* harmony export */   isMultiaddr: () => (/* binding */ isMultiaddr),\n/* harmony export */   isName: () => (/* binding */ isName),\n/* harmony export */   multiaddr: () => (/* binding */ multiaddr),\n/* harmony export */   protocols: () => (/* reexport safe */ _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol),\n/* harmony export */   resolvers: () => (/* binding */ resolvers)\n/* harmony export */ });\n/* harmony import */ var _multiaddr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./multiaddr.js */ \"./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js\");\n/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocols-table.js */ \"./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js\");\n/* harmony import */ var _filter_multiaddr_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter/multiaddr-filter.js */ \"./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js\");\n/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * const addr =  multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * const addr = multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddr } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddr)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(await ma.resolve(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\n\n\n/**\n * All configured {@link Resolver}s\n */\nconst resolvers = new Map();\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nfunction fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new _multiaddr_js__WEBPACK_IMPORTED_MODULE_0__.Multiaddr('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nfunction isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nfunction isMultiaddr(value) {\n    return Boolean(value?.[_multiaddr_js__WEBPACK_IMPORTED_MODULE_0__.symbol]);\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nfunction multiaddr(addr) {\n    return new _multiaddr_js__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(addr);\n}\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isIP: () => (/* reexport safe */ _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__.isIP),\n/* harmony export */   isV4: () => (/* binding */ isV4),\n/* harmony export */   isV6: () => (/* binding */ isV6),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip */ \"./node_modules/@chainsafe/is-ip/lib/is-ip.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n\n\n\nconst isV4 = _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__.isIPv4;\nconst isV6 = _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__.isIPv6;\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nconst toBytes = function (ip) {\n    let offset = 0;\n    ip = ip.toString().trim();\n    if (isV4(ip)) {\n        const bytes = new Uint8Array(offset + 4);\n        ip.split(/\\./g).forEach((byte) => {\n            bytes[offset++] = parseInt(byte, 10) & 0xff;\n        });\n        return bytes;\n    }\n    if (isV6(ip)) {\n        const sections = ip.split(':', 8);\n        let i;\n        for (i = 0; i < sections.length; i++) {\n            const isv4 = isV4(sections[i]);\n            let v4Buffer;\n            if (isv4) {\n                v4Buffer = toBytes(sections[i]);\n                sections[i] = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(v4Buffer.slice(0, 2), 'base16');\n            }\n            if (v4Buffer != null && ++i < 8) {\n                sections.splice(i, 0, (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(v4Buffer.slice(2, 4), 'base16'));\n            }\n        }\n        if (sections[0] === '') {\n            while (sections.length < 8)\n                sections.unshift('0');\n        }\n        else if (sections[sections.length - 1] === '') {\n            while (sections.length < 8)\n                sections.push('0');\n        }\n        else if (sections.length < 8) {\n            for (i = 0; i < sections.length && sections[i] !== ''; i++)\n                ;\n            const argv = [i, 1];\n            for (i = 9 - sections.length; i > 0; i--) {\n                argv.push('0');\n            }\n            sections.splice.apply(sections, argv);\n        }\n        const bytes = new Uint8Array(offset + 16);\n        for (i = 0; i < sections.length; i++) {\n            const word = parseInt(sections[i], 16);\n            bytes[offset++] = (word >> 8) & 0xff;\n            bytes[offset++] = word & 0xff;\n        }\n        return bytes;\n    }\n    throw new Error('invalid ip address');\n};\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nconst toString = function (buf, offset = 0, length) {\n    offset = ~~offset;\n    length = length ?? (buf.length - offset);\n    const view = new DataView(buf.buffer);\n    if (length === 4) {\n        const result = [];\n        // IPv4\n        for (let i = 0; i < length; i++) {\n            result.push(buf[offset + i]);\n        }\n        return result.join('.');\n    }\n    if (length === 16) {\n        const result = [];\n        // IPv6\n        for (let i = 0; i < length; i += 2) {\n            result.push(view.getUint16(offset + i).toString(16));\n        }\n        return result.join(':')\n            .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n            .replace(/:{3,4}/, '::');\n    }\n    return '';\n};\n//# sourceMappingURL=ip.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/ip.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js":
/*!********************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Multiaddr: () => (/* binding */ Multiaddr),\n/* harmony export */   symbol: () => (/* binding */ symbol)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./codec.js */ \"./node_modules/@multiformats/multiaddr/dist/src/codec.js\");\n/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./protocols-table.js */ \"./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@multiformats/multiaddr/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\n\n\n\n\n\n\n\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nconst DNS_CODES = [\n    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns').code,\n    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns4').code,\n    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns6').code,\n    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dnsaddr').code\n];\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nclass Multiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.bytesToMultiaddrParts)(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.stringToMultiaddrParts)(addr);\n        }\n        else if ((0,_index_js__WEBPACK_IMPORTED_MODULE_6__.isMultiaddr)(addr)) { // Multiaddr\n            parts = (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.bytesToMultiaddrParts)(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('tcp');\n        const udp = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('udp');\n        const ip4 = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('ip4');\n        const ip6 = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('ip6');\n        const dns6 = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns6');\n        const ip6zone = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new Multiaddr(addr);\n        return new Multiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new Multiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new Multiaddr((0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.tuplesToBytes)(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === _protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === _protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__.equals)(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = _index_js__WEBPACK_IMPORTED_MODULE_6__.resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const result = await resolver(this, options);\n        return result.map(str => (0,_index_js__WEBPACK_IMPORTED_MODULE_6__.multiaddr)(str));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n//# sourceMappingURL=multiaddr.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js?");

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codes: () => (/* binding */ codes),\n/* harmony export */   createProtocol: () => (/* binding */ createProtocol),\n/* harmony export */   getProtocol: () => (/* binding */ getProtocol),\n/* harmony export */   names: () => (/* binding */ names),\n/* harmony export */   table: () => (/* binding */ table)\n/* harmony export */ });\nconst V = -1;\nconst names = {};\nconst codes = {};\nconst table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nfunction createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nfunction getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/_shortw_utils.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/curve.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/edwards.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax + y = 1 + dxy\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax + y = 1 + dxy\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X\n            const Y2 = modP(Y * Y); // Y\n            const Z2 = modP(Z * Z); // Z\n            const Z4 = modP(Z2 * Z2); // Z\n            const aX2 = modP(X2 * a); // aX\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/edwards.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/modular.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!***************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === 'bigint' && _0n <= n && n < P)\n            return n;\n        throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/montgomery.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/utils.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/abstract/weierstrass.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/ed25519.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/curves/esm/ed25519.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"./node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"./node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n        x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n};\nconst ed25519 = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n});\nconst ed25519ph = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n});\nconst x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/ed25519.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/curves/esm/secp256k1.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/_assert.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/_md.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/_u64.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/crypto.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/hmac.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/pbkdf2.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/pbkdf2.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/sha256.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/sha512.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@noble/hashes/esm/utils.js?");

/***/ }),

/***/ "./node_modules/any-signal/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/any-signal/dist/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anySignal: () => (/* binding */ anySignal)\n/* harmony export */ });\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nfunction anySignal(signals) {\n    const controller = new globalThis.AbortController();\n    function onAbort() {\n        controller.abort();\n        for (const signal of signals) {\n            if (signal?.removeEventListener != null) {\n                signal.removeEventListener('abort', onAbort);\n            }\n        }\n    }\n    for (const signal of signals) {\n        if (signal?.aborted === true) {\n            onAbort();\n            break;\n        }\n        if (signal?.addEventListener != null) {\n            signal.addEventListener('abort', onAbort);\n        }\n    }\n    function clear() {\n        for (const signal of signals) {\n            if (signal?.removeEventListener != null) {\n                signal.removeEventListener('abort', onAbort);\n            }\n        }\n    }\n    const signal = controller.signal;\n    signal.clear = clear;\n    return signal;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/any-signal/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/base.js":
/*!*******************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/base.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseBlockstore: () => (/* binding */ BaseBlockstore)\n/* harmony export */ });\nclass BaseBlockstore {\n    has(key, options) {\n        return Promise.reject(new Error('.has is not implemented'));\n    }\n    put(key, val, options) {\n        return Promise.reject(new Error('.put is not implemented'));\n    }\n    async *putMany(source, options) {\n        for await (const { cid, block } of source) {\n            await this.put(cid, block, options);\n            yield cid;\n        }\n    }\n    get(key, options) {\n        return Promise.reject(new Error('.get is not implemented'));\n    }\n    async *getMany(source, options) {\n        for await (const key of source) {\n            yield {\n                cid: key,\n                block: await this.get(key, options)\n            };\n        }\n    }\n    delete(key, options) {\n        return Promise.reject(new Error('.delete is not implemented'));\n    }\n    async *deleteMany(source, options) {\n        for await (const key of source) {\n            await this.delete(key, options);\n            yield key;\n        }\n    }\n    /**\n     * Extending classes should override `query` or implement this method\n     */\n    async *getAll(options) {\n        throw new Error('.getAll is not implemented');\n    }\n}\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/base.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/black-hole.js":
/*!*************************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/black-hole.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlackHoleBlockstore: () => (/* binding */ BlackHoleBlockstore)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n\n\nclass BlackHoleBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseBlockstore {\n    put(key) {\n        return key;\n    }\n    get() {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.notFoundError();\n    }\n    has() {\n        return false;\n    }\n    async delete() {\n    }\n    async *getAll() {\n    }\n}\n//# sourceMappingURL=black-hole.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/black-hole.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abortedError: () => (/* binding */ abortedError),\n/* harmony export */   closeFailedError: () => (/* binding */ closeFailedError),\n/* harmony export */   deleteFailedError: () => (/* binding */ deleteFailedError),\n/* harmony export */   getFailedError: () => (/* binding */ getFailedError),\n/* harmony export */   hasFailedError: () => (/* binding */ hasFailedError),\n/* harmony export */   notFoundError: () => (/* binding */ notFoundError),\n/* harmony export */   openFailedError: () => (/* binding */ openFailedError),\n/* harmony export */   putFailedError: () => (/* binding */ putFailedError)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n\nfunction openFailedError(err) {\n    err = err ?? new Error('Open failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_OPEN_FAILED');\n}\nfunction closeFailedError(err) {\n    err = err ?? new Error('Close failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_CLOSE_FAILED');\n}\nfunction putFailedError(err) {\n    err = err ?? new Error('Put failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_PUT_FAILED');\n}\nfunction getFailedError(err) {\n    err = err ?? new Error('Get failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_GET_FAILED');\n}\nfunction deleteFailedError(err) {\n    err = err ?? new Error('Delete failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DELETE_FAILED');\n}\nfunction hasFailedError(err) {\n    err = err ?? new Error('Has failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_HAS_FAILED');\n}\nfunction notFoundError(err) {\n    err = err ?? new Error('Not Found');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_NOT_FOUND');\n}\nfunction abortedError(err) {\n    err = err ?? new Error('Aborted');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_ABORTED');\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/identity.js":
/*!***********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/identity.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdentityBlockstore: () => (/* binding */ IdentityBlockstore)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./node_modules/blockstore-core/dist/src/index.js\");\n\n\n// https://github.com/multiformats/multicodec/blob/d06fc6194710e8909bac64273c43f16b56ca4c34/table.csv#L2\nconst IDENTITY_CODEC = 0x00;\nclass IdentityBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseBlockstore {\n    child;\n    constructor(child) {\n        super();\n        this.child = child;\n    }\n    put(key, block) {\n        if (key.multihash.code === IDENTITY_CODEC) {\n            return key;\n        }\n        if (this.child == null) {\n            return key;\n        }\n        return this.child.put(key, block);\n    }\n    get(key) {\n        if (key.multihash.code === IDENTITY_CODEC) {\n            return key.multihash.digest;\n        }\n        if (this.child == null) {\n            throw _index_js__WEBPACK_IMPORTED_MODULE_1__.Errors.notFoundError();\n        }\n        return this.child.get(key);\n    }\n    has(key) {\n        if (key.multihash.code === IDENTITY_CODEC) {\n            return true;\n        }\n        if (this.child == null) {\n            return false;\n        }\n        return this.child.has(key);\n    }\n    delete(key) {\n        if (key.code === IDENTITY_CODEC) {\n            return;\n        }\n        if (this.child != null) {\n            return this.child.delete(key);\n        }\n    }\n    getAll(options) {\n        if (this.child != null) {\n            return this.child.getAll(options);\n        }\n        return [];\n    }\n}\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/identity.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseBlockstore: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseBlockstore),\n/* harmony export */   BlackHoleBlockstore: () => (/* reexport safe */ _black_hole_js__WEBPACK_IMPORTED_MODULE_3__.BlackHoleBlockstore),\n/* harmony export */   Errors: () => (/* binding */ Errors),\n/* harmony export */   MemoryBlockstore: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_2__.MemoryBlockstore),\n/* harmony export */   TieredBlockstore: () => (/* reexport safe */ _tiered_js__WEBPACK_IMPORTED_MODULE_4__.TieredBlockstore)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory.js */ \"./node_modules/blockstore-core/dist/src/memory.js\");\n/* harmony import */ var _black_hole_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./black-hole.js */ \"./node_modules/blockstore-core/dist/src/black-hole.js\");\n/* harmony import */ var _tiered_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tiered.js */ \"./node_modules/blockstore-core/dist/src/tiered.js\");\n/**\n * @packageDocumentation\n *\n * Various Blockstore implementations are available.\n *\n * ## Implementations\n *\n * - Base: [`src/base`](src/base.ts)\n * - Memory: [`src/memory`](src/memory.ts)\n * - BlackHole: ['src/black-hole](src/black-hole.ts)\n * - Tiered: ['src/tiered](src/tiered.ts)\n *\n * @example BaseBlockstore\n *\n * Provides a complete implementation of the Blockstore interface.  You must implement `.get`, `.put`, etc.\n *\n * ```js\n * import { BaseBlockstore } from 'blockstore-core/base'\n *\n * class MyCustomBlockstore extends BaseBlockstore {\n *   put (key, val, options) {\n *     // store a block\n *   }\n *\n *   get (key, options) {\n *     // retrieve a block\n *   }\n *\n *   // ...etc\n * }\n * ```\n *\n * @example MemoryBlockstore\n *\n * A simple Blockstore that stores blocks in memory.\n *\n * ```js\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * const store = new MemoryBlockstore()\n * ```\n *\n * @example BlackHoleBlockstore\n *\n * A Blockstore that does not store any blocks.\n *\n * ```js\n * import { BlackHoleBlockstore } from 'blockstore-core/black-hole'\n *\n * const store = new BlackHoleBlockstore()\n * ```\n *\n * @example TieredBlockstore\n *\n * A tiered blockstore wraps one or more blockstores and will query each in parallel to retrieve a block - the operation will succeed if any wrapped store has the block.\n *\n * Writes are invoked on all wrapped blockstores.\n *\n * ```js\n * import { TieredBlockstore } from 'blockstore-core/tiered'\n *\n * const store = new TieredBlockstore([\n *   store1,\n *   store2,\n *   // ...etc\n * ])\n * ```\n *\n * @example IdentityBlockstore\n *\n * An identity blockstore is one that deals exclusively in Identity CIDs - this is a special CID with the codec [0x00](https://github.com/multiformats/multicodec/blob/d06fc6194710e8909bac64273c43f16b56ca4c34/table.csv#L2) where the multihash digest is the data that makes up the block.\n *\n * ```TypeScript\n * import { IdentityBlockstore } from 'blockstore-core/identity'\n * import { CID } from 'multiformats/cid'\n *\n * const blockstore = new IdentityBlockstore()\n *\n * blockstore.has(CID.parse('QmFoo')) // false\n *\n * blockstore.has(CID.parse('bafkqac3imvwgy3zao5xxe3de')) // true\n * ```\n */\n\n\n\n\n\nconst Errors = {\n    ..._errors_js__WEBPACK_IMPORTED_MODULE_0__\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/memory.js":
/*!*********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/memory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryBlockstore: () => (/* binding */ MemoryBlockstore)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base32 */ \"./node_modules/multiformats/dist/src/bases/base32.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/digest */ \"./node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n\n\n\n\n\n\nclass MemoryBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseBlockstore {\n    data;\n    constructor() {\n        super();\n        this.data = new Map();\n    }\n    put(key, val) {\n        this.data.set(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes), val);\n        return key;\n    }\n    get(key) {\n        const buf = this.data.get(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes));\n        if (buf == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.notFoundError();\n        }\n        return buf;\n    }\n    has(key) {\n        return this.data.has(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes));\n    }\n    async delete(key) {\n        this.data.delete(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes));\n    }\n    async *getAll() {\n        for (const [key, value] of this.data.entries()) {\n            yield {\n                cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.createV1(multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__.code, multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.decode(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.decode(key))),\n                block: value\n            };\n        }\n    }\n}\n//# sourceMappingURL=memory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/memory.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/tiered.js":
/*!*********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/tiered.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TieredBlockstore: () => (/* binding */ TieredBlockstore)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.logger)('blockstore:core:tiered');\n/**\n * A blockstore that can combine multiple stores. Puts and deletes\n * will write through to all blockstores. Has and get will\n * try each store sequentially. getAll will use every store but also\n * deduplicate any yielded pairs.\n */\nclass TieredBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseBlockstore {\n    stores;\n    constructor(stores) {\n        super();\n        this.stores = stores.slice();\n    }\n    async put(key, value, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.put(key, value, options); }));\n            return key;\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.putFailedError(err);\n        }\n    }\n    async get(key, options) {\n        for (const store of this.stores) {\n            try {\n                const res = await store.get(key, options);\n                if (res != null)\n                    return res;\n            }\n            catch (err) {\n                log.error(err);\n            }\n        }\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.notFoundError();\n    }\n    async has(key, options) {\n        for (const s of this.stores) {\n            if (await s.has(key, options)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async delete(key, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.delete(key, options); }));\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.deleteFailedError(err);\n        }\n    }\n    async *putMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_3__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.putMany(source, options))\n                .catch(err => {\n                // store threw while putting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const pair of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(pair));\n                yield pair.cid;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_3__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.deleteMany(source, options))\n                .catch(err => {\n                // store threw while deleting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const key of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(key));\n                yield key;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    async *getAll(options) {\n        // deduplicate yielded pairs\n        const seen = new Set();\n        yield* (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((0,it_merge__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(...this.stores.map(s => s.getAll(options))), (pair) => {\n            const cidStr = pair.cid.toString();\n            if (seen.has(cidStr)) {\n                return false;\n            }\n            seen.add(cidStr);\n            return true;\n        });\n    }\n}\n//# sourceMappingURL=tiered.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/tiered.js?");

/***/ }),

/***/ "./node_modules/browser-readablestream-to-it/dist/src/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/browser-readablestream-to-it/dist/src/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ browserReadableStreamToIt)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * Allows treating a browser readable stream as an async iterator.\n *\n * @example\n *\n * ```javascript\n * import toIt from 'browser-readablestream-to-it'\n * import all from 'it-all'\n *\n * const content = [0, 1, 2, 3, 4]\n *\n * const stream = new ReadableStream({\n *   start(controller) {\n *     for (let i = 0; i < content.length; i++) {\n *       controller.enqueue(content[i])\n *     }\n *\n *     controller.close()\n *   }\n * })\n *\n * const arr = await all(toIt(stream))\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * ## preventCancel\n *\n * By default a readable stream will have [.cancel](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/cancel) called on it once it has ended or\n * reading has stopped prematurely.\n *\n * To prevent this behaviour, pass `preventCancel: true` as an option:\n *\n * ```javascript\n * const arr = await all(toIt(stream, { preventCancel: true }))\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n */\nasync function* browserReadableStreamToIt(stream, options = {}) {\n    const reader = stream.getReader();\n    try {\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                return;\n            }\n            yield result.value;\n        }\n    }\n    finally {\n        if (options.preventCancel !== true) {\n            await reader.cancel();\n        }\n        reader.releaseLock();\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/browser-readablestream-to-it/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/base.js":
/*!******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/base.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDatastore: () => (/* binding */ BaseDatastore)\n/* harmony export */ });\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-sort */ \"./node_modules/it-sort/dist/src/index.js\");\n/* harmony import */ var it_take__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-take */ \"./node_modules/it-take/dist/src/index.js\");\n\n\n\n\nclass BaseDatastore {\n    put(key, val, options) {\n        return Promise.reject(new Error('.put is not implemented'));\n    }\n    get(key, options) {\n        return Promise.reject(new Error('.get is not implemented'));\n    }\n    has(key, options) {\n        return Promise.reject(new Error('.has is not implemented'));\n    }\n    delete(key, options) {\n        return Promise.reject(new Error('.delete is not implemented'));\n    }\n    async *putMany(source, options = {}) {\n        for await (const { key, value } of source) {\n            await this.put(key, value, options);\n            yield key;\n        }\n    }\n    async *getMany(source, options = {}) {\n        for await (const key of source) {\n            yield {\n                key,\n                value: await this.get(key, options)\n            };\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        for await (const key of source) {\n            await this.delete(key, options);\n            yield key;\n        }\n    }\n    batch() {\n        let puts = [];\n        let dels = [];\n        return {\n            put(key, value) {\n                puts.push({ key, value });\n            },\n            delete(key) {\n                dels.push(key);\n            },\n            commit: async (options) => {\n                await (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.putMany(puts, options));\n                puts = [];\n                await (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.deleteMany(dels, options));\n                dels = [];\n            }\n        };\n    }\n    /**\n     * Extending classes should override `query` or implement this method\n     */\n    // eslint-disable-next-line require-yield\n    async *_all(q, options) {\n        throw new Error('._all is not implemented');\n    }\n    /**\n     * Extending classes should override `queryKeys` or implement this method\n     */\n    // eslint-disable-next-line require-yield\n    async *_allKeys(q, options) {\n        throw new Error('._allKeys is not implemented');\n    }\n    query(q, options) {\n        let it = this._all(q, options);\n        if (q.prefix != null) {\n            const prefix = q.prefix;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, (e) => e.key.toString().startsWith(prefix));\n        }\n        if (Array.isArray(q.filters)) {\n            it = q.filters.reduce((it, f) => (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, f), it);\n        }\n        if (Array.isArray(q.orders)) {\n            it = q.orders.reduce((it, f) => (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, f), it);\n        }\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null) {\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        }\n        return it;\n    }\n    queryKeys(q, options) {\n        let it = this._allKeys(q, options);\n        if (q.prefix != null) {\n            const prefix = q.prefix;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, (key) => key.toString().startsWith(prefix));\n        }\n        if (Array.isArray(q.filters)) {\n            it = q.filters.reduce((it, f) => (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, f), it);\n        }\n        if (Array.isArray(q.orders)) {\n            it = q.orders.reduce((it, f) => (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, f), it);\n        }\n        if (q.offset != null) {\n            const offset = q.offset;\n            let i = 0;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null) {\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        }\n        return it;\n    }\n}\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/base.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abortedError: () => (/* binding */ abortedError),\n/* harmony export */   dbDeleteFailedError: () => (/* binding */ dbDeleteFailedError),\n/* harmony export */   dbOpenFailedError: () => (/* binding */ dbOpenFailedError),\n/* harmony export */   dbReadFailedError: () => (/* binding */ dbReadFailedError),\n/* harmony export */   dbWriteFailedError: () => (/* binding */ dbWriteFailedError),\n/* harmony export */   notFoundError: () => (/* binding */ notFoundError)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n\nfunction dbOpenFailedError(err) {\n    err = err ?? new Error('Cannot open database');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_OPEN_FAILED');\n}\nfunction dbDeleteFailedError(err) {\n    err = err ?? new Error('Delete failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_DELETE_FAILED');\n}\nfunction dbWriteFailedError(err) {\n    err = err ?? new Error('Write failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_WRITE_FAILED');\n}\nfunction dbReadFailedError(err) {\n    err = err ?? new Error('Read failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_READ_FAILED');\n}\nfunction notFoundError(err) {\n    err = err ?? new Error('Not Found');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_NOT_FOUND');\n}\nfunction abortedError(err) {\n    err = err ?? new Error('Aborted');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_ABORTED');\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDatastore: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseDatastore),\n/* harmony export */   Errors: () => (/* reexport module object */ _errors_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   KeyTransformDatastore: () => (/* reexport safe */ _keytransform_js__WEBPACK_IMPORTED_MODULE_4__.KeyTransformDatastore),\n/* harmony export */   MemoryDatastore: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_3__.MemoryDatastore),\n/* harmony export */   MountDatastore: () => (/* reexport safe */ _mount_js__WEBPACK_IMPORTED_MODULE_6__.MountDatastore),\n/* harmony export */   NamespaceDatastore: () => (/* reexport safe */ _namespace_js__WEBPACK_IMPORTED_MODULE_8__.NamespaceDatastore),\n/* harmony export */   ShardingDatastore: () => (/* reexport safe */ _sharding_js__WEBPACK_IMPORTED_MODULE_5__.ShardingDatastore),\n/* harmony export */   TieredDatastore: () => (/* reexport safe */ _tiered_js__WEBPACK_IMPORTED_MODULE_7__.TieredDatastore),\n/* harmony export */   shard: () => (/* reexport module object */ _shard_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n/* harmony import */ var _shard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shard.js */ \"./node_modules/datastore-core/dist/src/shard.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./memory.js */ \"./node_modules/datastore-core/dist/src/memory.js\");\n/* harmony import */ var _keytransform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keytransform.js */ \"./node_modules/datastore-core/dist/src/keytransform.js\");\n/* harmony import */ var _sharding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sharding.js */ \"./node_modules/datastore-core/dist/src/sharding.js\");\n/* harmony import */ var _mount_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mount.js */ \"./node_modules/datastore-core/dist/src/mount.js\");\n/* harmony import */ var _tiered_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tiered.js */ \"./node_modules/datastore-core/dist/src/tiered.js\");\n/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./namespace.js */ \"./node_modules/datastore-core/dist/src/namespace.js\");\n/**\n * @packageDocumentation\n *\n * Various Datastore implementations are available.\n *\n * ## Implementations\n *\n * - Mount: [`src/mount`](src/mount.ts)\n * - Keytransform: [`src/keytransform`](src/keytransform.ts)\n * - Sharding: [`src/sharding`](src/sharding.ts)\n * - Tiered: [`src/tiered`](src/tirered.ts)\n * - Namespace: [`src/namespace`](src/namespace.ts)\n * - BlackHole: [`src/black-hole`](src/black-hole.ts)\n *\n * @example BaseDatastore\n *\n * An base store is made available to make implementing your own datastore easier:\n *\n * ```javascript\n * import { BaseDatastore } from 'datastore-core'\n *\n * class MyDatastore extends BaseDatastore {\n *   constructor () {\n *     super()\n *   }\n *\n *   async put (key, val) {\n *     // your implementation here\n *   }\n *\n *   async get (key) {\n *     // your implementation here\n *   }\n *\n *   // etc...\n * }\n * ```\n *\n * See the [MemoryDatastore](./src/memory.js) for an example of how it is used.\n *\n * @example Wrapping Stores\n *\n * ```js\n * import { Key } from 'interface-datastore'\n * import {\n *   MemoryStore,\n *   MountStore\n * } from 'datastore-core'\n *\n * const store = new MountStore({prefix: new Key('/a'), datastore: new MemoryStore()})\n * ```\n *\n * @example BlackHoleDatastore\n *\n * A datastore that does not store any data.\n *\n * ```js\n * import { BlackHoleDatastore } from 'datastore-core/black-hole'\n *\n * const store = new BlackHoleDatastore()\n * ```\n */\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/keytransform.js":
/*!**************************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/keytransform.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyTransformDatastore: () => (/* binding */ KeyTransformDatastore)\n/* harmony export */ });\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n\n\n\n/**\n * A datastore shim, that wraps around a given datastore, changing\n * the way keys look to the user, for example namespacing\n * keys, reversing them, etc.\n */\nclass KeyTransformDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseDatastore {\n    child;\n    transform;\n    constructor(child, transform) {\n        super();\n        this.child = child;\n        this.transform = transform;\n    }\n    async put(key, val, options) {\n        await this.child.put(this.transform.convert(key), val, options);\n        return key;\n    }\n    async get(key, options) {\n        return this.child.get(this.transform.convert(key), options);\n    }\n    async has(key, options) {\n        return this.child.has(this.transform.convert(key), options);\n    }\n    async delete(key, options) {\n        await this.child.delete(this.transform.convert(key), options);\n    }\n    async *putMany(source, options = {}) {\n        const transform = this.transform;\n        const child = this.child;\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_1__.pipe)(source, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, ({ key, value }) => ({\n                key: transform.convert(key),\n                value\n            }));\n        }, async function* (source) {\n            yield* child.putMany(source, options);\n        }, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.invert(key));\n        });\n    }\n    async *getMany(source, options = {}) {\n        const transform = this.transform;\n        const child = this.child;\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_1__.pipe)(source, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.convert(key));\n        }, async function* (source) {\n            yield* child.getMany(source, options);\n        }, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, ({ key, value }) => ({\n                key: transform.invert(key),\n                value\n            }));\n        });\n    }\n    async *deleteMany(source, options = {}) {\n        const transform = this.transform;\n        const child = this.child;\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_1__.pipe)(source, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.convert(key));\n        }, async function* (source) {\n            yield* child.deleteMany(source, options);\n        }, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.invert(key));\n        });\n    }\n    batch() {\n        const b = this.child.batch();\n        return {\n            put: (key, value) => {\n                b.put(this.transform.convert(key), value);\n            },\n            delete: (key) => {\n                b.delete(this.transform.convert(key));\n            },\n            commit: async (options) => {\n                await b.commit(options);\n            }\n        };\n    }\n    query(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return ({ key, value }) => filter({ key: this.transform.convert(key), value });\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push(({ key }) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order({ key: this.transform.invert(a.key), value: a.value }, { key: this.transform.invert(b.key), value: b.value });\n            });\n        }\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.child.query(query, options), ({ key, value }) => {\n            return {\n                key: this.transform.invert(key),\n                value\n            };\n        });\n    }\n    queryKeys(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return (key) => filter(this.transform.convert(key));\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push((key) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order(this.transform.invert(a), this.transform.invert(b));\n            });\n        }\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.child.queryKeys(query, options), key => {\n            return this.transform.invert(key);\n        });\n    }\n}\n//# sourceMappingURL=keytransform.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/keytransform.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/memory.js":
/*!********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/memory.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryDatastore: () => (/* binding */ MemoryDatastore)\n/* harmony export */ });\n/* harmony import */ var interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore/key */ \"./node_modules/interface-datastore/dist/src/key.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n\n\n\nclass MemoryDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseDatastore {\n    data;\n    constructor() {\n        super();\n        this.data = new Map();\n    }\n    put(key, val) {\n        this.data.set(key.toString(), val);\n        return key;\n    }\n    get(key) {\n        const result = this.data.get(key.toString());\n        if (result == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.notFoundError();\n        }\n        return result;\n    }\n    has(key) {\n        return this.data.has(key.toString());\n    }\n    delete(key) {\n        this.data.delete(key.toString());\n    }\n    *_all() {\n        for (const [key, value] of this.data.entries()) {\n            yield { key: new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(key), value };\n        }\n    }\n    *_allKeys() {\n        for (const key of this.data.keys()) {\n            yield new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(key);\n        }\n    }\n}\n//# sourceMappingURL=memory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/memory.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/mount.js":
/*!*******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/mount.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MountDatastore: () => (/* binding */ MountDatastore)\n/* harmony export */ });\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n/* harmony import */ var it_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-sort */ \"./node_modules/it-sort/dist/src/index.js\");\n/* harmony import */ var it_take__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-take */ \"./node_modules/it-take/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n\n\n\n\n\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n */\nclass MountDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseDatastore {\n    mounts;\n    constructor(mounts) {\n        super();\n        this.mounts = mounts.slice();\n    }\n    /**\n     * Lookup the matching datastore for the given key\n     */\n    _lookup(key) {\n        for (const mount of this.mounts) {\n            if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n                return {\n                    datastore: mount.datastore,\n                    mountpoint: mount.prefix\n                };\n            }\n        }\n    }\n    async put(key, value, options) {\n        const match = this._lookup(key);\n        if (match == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.dbWriteFailedError(new Error('No datastore mounted for this key'));\n        }\n        await match.datastore.put(key, value, options);\n        return key;\n    }\n    /**\n     * @param {Key} key\n     * @param {Options} [options]\n     */\n    async get(key, options = {}) {\n        const match = this._lookup(key);\n        if (match == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.notFoundError(new Error('No datastore mounted for this key'));\n        }\n        return match.datastore.get(key, options);\n    }\n    async has(key, options) {\n        const match = this._lookup(key);\n        if (match == null) {\n            return Promise.resolve(false);\n        }\n        return match.datastore.has(key, options);\n    }\n    async delete(key, options) {\n        const match = this._lookup(key);\n        if (match == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n        }\n        await match.datastore.delete(key, options);\n    }\n    batch() {\n        const batchMounts = {};\n        const lookup = (key) => {\n            const match = this._lookup(key);\n            if (match == null) {\n                throw new Error('No datastore mounted for this key');\n            }\n            const m = match.mountpoint.toString();\n            if (batchMounts[m] == null) {\n                batchMounts[m] = match.datastore.batch();\n            }\n            return {\n                batch: batchMounts[m]\n            };\n        };\n        return {\n            put: (key, value) => {\n                const match = lookup(key);\n                match.batch.put(key, value);\n            },\n            delete: (key) => {\n                const match = lookup(key);\n                match.batch.delete(key);\n            },\n            commit: async (options) => {\n                await Promise.all(Object.keys(batchMounts).map(async (p) => { await batchMounts[p].commit(options); }));\n            }\n        };\n    }\n    query(q, options) {\n        const qs = this.mounts.map(m => {\n            return m.datastore.query({\n                prefix: q.prefix,\n                filters: q.filters\n            }, options);\n        });\n        let it = (0,it_merge__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(...qs);\n        if (q.filters != null)\n            q.filters.forEach(f => { it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, f); });\n        if (q.orders != null)\n            q.orders.forEach(o => { it = (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, o); });\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null)\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        return it;\n    }\n    queryKeys(q, options) {\n        const qs = this.mounts.map(m => {\n            return m.datastore.queryKeys({\n                prefix: q.prefix,\n                filters: q.filters\n            }, options);\n        });\n        /** @type AsyncIterable<Key> */\n        let it = (0,it_merge__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(...qs);\n        if (q.filters != null)\n            q.filters.forEach(f => { it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, f); });\n        if (q.orders != null)\n            q.orders.forEach(o => { it = (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, o); });\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null)\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        return it;\n    }\n}\n//# sourceMappingURL=mount.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/mount.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/namespace.js":
/*!***********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/namespace.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NamespaceDatastore: () => (/* binding */ NamespaceDatastore)\n/* harmony export */ });\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var _keytransform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keytransform.js */ \"./node_modules/datastore-core/dist/src/keytransform.js\");\n\n\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n */\nclass NamespaceDatastore extends _keytransform_js__WEBPACK_IMPORTED_MODULE_2__.KeyTransformDatastore {\n    iChild;\n    iKey;\n    constructor(child, prefix) {\n        super(child, {\n            convert(key) {\n                return prefix.child(key);\n            },\n            invert(key) {\n                if (prefix.toString() === '/') {\n                    return key;\n                }\n                if (!prefix.isAncestorOf(key)) {\n                    throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);\n                }\n                return new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key(key.toString().slice(prefix.toString().length), false);\n            }\n        });\n        this.iChild = child;\n        this.iKey = prefix;\n    }\n    query(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return ({ key, value }) => filter({ key: this.transform.invert(key), value });\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push(({ key }) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order({ key: this.transform.invert(a.key), value: a.value }, { key: this.transform.invert(b.key), value: b.value });\n            });\n        }\n        query.filters.unshift(({ key }) => this.iKey.isAncestorOf(key));\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.iChild.query(query, options), ({ key, value }) => {\n            return {\n                key: this.transform.invert(key),\n                value\n            };\n        });\n    }\n    queryKeys(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return (key) => filter(this.transform.invert(key));\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push((key) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order(this.transform.invert(a), this.transform.invert(b));\n            });\n        }\n        query.filters.unshift(key => this.iKey.isAncestorOf(key));\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.iChild.queryKeys(query, options), key => {\n            return this.transform.invert(key);\n        });\n    }\n}\n//# sourceMappingURL=namespace.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/namespace.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/shard.js":
/*!*******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/shard.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NextToLast: () => (/* binding */ NextToLast),\n/* harmony export */   PREFIX: () => (/* binding */ PREFIX),\n/* harmony export */   Prefix: () => (/* binding */ Prefix),\n/* harmony export */   SHARDING_FN: () => (/* binding */ SHARDING_FN),\n/* harmony export */   ShardBase: () => (/* binding */ ShardBase),\n/* harmony export */   Suffix: () => (/* binding */ Suffix),\n/* harmony export */   parseShardFun: () => (/* binding */ parseShardFun),\n/* harmony export */   readShardFun: () => (/* binding */ readShardFun)\n/* harmony export */ });\n/* harmony import */ var interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore/key */ \"./node_modules/interface-datastore/dist/src/key.js\");\n\nconst PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = 'SHARDING';\nclass ShardBase {\n    param;\n    name;\n    _padding;\n    constructor(param) {\n        this.param = param;\n        this.name = 'base';\n        this._padding = '';\n    }\n    fun(s) {\n        return 'implement me';\n    }\n    toString() {\n        return `${PREFIX}v1/${this.name}/${this.param}`;\n    }\n}\nclass Prefix extends ShardBase {\n    constructor(prefixLen) {\n        super(prefixLen);\n        this._padding = ''.padStart(prefixLen, '_');\n        this.name = 'prefix';\n    }\n    fun(noslash) {\n        return (noslash + this._padding).slice(0, this.param);\n    }\n}\nclass Suffix extends ShardBase {\n    constructor(suffixLen) {\n        super(suffixLen);\n        this._padding = ''.padStart(suffixLen, '_');\n        this.name = 'suffix';\n    }\n    fun(noslash) {\n        const s = this._padding + noslash;\n        return s.slice(s.length - this.param);\n    }\n}\nclass NextToLast extends ShardBase {\n    constructor(suffixLen) {\n        super(suffixLen);\n        this._padding = ''.padStart(suffixLen + 1, '_');\n        this.name = 'next-to-last';\n    }\n    fun(noslash) {\n        const s = this._padding + noslash;\n        const offset = s.length - this.param - 1;\n        return s.slice(offset, offset + this.param);\n    }\n}\n/**\n * Convert a given string to the matching sharding function\n */\nfunction parseShardFun(str) {\n    str = str.trim();\n    if (str.length === 0) {\n        throw new Error('empty shard string');\n    }\n    if (!str.startsWith(PREFIX)) {\n        throw new Error(`invalid or no path prefix: ${str}`);\n    }\n    const parts = str.slice(PREFIX.length).split('/');\n    const version = parts[0];\n    if (version !== 'v1') {\n        throw new Error(`expect 'v1' version, got '${version}'`);\n    }\n    const name = parts[1];\n    if (parts[2] == null || parts[2] === '') {\n        throw new Error('missing param');\n    }\n    const param = parseInt(parts[2], 10);\n    switch (name) {\n        case 'prefix':\n            return new Prefix(param);\n        case 'suffix':\n            return new Suffix(param);\n        case 'next-to-last':\n            return new NextToLast(param);\n        default:\n            throw new Error(`unkown sharding function: ${name}`);\n    }\n}\nconst readShardFun = async (path, store) => {\n    const key = new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(path).child(new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(SHARDING_FN));\n    // @ts-expect-error not all stores have this\n    const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n    const res = await get(key);\n    return parseShardFun(new TextDecoder().decode(res ?? '').trim());\n};\n//# sourceMappingURL=shard.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/shard.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/sharding.js":
/*!**********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/sharding.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShardingDatastore: () => (/* binding */ ShardingDatastore)\n/* harmony export */ });\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n/* harmony import */ var _keytransform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keytransform.js */ \"./node_modules/datastore-core/dist/src/keytransform.js\");\n/* harmony import */ var _shard_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shard.js */ \"./node_modules/datastore-core/dist/src/shard.js\");\n\n\n\n\n\nconst shardKey = new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key(_shard_js__WEBPACK_IMPORTED_MODULE_4__.SHARDING_FN);\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseDatastore {\n    child;\n    shard;\n    constructor(store, shard) {\n        super();\n        this.child = new _keytransform_js__WEBPACK_IMPORTED_MODULE_3__.KeyTransformDatastore(store, {\n            convert: this._convertKey.bind(this),\n            invert: this._invertKey.bind(this)\n        });\n        this.shard = shard;\n    }\n    async open() {\n        this.shard = await ShardingDatastore.create(this.child, this.shard);\n    }\n    _convertKey(key) {\n        const s = key.toString();\n        if (s === shardKey.toString()) {\n            return key;\n        }\n        const parent = new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key(this.shard.fun(s));\n        return parent.child(key);\n    }\n    _invertKey(key) {\n        const s = key.toString();\n        if (s === shardKey.toString()) {\n            return key;\n        }\n        return interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key.withNamespaces(key.list().slice(1));\n    }\n    static async create(store, shard) {\n        const hasShard = await store.has(shardKey);\n        if (!hasShard) {\n            if (shard == null) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n            }\n            await store.put(shardKey, new TextEncoder().encode(shard.toString() + '\\n'));\n        }\n        if (shard == null) {\n            shard = await (0,_shard_js__WEBPACK_IMPORTED_MODULE_4__.readShardFun)('/', store);\n        }\n        // test shards\n        const diskShard = await (0,_shard_js__WEBPACK_IMPORTED_MODULE_4__.readShardFun)('/', store);\n        const a = diskShard.toString();\n        const b = shard.toString();\n        if (a !== b) {\n            throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n        }\n        return diskShard;\n    }\n    async put(key, val, options) {\n        await this.child.put(key, val, options);\n        return key;\n    }\n    async get(key, options) {\n        return this.child.get(key, options);\n    }\n    async has(key, options) {\n        return this.child.has(key, options);\n    }\n    async delete(key, options) {\n        await this.child.delete(key, options);\n    }\n    async *putMany(source, options = {}) {\n        yield* this.child.putMany(source, options);\n    }\n    async *getMany(source, options = {}) {\n        yield* this.child.getMany(source, options);\n    }\n    async *deleteMany(source, options = {}) {\n        yield* this.child.deleteMany(source, options);\n    }\n    batch() {\n        return this.child.batch();\n    }\n    query(q, options) {\n        const omitShard = ({ key }) => key.toString() !== shardKey.toString();\n        const tq = {\n            ...q,\n            filters: [\n                omitShard\n            ].concat(q.filters ?? [])\n        };\n        return this.child.query(tq, options);\n    }\n    queryKeys(q, options) {\n        const omitShard = (key) => key.toString() !== shardKey.toString();\n        const tq = {\n            ...q,\n            filters: [\n                omitShard\n            ].concat(q.filters ?? [])\n        };\n        return this.child.queryKeys(tq, options);\n    }\n}\n//# sourceMappingURL=sharding.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/sharding.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/tiered.js":
/*!********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/tiered.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TieredDatastore: () => (/* binding */ TieredDatastore)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_4__.logger)('datastore:core:tiered');\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseDatastore {\n    stores;\n    constructor(stores) {\n        super();\n        this.stores = stores.slice();\n    }\n    async put(key, value, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.put(key, value, options); }));\n            return key;\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.dbWriteFailedError(err);\n        }\n    }\n    async get(key, options) {\n        for (const store of this.stores) {\n            try {\n                const res = await store.get(key, options);\n                if (res != null)\n                    return res;\n            }\n            catch (err) {\n                log.error(err);\n            }\n        }\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.notFoundError();\n    }\n    async has(key, options) {\n        for (const s of this.stores) {\n            if (await s.has(key, options)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async delete(key, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.delete(key, options); }));\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.dbDeleteFailedError(err);\n        }\n    }\n    async *putMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_1__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.putMany(source, options))\n                .catch(err => {\n                // store threw while putting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const pair of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(pair));\n                yield pair.key;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_1__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.deleteMany(source, options))\n                .catch(err => {\n                // store threw while deleting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const key of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(key));\n                yield key;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    batch() {\n        const batches = this.stores.map(store => store.batch());\n        return {\n            put: (key, value) => {\n                batches.forEach(b => { b.put(key, value); });\n            },\n            delete: (key) => {\n                batches.forEach(b => { b.delete(key); });\n            },\n            commit: async (options) => {\n                for (const batch of batches) {\n                    await batch.commit(options);\n                }\n            }\n        };\n    }\n    query(q, options) {\n        return this.stores[this.stores.length - 1].query(q, options);\n    }\n    queryKeys(q, options) {\n        return this.stores[this.stores.length - 1].queryKeys(q, options);\n    }\n}\n//# sourceMappingURL=tiered.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/tiered.js?");

/***/ }),

/***/ "./node_modules/interface-datastore/dist/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/interface-datastore/dist/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Key: () => (/* reexport safe */ _key_js__WEBPACK_IMPORTED_MODULE_0__.Key)\n/* harmony export */ });\n/* harmony import */ var _key_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./key.js */ \"./node_modules/interface-datastore/dist/src/key.js\");\n/* eslint-disable @typescript-eslint/ban-types */\n// this ignore is so we can use {} as the default value for the options\n// extensions below - it normally means \"any non-nullish value\" but here\n// we are using it as an intersection type - see the aside at the bottom:\n// https://github.com/typescript-eslint/typescript-eslint/issues/2063#issuecomment-675156492\n/**\n * @packageDocumentation\n *\n * A Datastore is a key/value database that lets store/retrieve binary blobs using namespaced Keys.\n *\n * It is used by IPFS to store/retrieve arbitrary metadata needed to run the node - DHT provider records, signed peer records, etc.\n *\n * ## Backed Implementations\n *\n * - File System: [`datastore-fs`](https://github.com/ipfs/js-stores/tree/main/packages/datastore-fs)\n * - IndexedDB: [`datastore-idb`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-idb)\n * - level: [`datastore-level`](https://github.com/ipfs/js-stores/tree/main/packages/datastore-level) (supports any levelup compatible backend)\n * - Memory: [`datastore-core/memory`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/memory.ts)\n * - S3: [`datastore-s3`](https://github.com/ipfs/js-stores/tree/main/packages/datastore-s3)\n *\n * ## Wrapper Implementations\n *\n * - Keytransform: [`datstore-core/src/keytransform`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/keytransform.ts)\n * - Mount: [`datastore-core/src/mount`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/mount.ts)\n * - Namespace: [`datastore-core/src/namespace`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/namespace.ts)\n * - Sharding: [`datastore-core/src/sharding`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/sharding.ts)\n * - Tiered: [`datstore-core/src/tiered`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/tiered.ts)\n *\n * If you want the same functionality as [go-ds-flatfs](https://github.com/ipfs/go-ds-flatfs), use sharding with fs.\n *\n * @example\n *\n * ```js\n * import FsStore from 'datastore-fs'\n * import { ShardingDataStore, shard } from 'datastore-core'\n *\n * const fs = new FsStore('path/to/store')\n *\n * // flatfs now works like go-flatfs\n * const flatfs = await ShardingStore.createOrOpen(fs, new shard.NextToLast(2))\n * ```\n *\n * ### Test suite\n *\n * Available via the [`interface-datastore-tests`](https://npmjs.com/package/interface-datastore-tests) module\n *\n * ```js\n * import { interfaceDatastoreTests } from 'interface-datastore-tests'\n *\n * describe('mystore', () => {\n *   interfaceDatastoreTests({\n *     async setup () {\n *       return instanceOfMyStore\n *     },\n *     async teardown () {\n *       // cleanup resources\n *     }\n *   })\n * })\n * ```\n *\n * ### Aborting requests\n *\n * Most API methods accept an \\[AbortSignal]\\[] as part of an options object.  Implementations may listen for an `abort` event emitted by this object, or test the `signal.aborted` property. When received implementations should tear down any long-lived requests or resources created.\n *\n * ### Concurrency\n *\n * The streaming `(put|get|delete)Many` methods are intended to be used with modules such as [it-parallel-batch](https://www.npmjs.com/package/it-parallel-batch) to allow calling code to control levels of parallelisation.  The batching method ensures results are returned in the correct order, but interface implementations should be thread safe.\n *\n * ```js\n * import batch from 'it-parallel-batch'\n * const source = [{\n *   key: ..,\n *   value: ..\n * }]\n *\n * // put values into the datastore concurrently, max 10 at a time\n * for await (const { key, data } of batch(store.putMany(source), 10)) {\n *   console.info(`Put ${key}`)\n * }\n * ```\n *\n * ### Keys\n *\n * To allow a better abstraction on how to address values, there is a `Key` class which is used as identifier. It's easy to create a key from a `Uint8Array` or a `string`.\n *\n * ```js\n * const a = new Key('a')\n * const b = new Key(new Uint8Array([0, 1, 2, 3]))\n * ```\n *\n * The key scheme is inspired by file systems and Google App Engine key model. Keys are meant to be unique across a system. They are typically hierarchical, incorporating more and more specific namespaces. Thus keys can be deemed 'children' or 'ancestors' of other keys:\n *\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n *\n * Also, every namespace can be parameterized to embed relevant object information. For example, the Key `name` (most specific namespace) could include the object type:\n *\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n */\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/interface-datastore/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/interface-datastore/dist/src/key.js":
/*!**********************************************************!*\
  !*** ./node_modules/interface-datastore/dist/src/key.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Key: () => (/* binding */ Key)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n\n\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nclass Key {\n    _buf;\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */\n    constructor(s, clean) {\n        if (typeof s === 'string') {\n            this._buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(s);\n        }\n        else if (s instanceof Uint8Array) {\n            this._buf = s;\n        }\n        else {\n            throw new Error('Invalid key, should be String of Uint8Array');\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error('Invalid key');\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */\n    toString(encoding = 'utf8') {\n        return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */\n    uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */\n    static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/344502982398')\n     * ```\n     */\n    static random() {\n        return new Key(Math.random().toString().substring(2));\n    }\n    /**\n     * @param {*} other\n     */\n    static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === 'string') {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === 'function') {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */\n    less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for (let i = 0; i < list1.length; i++) {\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            }\n            else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */\n    reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n    namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */\n    baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */\n    list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */\n    type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */\n    name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    instance(s) {\n        return new Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */\n    path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */\n    parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        }\n        else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */\n    isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */\n    isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */\n    isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */\n    concat(...keys) {\n        return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType(ns) {\n    const parts = ns.split(':');\n    if (parts.length < 2) {\n        return '';\n    }\n    return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue(ns) {\n    const parts = ns.split(':');\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten(arr) {\n    return ([]).concat(...arr);\n}\n//# sourceMappingURL=key.js.map\n\n//# sourceURL=webpack://ems/./node_modules/interface-datastore/dist/src/key.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/bitswap.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/bitswap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBitswap: () => (/* binding */ DefaultBitswap)\n/* harmony export */ });\n/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! any-signal */ \"./node_modules/any-signal/dist/src/index.js\");\n/* harmony import */ var it_foreach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-foreach */ \"./node_modules/it-foreach/dist/src/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _decision_engine_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./decision-engine/index.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network.js */ \"./node_modules/ipfs-bitswap/dist/src/network.js\");\n/* harmony import */ var _notifications_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./notifications.js */ \"./node_modules/ipfs-bitswap/dist/src/notifications.js\");\n/* harmony import */ var _stats_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stats/index.js */ \"./node_modules/ipfs-bitswap/dist/src/stats/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _want_manager_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./want-manager/index.js */ \"./node_modules/ipfs-bitswap/dist/src/want-manager/index.js\");\n\n\n\n\n\n\n\n\n\nconst hashLoader = {\n    async getHasher() {\n        throw new Error('Not implemented');\n    }\n};\nconst defaultOptions = {\n    maxInboundStreams: 1024,\n    maxOutboundStreams: 1024,\n    incomingStreamTimeout: 30000,\n    hashLoader,\n    statsEnabled: false,\n    statsComputeThrottleTimeout: 1000,\n    statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = [\n    'blocksReceived',\n    'dataReceived',\n    'dupBlksReceived',\n    'dupDataReceived',\n    'blocksSent',\n    'dataSent',\n    'providesBufferLength',\n    'wantListLength',\n    'peerCount'\n];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n */\nclass DefaultBitswap {\n    _libp2p;\n    _log;\n    stats;\n    network;\n    blockstore;\n    engine;\n    wm;\n    notifications;\n    started;\n    constructor(libp2p, blockstore, options = {}) {\n        this._libp2p = libp2p;\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.logger)(this.peerId);\n        options = Object.assign({}, defaultOptions, options);\n        // stats\n        this.stats = new _stats_index_js__WEBPACK_IMPORTED_MODULE_4__.Stats(libp2p, statsKeys, {\n            enabled: options.statsEnabled,\n            computeThrottleTimeout: options.statsComputeThrottleTimeout,\n            computeThrottleMaxQueueSize: options.statsComputeThrottleMaxQueueSize\n        });\n        // the network delivers messages\n        this.network = new _network_js__WEBPACK_IMPORTED_MODULE_5__.Network(libp2p, this, this.stats, {\n            hashLoader: options.hashLoader,\n            maxInboundStreams: options.maxInboundStreams,\n            maxOutboundStreams: options.maxOutboundStreams,\n            incomingStreamTimeout: options.incomingStreamTimeout\n        });\n        // local database\n        this.blockstore = blockstore;\n        this.engine = new _decision_engine_index_js__WEBPACK_IMPORTED_MODULE_6__.DecisionEngine(this.peerId, blockstore, this.network, this.stats, libp2p);\n        // handle message sending\n        this.wm = new _want_manager_index_js__WEBPACK_IMPORTED_MODULE_7__.WantManager(this.peerId, this.network, this.stats, libp2p);\n        this.notifications = new _notifications_js__WEBPACK_IMPORTED_MODULE_8__.Notifications(this.peerId);\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    get peerId() {\n        return this._libp2p.peerId;\n    }\n    /**\n     * handle messages received through the network\n     */\n    async _receiveMessage(peerId, incoming) {\n        try {\n            // Note: this allows the engine to respond to any wants in the message.\n            // Processing of the blocks in the message happens below, after the\n            // blocks have been added to the blockstore.\n            await this.engine.messageReceived(peerId, incoming);\n        }\n        catch (err) {\n            // Log instead of throwing an error so as to process as much as\n            // possible of the message. Currently `messageReceived` does not\n            // throw any errors, but this could change in the future.\n            this._log('failed to receive message', incoming);\n        }\n        if (incoming.blocks.size === 0) {\n            return;\n        }\n        /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n        const received = [];\n        for (const [cidStr, data] of incoming.blocks.entries()) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_2__.CID.parse(cidStr);\n            received.push({\n                wasWanted: this.wm.wantlist.contains(cid),\n                cid,\n                data\n            });\n        }\n        // quickly send out cancels, reduces chances of duplicate block receives\n        this.wm.cancelWants(received\n            .filter(({ wasWanted }) => wasWanted)\n            .map(({ cid }) => cid));\n        await Promise.all(received.map(async ({ cid, wasWanted, data }) => { await this._handleReceivedBlock(peerId, cid, data, wasWanted); }));\n    }\n    async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n        this._log('received block');\n        const has = await this.blockstore.has(cid);\n        this._updateReceiveCounters(peerId.toString(), cid, data, has);\n        if (!wasWanted) {\n            return;\n        }\n        await this.put(cid, data);\n    }\n    _updateReceiveCounters(peerIdStr, cid, data, exists) {\n        this.stats.push(peerIdStr, 'blocksReceived', 1);\n        this.stats.push(peerIdStr, 'dataReceived', data.length);\n        if (exists) {\n            this.stats.push(peerIdStr, 'dupBlksReceived', 1);\n            this.stats.push(peerIdStr, 'dupDataReceived', data.length);\n        }\n    }\n    /**\n     * handle errors on the receiving channel\n     */\n    _receiveError(err) {\n        this._log.error('ReceiveError', err);\n    }\n    /**\n     * handle new peers\n     */\n    _onPeerConnected(peerId) {\n        this.wm.connected(peerId);\n    }\n    /**\n     * handle peers being disconnected\n     */\n    _onPeerDisconnected(peerId) {\n        this.wm.disconnected(peerId);\n        this.engine.peerDisconnected(peerId);\n        this.stats.disconnected(peerId);\n    }\n    enableStats() {\n        this.stats.enable();\n    }\n    disableStats() {\n        this.stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     */\n    wantlistForPeer(peerId, _options) {\n        return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     */\n    ledgerForPeer(peerId) {\n        return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     */\n    async want(cid, options = {}) {\n        const fetchFromNetwork = async (cid, options) => {\n            // add it to the want list - n.b. later we will abort the AbortSignal\n            // so no need to remove the blocks from the wantlist after we have it\n            this.wm.wantBlocks([cid], options);\n            return this.notifications.wantBlock(cid, options);\n        };\n        let promptedNetwork = false;\n        const loadOrFetchFromNetwork = async (cid, options) => {\n            try {\n                // have to await here as we want to handle ERR_NOT_FOUND\n                const block = await this.blockstore.get(cid, options);\n                return block;\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n                if (!promptedNetwork) {\n                    promptedNetwork = true;\n                    this.network.findAndConnect(cid, options)\n                        .catch((err) => { this._log.error(err); });\n                }\n                // we don't have the block locally so fetch it from the network\n                return await fetchFromNetwork(cid, options);\n            }\n        };\n        // depending on implementation it's possible for blocks to come in while\n        // we do the async operations to get them from the blockstore leading to\n        // a race condition, so register for incoming block notifications as well\n        // as trying to get it from the datastore\n        const controller = new AbortController();\n        const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_0__.anySignal)([controller.signal, options.signal]);\n        try {\n            const block = await Promise.race([\n                this.notifications.wantBlock(cid, {\n                    ...options,\n                    signal\n                }),\n                loadOrFetchFromNetwork(cid, {\n                    ...options,\n                    signal\n                })\n            ]);\n            return block;\n        }\n        finally {\n            // since we have the block we can now abort any outstanding attempts to\n            // fetch it\n            controller.abort();\n            signal.clear();\n        }\n    }\n    /**\n     * Removes the given CIDs from the wantlist independent of any ref counts.\n     *\n     * This will cause all outstanding promises for a given block to reject.\n     *\n     * If you want to cancel the want for a block without doing that, pass an\n     * AbortSignal in to `.get` or `.getMany` and abort it.\n     */\n    unwant(cids) {\n        const cidsArray = Array.isArray(cids) ? cids : [cids];\n        this.wm.unwantBlocks(cidsArray);\n        cidsArray.forEach((cid) => { this.notifications.unwantBlock(cid); });\n    }\n    /**\n     * Removes the given keys from the want list. This may cause pending promises\n     * for blocks to never resolve.  If you wish these promises to abort instead\n     * call `unwant(cids)` instead.\n     */\n    cancelWants(cids) {\n        this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     */\n    async put(cid, block, _options) {\n        await this.blockstore.put(cid, block);\n        this.notify(cid, block);\n    }\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     */\n    async *putMany(source, options) {\n        yield* this.blockstore.putMany((0,it_foreach__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(source, ({ cid, block }) => {\n            this.notify(cid, block);\n        }), options);\n    }\n    /**\n     * Sends notifications about the arrival of a block\n     */\n    notify(cid, block, options = {}) {\n        this.notifications.hasBlock(cid, block);\n        this.engine.receivedBlocks([{ cid, block }]);\n        // Note: Don't wait for provide to finish before returning\n        this.network.provide(cid, options).catch((err) => {\n            this._log.error('Failed to provide: %s', err.message);\n        });\n    }\n    /**\n     * Get the current list of wants\n     */\n    getWantlist() {\n        return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners\n     */\n    get peers() {\n        return this.engine.peers();\n    }\n    /**\n     * Start the bitswap node\n     */\n    async start() {\n        this.wm.start();\n        await this.network.start();\n        this.engine.start();\n        this.started = true;\n    }\n    /**\n     * Stop the bitswap node\n     */\n    async stop() {\n        this.stats.stop();\n        this.wm.stop();\n        await this.network.stop();\n        this.engine.stop();\n        this.started = false;\n    }\n}\n//# sourceMappingURL=bitswap.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/bitswap.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasBlockTimeout: () => (/* binding */ hasBlockTimeout),\n/* harmony export */   kMaxPriority: () => (/* binding */ kMaxPriority),\n/* harmony export */   maxListeners: () => (/* binding */ maxListeners),\n/* harmony export */   maxProvidersPerRequest: () => (/* binding */ maxProvidersPerRequest),\n/* harmony export */   provideTimeout: () => (/* binding */ provideTimeout),\n/* harmony export */   providerRequestTimeout: () => (/* binding */ providerRequestTimeout),\n/* harmony export */   wantlistSendDebounceMs: () => (/* binding */ wantlistSendDebounceMs)\n/* harmony export */ });\nconst SECOND = 1000;\nconst maxProvidersPerRequest = 3;\nconst providerRequestTimeout = 10 * SECOND;\nconst hasBlockTimeout = 15 * SECOND;\nconst provideTimeout = 15 * SECOND;\nconst kMaxPriority = Math.pow(2, 31) - 1;\nconst maxListeners = 1000;\nconst wantlistSendDebounceMs = 1;\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/constants.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecisionEngine: () => (/* binding */ DecisionEngine)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _wantlist_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../wantlist/index.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/index.js\");\n/* harmony import */ var _ledger_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ledger.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js\");\n/* harmony import */ var _req_queue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./req-queue.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js\");\n/* harmony import */ var _task_merger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./task-merger.js */ \"./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js\");\n\n\n\n\n\n\n\n\n\nconst WantType = _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.WantType;\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024;\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\nclass DecisionEngine {\n    _log;\n    blockstore;\n    network;\n    _stats;\n    _opts;\n    ledgerMap;\n    _running;\n    _requestQueue;\n    constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.logger)(peerId, 'engine');\n        this.blockstore = blockstore;\n        this.network = network;\n        this._stats = stats;\n        this._opts = this._processOpts(opts);\n        // A list of of ledgers by their partner id\n        this.ledgerMap = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_4__.trackedMap)({\n            name: 'ipfs_bitswap_ledger_map',\n            metrics: libp2p.metrics\n        });\n        this._running = false;\n        // Queue of want-have / want-block per peer\n        this._requestQueue = new _req_queue_js__WEBPACK_IMPORTED_MODULE_5__.RequestQueue(_task_merger_js__WEBPACK_IMPORTED_MODULE_6__.DefaultTaskMerger);\n    }\n    _processOpts(opts) {\n        return {\n            maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n            targetMessageSize: TARGET_MESSAGE_SIZE,\n            ...opts\n        };\n    }\n    _scheduleProcessTasks() {\n        setTimeout(() => {\n            this._processTasks().catch(err => {\n                this._log.error('error processing stats', err);\n            });\n        });\n    }\n    /**\n     * Pull tasks off the request queue and send a message to the corresponding\n     * peer\n     */\n    async _processTasks() {\n        if (!this._running) {\n            return;\n        }\n        const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);\n        if (tasks.length === 0) {\n            return;\n        }\n        // Create a new message\n        const msg = new _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage(false);\n        // Amount of data in the request queue still waiting to be popped\n        msg.setPendingBytes(pendingSize);\n        // Split out want-blocks, want-haves and DONT_HAVEs\n        const blockCids = [];\n        const blockTasks = new Map();\n        for (const task of tasks) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(task.topic);\n            if (task.data.haveBlock) {\n                if (task.data.isWantBlock) {\n                    blockCids.push(cid);\n                    blockTasks.set(task.topic, task.data);\n                }\n                else {\n                    // Add HAVES to the message\n                    msg.addHave(cid);\n                }\n            }\n            else {\n                // Add DONT_HAVEs to the message\n                msg.addDontHave(cid);\n            }\n        }\n        const blocks = await this._getBlocks(blockCids);\n        for (const [topic, taskData] of blockTasks) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(topic);\n            const blk = blocks.get(topic);\n            // If the block was found (it has not been removed)\n            if (blk != null) {\n                // Add the block to the message\n                msg.addBlock(cid, blk);\n            }\n            else {\n                // The block was not found. If the client requested DONT_HAVE,\n                // add DONT_HAVE to the message.\n                if (taskData.sendDontHave) {\n                    msg.addDontHave(cid);\n                }\n            }\n        }\n        // If there's nothing in the message, bail out\n        if (msg.empty) {\n            (peerId != null) && this._requestQueue.tasksDone(peerId, tasks);\n            // Trigger the next round of task processing\n            this._scheduleProcessTasks();\n            return;\n        }\n        try {\n            // Send the message\n            (peerId != null) && await this.network.sendMessage(peerId, msg);\n            // Peform sent message accounting\n            for (const [cidStr, block] of blocks.entries()) {\n                (peerId != null) && this.messageSent(peerId, multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(cidStr), block);\n            }\n        }\n        catch (err) {\n            this._log.error(err);\n        }\n        // Free the tasks up from the request queue\n        (peerId != null) && this._requestQueue.tasksDone(peerId, tasks);\n        // Trigger the next round of task processing\n        this._scheduleProcessTasks();\n    }\n    wantlistForPeer(peerId) {\n        const peerIdStr = peerId.toString();\n        const ledger = this.ledgerMap.get(peerIdStr);\n        return (ledger != null) ? ledger.wantlist.sortedEntries() : new Map();\n    }\n    ledgerForPeer(peerId) {\n        const peerIdStr = peerId.toString();\n        const ledger = this.ledgerMap.get(peerIdStr);\n        if (ledger == null) {\n            return undefined;\n        }\n        return {\n            peer: ledger.partner,\n            value: ledger.debtRatio(),\n            sent: ledger.accounting.bytesSent,\n            recv: ledger.accounting.bytesRecv,\n            exchanged: ledger.exchangeCount\n        };\n    }\n    peers() {\n        return Array.from(this.ledgerMap.values()).map((l) => l.partner);\n    }\n    /**\n     * Receive blocks either from an incoming message from the network, or from\n     * blocks being added by the client on the localhost (eg IPFS add)\n     */\n    receivedBlocks(blocks) {\n        if (blocks.length === 0) {\n            return;\n        }\n        // For each connected peer, check if it wants the block we received\n        for (const ledger of this.ledgerMap.values()) {\n            for (const { cid, block } of blocks) {\n                // Filter out blocks that we don't want\n                const want = ledger.wantlistContains(cid);\n                if (want == null) {\n                    continue;\n                }\n                // If the block is small enough, just send the block, even if the\n                // client asked for a HAVE\n                const blockSize = block.length;\n                const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n                let entrySize = blockSize;\n                if (!isWantBlock) {\n                    entrySize = _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.blockPresenceSize(want.cid);\n                }\n                this._requestQueue.pushTasks(ledger.partner, [{\n                        topic: want.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc),\n                        priority: want.priority,\n                        size: entrySize,\n                        data: {\n                            blockSize,\n                            isWantBlock,\n                            haveBlock: true,\n                            sendDontHave: false\n                        }\n                    }]);\n            }\n        }\n        this._scheduleProcessTasks();\n    }\n    /**\n     * Handle incoming messages\n     */\n    async messageReceived(peerId, msg) {\n        const ledger = this._findOrCreate(peerId);\n        if (msg.empty) {\n            return;\n        }\n        // If the message has a full wantlist, clear the current wantlist\n        if (msg.full) {\n            ledger.wantlist = new _wantlist_index_js__WEBPACK_IMPORTED_MODULE_7__.Wantlist();\n        }\n        // Record the amount of block data received\n        this._updateBlockAccounting(msg.blocks, ledger);\n        if (msg.wantlist.size === 0) {\n            this._scheduleProcessTasks();\n            return;\n        }\n        // Clear cancelled wants and add new wants to the ledger\n        const cancels = [];\n        const wants = [];\n        msg.wantlist.forEach((entry) => {\n            if (entry.cancel) {\n                ledger.cancelWant(entry.cid);\n                cancels.push(entry.cid);\n            }\n            else {\n                ledger.wants(entry.cid, entry.priority, entry.wantType);\n                wants.push(entry);\n            }\n        });\n        this._cancelWants(peerId, cancels);\n        await this._addWants(peerId, wants);\n        this._scheduleProcessTasks();\n    }\n    _cancelWants(peerId, cids) {\n        for (const c of cids) {\n            this._requestQueue.remove(c.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc), peerId);\n        }\n    }\n    async _addWants(peerId, wants) {\n        // Get the size of each wanted block\n        const blockSizes = await this._getBlockSizes(wants.map(w => w.cid));\n        const tasks = [];\n        for (const want of wants) {\n            const id = want.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n            const blockSize = blockSizes.get(id);\n            // If the block was not found\n            if (blockSize == null) {\n                // Only add the task to the queue if the requester wants a DONT_HAVE\n                if (want.sendDontHave) {\n                    tasks.push({\n                        topic: id,\n                        priority: want.priority,\n                        size: _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.blockPresenceSize(want.cid),\n                        data: {\n                            isWantBlock: want.wantType === WantType.Block,\n                            blockSize: 0,\n                            haveBlock: false,\n                            sendDontHave: want.sendDontHave\n                        }\n                    });\n                }\n            }\n            else {\n                // The block was found, add it to the queue\n                // If the block is small enough, just send the block, even if the\n                // client asked for a HAVE\n                const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n                // entrySize is the amount of space the entry takes up in the\n                // message we send to the recipient. If we're sending a block, the\n                // entrySize is the size of the block. Otherwise it's the size of\n                // a block presence entry.\n                let entrySize = blockSize;\n                if (!isWantBlock) {\n                    entrySize = _message_index_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessage.blockPresenceSize(want.cid);\n                }\n                tasks.push({\n                    topic: id,\n                    priority: want.priority,\n                    size: entrySize,\n                    data: {\n                        isWantBlock,\n                        blockSize,\n                        haveBlock: true,\n                        sendDontHave: want.sendDontHave\n                    }\n                });\n            }\n            this._requestQueue.pushTasks(peerId, tasks);\n        }\n    }\n    _sendAsBlock(wantType, blockSize) {\n        return wantType === WantType.Block ||\n            blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n    }\n    async _getBlockSizes(cids) {\n        const blocks = await this._getBlocks(cids);\n        return new Map([...blocks].map(([k, v]) => [k, v.length]));\n    }\n    async _getBlocks(cids) {\n        const res = new Map();\n        await Promise.all(cids.map(async (cid) => {\n            try {\n                const block = await this.blockstore.get(cid);\n                res.set(cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc), block);\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    this._log.error('failed to query blockstore for %s: %s', cid, err);\n                }\n            }\n        }));\n        return res;\n    }\n    _updateBlockAccounting(blocksMap, ledger) {\n        for (const block of blocksMap.values()) {\n            this._log('got block (%s bytes)', block.length);\n            ledger.receivedBytes(block.length);\n        }\n    }\n    /**\n     * Clear up all accounting things after message was sent\n     */\n    messageSent(peerId, cid, block) {\n        const ledger = this._findOrCreate(peerId);\n        ledger.sentBytes(block.length);\n        ledger.wantlist.remove(cid);\n    }\n    numBytesSentTo(peerId) {\n        return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n    numBytesReceivedFrom(peerId) {\n        return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n    peerDisconnected(peerId) {\n        this.ledgerMap.delete(peerId.toString());\n    }\n    _findOrCreate(peerId) {\n        const peerIdStr = peerId.toString();\n        const ledger = this.ledgerMap.get(peerIdStr);\n        if (ledger != null) {\n            return ledger;\n        }\n        const l = new _ledger_js__WEBPACK_IMPORTED_MODULE_8__.Ledger(peerId);\n        this.ledgerMap.set(peerIdStr, l);\n        if (this._stats != null) {\n            this._stats.push(peerIdStr, 'peerCount', 1);\n        }\n        return l;\n    }\n    start() {\n        this._running = true;\n    }\n    stop() {\n        this._running = false;\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ledger: () => (/* binding */ Ledger)\n/* harmony export */ });\n/* harmony import */ var _wantlist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wantlist/index.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/index.js\");\n\nclass Ledger {\n    partner;\n    wantlist;\n    exchangeCount;\n    accounting;\n    lastExchange;\n    constructor(peerId) {\n        this.partner = peerId;\n        this.wantlist = new _wantlist_index_js__WEBPACK_IMPORTED_MODULE_0__.Wantlist();\n        this.exchangeCount = 0;\n        this.accounting = {\n            bytesSent: 0,\n            bytesRecv: 0\n        };\n    }\n    sentBytes(n) {\n        this.exchangeCount++;\n        this.lastExchange = (new Date()).getTime();\n        this.accounting.bytesSent += n;\n    }\n    receivedBytes(n) {\n        this.exchangeCount++;\n        this.lastExchange = (new Date()).getTime();\n        this.accounting.bytesRecv += n;\n    }\n    wants(cid, priority, wantType) {\n        this.wantlist.add(cid, priority, wantType);\n    }\n    /**\n     * @param {CID} cid\n     * @returns {void}\n     */\n    cancelWant(cid) {\n        this.wantlist.remove(cid);\n    }\n    wantlistContains(cid) {\n        return this.wantlist.get(cid);\n    }\n    debtRatio() {\n        return (this.accounting.bytesSent / (this.accounting.bytesRecv + 1)); // +1 is to prevent division by zero\n    }\n}\n//# sourceMappingURL=ledger.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/ledger.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RequestQueue: () => (/* binding */ RequestQueue)\n/* harmony export */ });\n/* harmony import */ var _utils_sorted_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/sorted-map.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js\");\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n */\nconst DefaultTaskMerger = {\n    hasNewInfo() {\n        return false;\n    },\n    merge() { }\n};\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\nclass RequestQueue {\n    _taskMerger;\n    _byPeer;\n    constructor(taskMerger = DefaultTaskMerger) {\n        this._taskMerger = taskMerger;\n        this._byPeer = new _utils_sorted_map_js__WEBPACK_IMPORTED_MODULE_0__.SortedMap([], PeerTasks.compare);\n    }\n    /**\n     * Push tasks onto the queue for the given peer\n     */\n    pushTasks(peerId, tasks) {\n        let peerTasks = this._byPeer.get(peerId.toString());\n        if (peerTasks == null) {\n            peerTasks = new PeerTasks(peerId, this._taskMerger);\n        }\n        peerTasks.pushTasks(tasks);\n        this._byPeer.set(peerId.toString(), peerTasks);\n    }\n    /**\n     * Choose the peer with the least active work (or if all have the same active\n     * work, the most pending tasks) and pop off the highest priority tasks until\n     * the total size is at least targetMinBytes.\n     * This puts the popped tasks into the \"active\" state, meaning they are\n     * actively being processed (and cannot be modified).\n     */\n    popTasks(targetMinBytes) {\n        // Get the queue of tasks for the best peer and pop off tasks up to\n        // targetMinBytes\n        const peerTasks = this._head();\n        if (peerTasks === undefined) {\n            return { tasks: [], pendingSize: 0 };\n        }\n        const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);\n        if (tasks.length === 0) {\n            return { tasks, pendingSize };\n        }\n        const peerId = peerTasks.peerId;\n        if (peerTasks.isIdle()) {\n            // If there are no more tasks for the peer, free up its memory\n            this._byPeer.delete(peerId.toString());\n        }\n        else {\n            // If there are still tasks remaining, update the sort order of peerTasks\n            // (because it depends on the number of pending tasks)\n            this._byPeer.update(0);\n        }\n        return {\n            peerId, tasks, pendingSize\n        };\n    }\n    _head() {\n        // Shortcut\n        if (this._byPeer.size === 0) {\n            return undefined;\n        }\n        // eslint-disable-next-line no-unreachable-loop\n        for (const [, v] of this._byPeer) {\n            return v;\n        }\n        return undefined;\n    }\n    /**\n     * Remove the task with the given topic for the given peer.\n     */\n    remove(topic, peerId) {\n        const peerTasks = this._byPeer.get(peerId.toString());\n        peerTasks?.remove(topic);\n    }\n    /**\n     * Called when the tasks for the given peer complete.\n     */\n    tasksDone(peerId, tasks) {\n        const peerTasks = this._byPeer.get(peerId.toString());\n        if (peerTasks == null) {\n            return;\n        }\n        const i = this._byPeer.indexOf(peerId.toString());\n        for (const task of tasks) {\n            peerTasks.taskDone(task);\n        }\n        // Marking the tasks as done takes them out of the \"active\" state, and the\n        // sort order depends on the size of the active tasks, so we need to update\n        // the order.\n        this._byPeer.update(i);\n    }\n}\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\nclass PeerTasks {\n    peerId;\n    _taskMerger;\n    _activeTotalSize;\n    _pending;\n    _active;\n    constructor(peerId, taskMerger) {\n        this.peerId = peerId;\n        this._taskMerger = taskMerger;\n        this._activeTotalSize = 0;\n        this._pending = new PendingTasks();\n        this._active = new Set();\n    }\n    /**\n     * Push tasks onto the queue\n     */\n    pushTasks(tasks) {\n        for (const t of tasks) {\n            this._pushTask(t);\n        }\n    }\n    _pushTask(task) {\n        // If the new task doesn't add any more information over what we\n        // already have in the active queue, then we can skip the new task\n        if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n            return;\n        }\n        // If there is already a non-active (pending) task with this topic\n        const existingTask = this._pending.get(task.topic);\n        if (existingTask != null) {\n            // If the new task has a higher priority than the old task,\n            if (task.priority > existingTask.priority) {\n                // Update the priority and the task's position in the queue\n                this._pending.updatePriority(task.topic, task.priority);\n            }\n            // Merge the information from the new task into the existing task\n            this._taskMerger.merge(task, existingTask);\n            // A task with the topic exists, so we don't need to add\n            // the new task to the queue\n            return;\n        }\n        // Push the new task onto the queue\n        this._pending.add(task);\n    }\n    /**\n     * Indicates whether the new task adds any more information over tasks that are\n     * already in the active task queue\n     */\n    _taskHasMoreInfoThanActiveTasks(task) {\n        const tasksWithTopic = [];\n        for (const activeTask of this._active) {\n            if (activeTask.topic === task.topic) {\n                tasksWithTopic.push(activeTask);\n            }\n        }\n        // No tasks with that topic, so the new task adds information\n        if (tasksWithTopic.length === 0) {\n            return true;\n        }\n        return this._taskMerger.hasNewInfo(task, tasksWithTopic);\n    }\n    /**\n     * Pop tasks off the queue such that the total size is at least targetMinBytes\n     */\n    popTasks(targetMinBytes) {\n        let size = 0;\n        const tasks = [];\n        // Keep popping tasks until we get up to targetMinBytes (or one item over\n        // targetMinBytes)\n        const pendingTasks = this._pending.tasks();\n        for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n            const task = pendingTasks[i];\n            tasks.push(task);\n            size += task.size;\n            // Move tasks from pending to active\n            this._pending.delete(task.topic);\n            this._activeTotalSize += task.size;\n            this._active.add(task);\n        }\n        return {\n            tasks, pendingSize: this._pending.totalSize\n        };\n    }\n    /**\n     * Called when a task completes.\n     * Note: must be the same reference as returned from popTasks.\n     */\n    taskDone(task) {\n        if (this._active.has(task)) {\n            this._activeTotalSize -= task.size;\n            this._active.delete(task);\n        }\n    }\n    /**\n     * Remove pending tasks with the given topic\n     */\n    remove(topic) {\n        this._pending.delete(topic);\n    }\n    /**\n     * No work to be done, this PeerTasks object can be freed.\n     */\n    isIdle() {\n        return this._pending.length === 0 && this._active.size === 0;\n    }\n    /**\n     * Compare PeerTasks\n     */\n    static compare(a, b) {\n        // Move peers with no pending tasks to the back of the queue\n        if (a[1]._pending.length === 0) {\n            return 1;\n        }\n        if (b[1]._pending.length === 0) {\n            return -1;\n        }\n        // If the amount of active work is the same\n        if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n            // Choose the peer with the most pending work\n            return b[1]._pending.length - a[1]._pending.length;\n        }\n        // Choose the peer with the least amount of active work (\"keep peers busy\")\n        return a[1]._activeTotalSize - b[1]._activeTotalSize;\n    }\n}\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\nclass PendingTasks {\n    _tasks;\n    constructor() {\n        this._tasks = new _utils_sorted_map_js__WEBPACK_IMPORTED_MODULE_0__.SortedMap([], this._compare);\n    }\n    get length() {\n        return this._tasks.size;\n    }\n    /**\n     * Sum of the size of all pending tasks\n     **/\n    get totalSize() {\n        return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);\n    }\n    get(topic) {\n        return this._tasks?.get(topic)?.task;\n    }\n    add(task) {\n        this._tasks.set(task.topic, {\n            created: Date.now(),\n            task\n        });\n    }\n    delete(topic) {\n        this._tasks.delete(topic);\n    }\n    // All pending tasks, in priority order\n    tasks() {\n        return [...this._tasks.values()].map(i => i.task);\n    }\n    /**\n     * Update the priority of the task with the given topic, and update the order\n     **/\n    updatePriority(topic, priority) {\n        const obj = this._tasks.get(topic);\n        if (obj == null) {\n            return;\n        }\n        const i = this._tasks.indexOf(topic);\n        obj.task.priority = priority;\n        this._tasks.update(i);\n    }\n    /**\n     * Sort by priority desc then FIFO\n     */\n    _compare(a, b) {\n        if (a[1].task.priority === b[1].task.priority) {\n            // FIFO\n            return a[1].created - b[1].created;\n        }\n        // Priority high -> low\n        return b[1].task.priority - a[1].task.priority;\n    }\n}\n//# sourceMappingURL=req-queue.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/req-queue.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultTaskMerger: () => (/* binding */ DefaultTaskMerger)\n/* harmony export */ });\nconst DefaultTaskMerger = {\n    /**\n     * Indicates whether the given task has newer information than the active\n     * tasks with the same topic.\n     *\n     * @param {Task} task\n     * @param {Task[]} tasksWithTopic\n     * @returns {boolean}\n     */\n    hasNewInfo(task, tasksWithTopic) {\n        let haveBlock = false;\n        let isWantBlock = false;\n        for (const existing of tasksWithTopic) {\n            if (existing.data.haveBlock) {\n                haveBlock = true;\n            }\n            if (existing.data.isWantBlock) {\n                isWantBlock = true;\n            }\n        }\n        // If there is no active want-block and the new task is a want-block,\n        // the new task is better\n        if (!isWantBlock && task.data.isWantBlock) {\n            return true;\n        }\n        // If we didn't have the block, and the new task indicates that we now\n        // do have the block, then we must also have size information for the\n        // block, so the new task has new information.\n        if (!haveBlock && task.data.haveBlock) {\n            return true;\n        }\n        return false;\n    },\n    /**\n     * Merge the information from the given task into the existing task (with the\n     * same topic)\n     */\n    merge(newTask, existingTask) {\n        // The merge function ignores the topic and priority as these don't change.\n        //\n        // We may receive new information about a want before the want has been\n        // popped from the queue in the following scenarios:\n        //\n        // - Replace want type:\n        //   1. Client sends want-have CID1\n        //   2. Client sends want-block CID1\n        //   In this case we should replace want-have with want-block, including\n        //   updating the task size to be the block size.\n        //\n        // - Replace DONT_HAVE with want:\n        //   1. Client sends want-have CID1 or want-block CID1\n        //   2. Local node doesn't have block for CID1\n        //   3. Local node receives block for CID1 from peer\n        //   In this case we should replace DONT_HAVE with the want, including\n        //   updating the task size and block size.\n        const taskData = newTask.data;\n        const existingData = existingTask.data;\n        // If we didn't have block size information (because we didn't have the\n        // block) and we receive the block from a peer, update the task with the\n        // new block size\n        if (!existingData.haveBlock && taskData.haveBlock) {\n            existingData.haveBlock = taskData.haveBlock;\n            existingData.blockSize = taskData.blockSize;\n        }\n        // If replacing a want-have with a want-block\n        if (!existingData.isWantBlock && taskData.isWantBlock) {\n            // Change the type from want-have to want-block\n            existingData.isWantBlock = true;\n            // If the want-have was a DONT_HAVE, or the want-block has a size\n            if (!existingData.haveBlock || taskData.haveBlock) {\n                // Update the entry size\n                existingData.haveBlock = taskData.haveBlock;\n                existingTask.size = newTask.size;\n            }\n        }\n        // If the task is a want-block, make sure the entry size is equal\n        // to the block size (because we will send the whole block)\n        if (existingData.isWantBlock && existingData.haveBlock) {\n            existingTask.size = existingData.blockSize;\n        }\n    }\n};\n//# sourceMappingURL=task-merger.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/decision-engine/task-merger.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBitswap: () => (/* binding */ createBitswap)\n/* harmony export */ });\n/* harmony import */ var _bitswap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitswap.js */ \"./node_modules/ipfs-bitswap/dist/src/bitswap.js\");\n/**\n * @packageDocumentation\n *\n * This module implements the [Bitswap protocol](https://docs.ipfs.tech/concepts/bitswap/) in TypeScript.\n */\n\nconst createBitswap = (libp2p, blockstore, options = {}) => {\n    return new _bitswap_js__WEBPACK_IMPORTED_MODULE_0__.DefaultBitswap(libp2p, blockstore, options);\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/message/entry.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/message/entry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitswapMessageEntry: () => (/* binding */ BitswapMessageEntry)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _wantlist_entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wantlist/entry.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js\");\n\n\nclass BitswapMessageEntry {\n    entry;\n    cancel;\n    sendDontHave;\n    constructor(cid, priority, wantType, cancel, sendDontHave) {\n        this.entry = new _wantlist_entry_js__WEBPACK_IMPORTED_MODULE_1__.WantListEntry(cid, priority, wantType);\n        this.cancel = Boolean(cancel);\n        this.sendDontHave = Boolean(sendDontHave);\n    }\n    get cid() {\n        return this.entry.cid;\n    }\n    set cid(cid) {\n        this.entry.cid = cid;\n    }\n    get priority() {\n        return this.entry.priority;\n    }\n    set priority(val) {\n        this.entry.priority = val;\n    }\n    get wantType() {\n        return this.entry.wantType;\n    }\n    set wantType(val) {\n        this.entry.wantType = val;\n    }\n    get [Symbol.toStringTag]() {\n        const cidStr = this.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;\n    }\n    equals(other) {\n        return (this.cancel === other.cancel) &&\n            (this.sendDontHave === other.sendDontHave) &&\n            (this.wantType === other.wantType) &&\n            this.entry.equals(other.entry);\n    }\n}\n//# sourceMappingURL=entry.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/message/entry.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/message/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/message/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BitswapMessage: () => (/* binding */ BitswapMessage)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n/* harmony import */ var varint_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! varint-decoder */ \"./node_modules/varint-decoder/src/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _utils_varint_encoder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/varint-encoder.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entry.js */ \"./node_modules/ipfs-bitswap/dist/src/message/entry.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./message.js */ \"./node_modules/ipfs-bitswap/dist/src/message/message.js\");\n\n\n\n\n// @ts-expect-error no types\n\n\n\n\n\nclass BitswapMessage {\n    static Entry = _entry_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessageEntry;\n    static WantType = {\n        Block: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.Wantlist.WantType.Block,\n        Have: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.Wantlist.WantType.Have\n    };\n    static BlockPresenceType = {\n        Have: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.BlockPresenceType.Have,\n        DontHave: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.BlockPresenceType.DontHave\n    };\n    static deserialize = async (raw, hashLoader) => {\n        const decoded = _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.decode(raw);\n        const isFull = decoded.wantlist?.full === true;\n        const msg = new BitswapMessage(isFull);\n        decoded.wantlist?.entries.forEach((entry) => {\n            if (entry.block == null) {\n                return;\n            }\n            // note: entry.block is the CID here\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(entry.block);\n            msg.addEntry(cid, entry.priority ?? 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n        });\n        decoded.blockPresences.forEach((blockPresence) => {\n            if (blockPresence.cid == null) {\n                return;\n            }\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(blockPresence.cid);\n            if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                msg.addHave(cid);\n            }\n            else {\n                msg.addDontHave(cid);\n            }\n        });\n        // Bitswap 1.0.0\n        // decoded.blocks are just the byte arrays\n        if (decoded.blocks.length > 0) {\n            await Promise.all(decoded.blocks.map(async (b) => {\n                const hash = await multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.digest(b);\n                const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.createV0(hash);\n                msg.addBlock(cid, b);\n            }));\n            return msg;\n        }\n        // Bitswap 1.1.0\n        if (decoded.payload.length > 0) {\n            await Promise.all(decoded.payload.map(async (p) => {\n                if (p.prefix == null || p.data == null) {\n                    return;\n                }\n                const values = varint_decoder__WEBPACK_IMPORTED_MODULE_3__(p.prefix);\n                const cidVersion = values[0];\n                const multicodec = values[1];\n                const hashAlg = values[2];\n                const hasher = hashAlg === multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256.code ? multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256 : await hashLoader?.getHasher(hashAlg);\n                if (hasher == null) {\n                    throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_6__.CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG');\n                }\n                // const hashLen = values[3] // We haven't need to use this so far\n                const hash = await hasher.digest(p.data);\n                const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.create(cidVersion, multicodec, hash);\n                msg.addBlock(cid, p.data);\n            }));\n            msg.setPendingBytes(decoded.pendingBytes);\n            return msg;\n        }\n        return msg;\n    };\n    static blockPresenceSize = (cid) => {\n        // It's ok if this is not exactly right: it's used to estimate the size of\n        // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n        // plenty of padding under the maximum message size.\n        // (It's more important for this to be fast).\n        return cid.bytes.length + 1;\n    };\n    full;\n    wantlist;\n    blocks;\n    blockPresences;\n    pendingBytes;\n    constructor(full) {\n        this.full = full;\n        this.wantlist = new Map();\n        this.blocks = new Map();\n        this.blockPresences = new Map();\n        this.pendingBytes = 0;\n    }\n    get empty() {\n        return this.blocks.size === 0 &&\n            this.wantlist.size === 0 &&\n            this.blockPresences.size === 0;\n    }\n    addEntry(cid, priority, wantType, cancel, sendDontHave) {\n        if (wantType == null) {\n            wantType = BitswapMessage.WantType.Block;\n        }\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        const entry = this.wantlist.get(cidStr);\n        if (entry != null) {\n            // Only change priority if want is of the same type\n            if (entry.wantType === wantType) {\n                entry.priority = priority;\n            }\n            // Only change from \"dont cancel\" to \"do cancel\"\n            if (cancel === true) {\n                entry.cancel = Boolean(cancel);\n            }\n            // Only change from \"dont send\" to \"do send\" DONT_HAVE\n            if (sendDontHave === true) {\n                entry.sendDontHave = Boolean(sendDontHave);\n            }\n            // want-block overrides existing want-have\n            if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n                entry.wantType = wantType;\n            }\n        }\n        else {\n            this.wantlist.set(cidStr, new _entry_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));\n        }\n    }\n    addBlock(cid, block) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        this.blocks.set(cidStr, block);\n    }\n    addHave(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        if (!this.blockPresences.has(cidStr)) {\n            this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n        }\n    }\n    addDontHave(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        if (!this.blockPresences.has(cidStr)) {\n            this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n        }\n    }\n    cancel(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        this.wantlist.delete(cidStr);\n        this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n    setPendingBytes(size) {\n        this.pendingBytes = size;\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     */\n    serializeToBitswap100() {\n        return _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.encode({\n            wantlist: {\n                entries: Array.from(this.wantlist.values()).map((entry) => {\n                    return {\n                        block: entry.cid.bytes, // cid\n                        priority: Number(entry.priority),\n                        cancel: Boolean(entry.cancel),\n                        wantType: _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.Wantlist.WantType.Block,\n                        sendDontHave: false\n                    };\n                }),\n                full: Boolean(this.full)\n            },\n            blocks: Array.from(this.blocks.values())\n        });\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     */\n    serializeToBitswap110() {\n        const msg = {\n            wantlist: {\n                entries: Array.from(this.wantlist.values()).map((entry) => {\n                    return {\n                        block: entry.cid.bytes, // cid\n                        priority: Number(entry.priority),\n                        wantType: entry.wantType,\n                        cancel: Boolean(entry.cancel),\n                        sendDontHave: Boolean(entry.sendDontHave)\n                    };\n                }),\n                full: Boolean(this.full)\n            },\n            blockPresences: [],\n            payload: [],\n            pendingBytes: this.pendingBytes,\n            blocks: []\n        };\n        for (const [cidStr, data] of this.blocks.entries()) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(cidStr);\n            const version = cid.version;\n            const codec = cid.code;\n            const multihash = cid.multihash.code;\n            const digestLength = cid.multihash.digest.length;\n            const prefix = (0,_utils_varint_encoder_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])([\n                version, codec, multihash, digestLength\n            ]);\n            msg.payload.push({\n                prefix,\n                data\n            });\n        }\n        for (const [cidStr, bpType] of this.blockPresences) {\n            msg.blockPresences.push({\n                cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(cidStr).bytes,\n                type: bpType\n            });\n        }\n        if (this.pendingBytes > 0) {\n            msg.pendingBytes = this.pendingBytes;\n        }\n        return _message_js__WEBPACK_IMPORTED_MODULE_5__.Message.encode(msg);\n    }\n    equals(other) {\n        if (this.full !== other.full ||\n            this.pendingBytes !== other.pendingBytes ||\n            !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.isMapEqual)(this.wantlist, other.wantlist) ||\n            !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.isMapEqual)(this.blocks, other.blocks) ||\n            // @TODO - Is this a bug ?\n            // @ts-expect-error - isMap equals map values to be objects not numbers\n            !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.isMapEqual)(this.blockPresences, other.blockPresences)) {\n            return false;\n        }\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        const list = Array.from(this.wantlist.keys());\n        const blocks = Array.from(this.blocks.keys());\n        return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/message/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/message/message.js":
/*!***************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/message/message.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Message: () => (/* binding */ Message)\n/* harmony export */ });\n/* harmony import */ var protons_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protons-runtime */ \"./node_modules/protons-runtime/dist/src/index.js\");\n/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nvar Message;\n(function (Message) {\n    let Wantlist;\n    (function (Wantlist) {\n        let WantType;\n        (function (WantType) {\n            WantType[\"Block\"] = \"Block\";\n            WantType[\"Have\"] = \"Have\";\n        })(WantType = Wantlist.WantType || (Wantlist.WantType = {}));\n        let __WantTypeValues;\n        (function (__WantTypeValues) {\n            __WantTypeValues[__WantTypeValues[\"Block\"] = 0] = \"Block\";\n            __WantTypeValues[__WantTypeValues[\"Have\"] = 1] = \"Have\";\n        })(__WantTypeValues || (__WantTypeValues = {}));\n        (function (WantType) {\n            WantType.codec = () => {\n                return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__WantTypeValues);\n            };\n        })(WantType = Wantlist.WantType || (Wantlist.WantType = {}));\n        let Entry;\n        (function (Entry) {\n            let _codec;\n            Entry.codec = () => {\n                if (_codec == null) {\n                    _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                        if (opts.lengthDelimited !== false) {\n                            w.fork();\n                        }\n                        if ((obj.block != null && obj.block.byteLength > 0)) {\n                            w.uint32(10);\n                            w.bytes(obj.block);\n                        }\n                        if ((obj.priority != null && obj.priority !== 0)) {\n                            w.uint32(16);\n                            w.int32(obj.priority);\n                        }\n                        if ((obj.cancel != null && obj.cancel !== false)) {\n                            w.uint32(24);\n                            w.bool(obj.cancel);\n                        }\n                        if (obj.wantType != null && __WantTypeValues[obj.wantType] !== 0) {\n                            w.uint32(32);\n                            Message.Wantlist.WantType.codec().encode(obj.wantType, w);\n                        }\n                        if ((obj.sendDontHave != null && obj.sendDontHave !== false)) {\n                            w.uint32(40);\n                            w.bool(obj.sendDontHave);\n                        }\n                        if (opts.lengthDelimited !== false) {\n                            w.ldelim();\n                        }\n                    }, (reader, length) => {\n                        const obj = {\n                            block: new Uint8Array(0),\n                            priority: 0,\n                            cancel: false,\n                            wantType: WantType.Block,\n                            sendDontHave: false\n                        };\n                        const end = length == null ? reader.len : reader.pos + length;\n                        while (reader.pos < end) {\n                            const tag = reader.uint32();\n                            switch (tag >>> 3) {\n                                case 1:\n                                    obj.block = reader.bytes();\n                                    break;\n                                case 2:\n                                    obj.priority = reader.int32();\n                                    break;\n                                case 3:\n                                    obj.cancel = reader.bool();\n                                    break;\n                                case 4:\n                                    obj.wantType = Message.Wantlist.WantType.codec().decode(reader);\n                                    break;\n                                case 5:\n                                    obj.sendDontHave = reader.bool();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                            }\n                        }\n                        return obj;\n                    });\n                }\n                return _codec;\n            };\n            Entry.encode = (obj) => {\n                return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Entry.codec());\n            };\n            Entry.decode = (buf) => {\n                return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Entry.codec());\n            };\n        })(Entry = Wantlist.Entry || (Wantlist.Entry = {}));\n        let _codec;\n        Wantlist.codec = () => {\n            if (_codec == null) {\n                _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if (obj.entries != null) {\n                        for (const value of obj.entries) {\n                            w.uint32(10);\n                            Message.Wantlist.Entry.codec().encode(value, w);\n                        }\n                    }\n                    if ((obj.full != null && obj.full !== false)) {\n                        w.uint32(16);\n                        w.bool(obj.full);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        entries: [],\n                        full: false\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.entries.push(Message.Wantlist.Entry.codec().decode(reader, reader.uint32()));\n                                break;\n                            case 2:\n                                obj.full = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Wantlist.encode = (obj) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Wantlist.codec());\n        };\n        Wantlist.decode = (buf) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Wantlist.codec());\n        };\n    })(Wantlist = Message.Wantlist || (Message.Wantlist = {}));\n    let Block;\n    (function (Block) {\n        let _codec;\n        Block.codec = () => {\n            if (_codec == null) {\n                _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.prefix != null && obj.prefix.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.prefix);\n                    }\n                    if ((obj.data != null && obj.data.byteLength > 0)) {\n                        w.uint32(18);\n                        w.bytes(obj.data);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        prefix: new Uint8Array(0),\n                        data: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.prefix = reader.bytes();\n                                break;\n                            case 2:\n                                obj.data = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Block.encode = (obj) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Block.codec());\n        };\n        Block.decode = (buf) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Block.codec());\n        };\n    })(Block = Message.Block || (Message.Block = {}));\n    let BlockPresenceType;\n    (function (BlockPresenceType) {\n        BlockPresenceType[\"Have\"] = \"Have\";\n        BlockPresenceType[\"DontHave\"] = \"DontHave\";\n    })(BlockPresenceType = Message.BlockPresenceType || (Message.BlockPresenceType = {}));\n    let __BlockPresenceTypeValues;\n    (function (__BlockPresenceTypeValues) {\n        __BlockPresenceTypeValues[__BlockPresenceTypeValues[\"Have\"] = 0] = \"Have\";\n        __BlockPresenceTypeValues[__BlockPresenceTypeValues[\"DontHave\"] = 1] = \"DontHave\";\n    })(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));\n    (function (BlockPresenceType) {\n        BlockPresenceType.codec = () => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__BlockPresenceTypeValues);\n        };\n    })(BlockPresenceType = Message.BlockPresenceType || (Message.BlockPresenceType = {}));\n    let BlockPresence;\n    (function (BlockPresence) {\n        let _codec;\n        BlockPresence.codec = () => {\n            if (_codec == null) {\n                _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.cid != null && obj.cid.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.cid);\n                    }\n                    if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {\n                        w.uint32(16);\n                        Message.BlockPresenceType.codec().encode(obj.type, w);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        cid: new Uint8Array(0),\n                        type: BlockPresenceType.Have\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.cid = reader.bytes();\n                                break;\n                            case 2:\n                                obj.type = Message.BlockPresenceType.codec().decode(reader);\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        BlockPresence.encode = (obj) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, BlockPresence.codec());\n        };\n        BlockPresence.decode = (buf) => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, BlockPresence.codec());\n        };\n    })(BlockPresence = Message.BlockPresence || (Message.BlockPresence = {}));\n    let _codec;\n    Message.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.wantlist != null) {\n                    w.uint32(10);\n                    Message.Wantlist.codec().encode(obj.wantlist, w);\n                }\n                if (obj.blocks != null) {\n                    for (const value of obj.blocks) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (obj.payload != null) {\n                    for (const value of obj.payload) {\n                        w.uint32(26);\n                        Message.Block.codec().encode(value, w);\n                    }\n                }\n                if (obj.blockPresences != null) {\n                    for (const value of obj.blockPresences) {\n                        w.uint32(34);\n                        Message.BlockPresence.codec().encode(value, w);\n                    }\n                }\n                if ((obj.pendingBytes != null && obj.pendingBytes !== 0)) {\n                    w.uint32(40);\n                    w.int32(obj.pendingBytes);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    blocks: [],\n                    payload: [],\n                    blockPresences: [],\n                    pendingBytes: 0\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.wantlist = Message.Wantlist.codec().decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            obj.blocks.push(reader.bytes());\n                            break;\n                        case 3:\n                            obj.payload.push(Message.Block.codec().decode(reader, reader.uint32()));\n                            break;\n                        case 4:\n                            obj.blockPresences.push(Message.BlockPresence.codec().decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            obj.pendingBytes = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Message.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Message.codec());\n    };\n    Message.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Message.codec());\n    };\n})(Message || (Message = {}));\n//# sourceMappingURL=message.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/message/message.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/network.js":
/*!*******************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/network.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_length_prefixed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-length-prefixed */ \"./node_modules/it-length-prefixed/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var it_take__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-take */ \"./node_modules/it-take/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var timeout_abort_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! timeout-abort-controller */ \"./node_modules/timeout-abort-controller/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\nconst DEFAULT_MAX_INBOUND_STREAMS = 1024;\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 1024;\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000;\nclass Network {\n    _log;\n    _libp2p;\n    _bitswap;\n    _protocols;\n    _stats;\n    _running;\n    _hashLoader;\n    _maxInboundStreams;\n    _maxOutboundStreams;\n    _incomingStreamTimeout;\n    _registrarIds;\n    constructor(libp2p, bitswap, stats, options = {}) {\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.logger)(libp2p.peerId, 'network');\n        this._libp2p = libp2p;\n        this._bitswap = bitswap;\n        this._protocols = [BITSWAP100];\n        if (options.b100Only !== true) {\n            // Latest bitswap first\n            this._protocols.unshift(BITSWAP110);\n            this._protocols.unshift(BITSWAP120);\n        }\n        this._stats = stats;\n        this._running = false;\n        // bind event listeners\n        this._onPeerConnect = this._onPeerConnect.bind(this);\n        this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n        this._onConnection = this._onConnection.bind(this);\n        this._hashLoader = options.hashLoader ?? {\n            async getHasher() {\n                throw new Error('Not implemented');\n            }\n        };\n        this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;\n        this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n        this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;\n    }\n    async start() {\n        this._running = true;\n        await this._libp2p.handle(this._protocols, this._onConnection, {\n            maxInboundStreams: this._maxInboundStreams,\n            maxOutboundStreams: this._maxOutboundStreams\n        });\n        // register protocol with topology\n        const topology = {\n            onConnect: this._onPeerConnect,\n            onDisconnect: this._onPeerDisconnect\n        };\n        /** @type {string[]} */\n        this._registrarIds = [];\n        for (const protocol of this._protocols) {\n            this._registrarIds.push(await this._libp2p.register(protocol, topology));\n        }\n        // All existing connections are like new ones for us\n        this._libp2p.getConnections().forEach(conn => {\n            this._onPeerConnect(conn.remotePeer);\n        });\n    }\n    async stop() {\n        this._running = false;\n        // Unhandle both, libp2p doesn't care if it's not already handled\n        await this._libp2p.unhandle(this._protocols);\n        // unregister protocol and handlers\n        if (this._registrarIds != null) {\n            for (const id of this._registrarIds) {\n                this._libp2p.unregister(id);\n            }\n            this._registrarIds = [];\n        }\n    }\n    /**\n     * Handles both types of incoming bitswap messages\n     */\n    _onConnection(info) {\n        if (!this._running) {\n            return;\n        }\n        const { stream, connection } = info;\n        const controller = new timeout_abort_controller__WEBPACK_IMPORTED_MODULE_6__.TimeoutController(this._incomingStreamTimeout);\n        Promise.resolve().then(async () => {\n            this._log('incoming new bitswap %s connection from %p', stream.protocol, connection.remotePeer);\n            const abortListener = () => {\n                stream.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('Incoming Bitswap stream timed out', 'ERR_TIMEOUT'));\n            };\n            let signal = AbortSignal.timeout(this._incomingStreamTimeout);\n            signal.addEventListener('abort', abortListener);\n            await (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)(stream, (source) => it_length_prefixed__WEBPACK_IMPORTED_MODULE_1__.decode(source), async (source) => {\n                for await (const data of source) {\n                    try {\n                        const message = await _message_index_js__WEBPACK_IMPORTED_MODULE_9__.BitswapMessage.deserialize(data.subarray(), this._hashLoader);\n                        await this._bitswap._receiveMessage(connection.remotePeer, message);\n                    }\n                    catch (err) {\n                        this._bitswap._receiveError(err);\n                        break;\n                    }\n                    // we have received some data so reset the timeout controller\n                    signal.removeEventListener('abort', abortListener);\n                    signal = AbortSignal.timeout(this._incomingStreamTimeout);\n                    signal.addEventListener('abort', abortListener);\n                }\n            });\n            await stream.close({\n                signal\n            });\n        })\n            .catch(err => {\n            this._log(err);\n            stream.abort(err);\n        })\n            .finally(() => {\n            controller.clear();\n        });\n    }\n    _onPeerConnect(peerId) {\n        this._bitswap._onPeerConnected(peerId);\n    }\n    _onPeerDisconnect(peerId) {\n        this._bitswap._onPeerDisconnected(peerId);\n    }\n    /**\n     * Find providers given a `cid`.\n     */\n    findProviders(cid, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:find-providers', cid));\n        return this._libp2p.contentRouting.findProviders(cid, options);\n    }\n    /**\n     * Find the providers of a given `cid` and connect to them.\n     */\n    async findAndConnect(cid, options) {\n        await (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,it_take__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,it_map__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.findProviders(cid, options), async (provider) => this.connectTo(provider.id, options)\n            .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err);\n        })), _constants_js__WEBPACK_IMPORTED_MODULE_10__.maxProvidersPerRequest))\n            .catch(err => {\n            this._log.error(err);\n        });\n    }\n    /**\n     * Tell the network we can provide content for the passed CID\n     */\n    async provide(cid, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:provide', cid));\n        await this._libp2p.contentRouting.provide(cid, options);\n    }\n    /**\n     * Connect to the given peer\n     * Send the given msg (instance of Message) to the given peer\n     */\n    async sendMessage(peer, msg, options = {}) {\n        if (!this._running)\n            throw new Error('network isn\\'t running');\n        const stringId = peer.toString();\n        this._log('sendMessage to %s', stringId, msg);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:send-wantlist', peer));\n        await this._writeMessage(peer, msg, options);\n        this._updateSentStats(peer, msg.blocks);\n    }\n    /**\n     * Connects to another peer\n     */\n    async connectTo(peer, options = {}) {\n        if (!this._running) {\n            throw new Error('network isn\\'t running');\n        }\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:dial', peer));\n        return this._libp2p.dial(peer, options);\n    }\n    _updateSentStats(peer, blocks) {\n        const peerId = peer.toString();\n        if (this._stats != null) {\n            for (const block of blocks.values()) {\n                this._stats.push(peerId, 'dataSent', block.length);\n            }\n            this._stats.push(peerId, 'blocksSent', blocks.size);\n        }\n    }\n    async _writeMessage(peerId, msg, options = {}) {\n        const stream = await this._libp2p.dialProtocol(peerId, [BITSWAP120, BITSWAP110, BITSWAP100]);\n        try {\n            /** @type {Uint8Array} */\n            let serialized;\n            switch (stream.protocol) {\n                case BITSWAP100:\n                    serialized = msg.serializeToBitswap100();\n                    break;\n                case BITSWAP110:\n                case BITSWAP120:\n                    serialized = msg.serializeToBitswap110();\n                    break;\n                default:\n                    throw new Error(`Unknown protocol: ${stream.protocol}`);\n            }\n            await (0,it_pipe__WEBPACK_IMPORTED_MODULE_3__.pipe)([serialized], (source) => it_length_prefixed__WEBPACK_IMPORTED_MODULE_1__.encode(source), stream);\n            await stream.close();\n        }\n        catch (err) {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('bitswap:network:send-wantlist:error', { peer: peerId, error: err }));\n            this._log(err);\n            stream.abort(err);\n        }\n    }\n}\n//# sourceMappingURL=network.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/network.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/notifications.js":
/*!*************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/notifications.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Notifications: () => (/* binding */ Notifications)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n\n\n\n\n\nconst unwantEvent = (cid) => `unwant:${(0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(cid.multihash.bytes, 'base64')}`;\nconst blockEvent = (cid) => `block:${(0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(cid.multihash.bytes, 'base64')}`;\nclass Notifications extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    _log;\n    /**\n     * Internal module used to track events about incoming blocks,\n     * wants and unwants.\n     */\n    constructor(peerId) {\n        super();\n        this.setMaxListeners(_constants_js__WEBPACK_IMPORTED_MODULE_3__.maxListeners);\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.logger)(peerId, 'notif');\n    }\n    /**\n     * Signal the system that we received `block`.\n     */\n    hasBlock(cid, block) {\n        const event = blockEvent(cid);\n        this._log(event);\n        this.emit(event, block);\n    }\n    /**\n     * Signal the system that we are waiting to receive the\n     * block associated with the given `cid`.\n     * Returns a Promise that resolves to the block when it is received,\n     * or undefined when the block is unwanted.\n     */\n    async wantBlock(cid, options = {}) {\n        if (cid == null) {\n            throw new Error('Not a valid cid');\n        }\n        const blockEvt = blockEvent(cid);\n        const unwantEvt = unwantEvent(cid);\n        this._log(`wantBlock:${cid}`);\n        return new Promise((resolve, reject) => {\n            const onUnwant = () => {\n                this.removeListener(blockEvt, onBlock);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_1__.CustomProgressEvent('bitswap:want-block:unwant', cid));\n                reject(new Error(`Block for ${cid} unwanted`));\n            };\n            const onBlock = (data) => {\n                this.removeListener(unwantEvt, onUnwant);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_1__.CustomProgressEvent('bitswap:want-block:block', cid));\n                resolve(data);\n            };\n            this.once(unwantEvt, onUnwant);\n            this.once(blockEvt, onBlock);\n            options.signal?.addEventListener('abort', () => {\n                this.removeListener(blockEvt, onBlock);\n                this.removeListener(unwantEvt, onUnwant);\n                reject(new Error(`Want for ${cid} aborted`));\n            });\n        });\n    }\n    /**\n     * Signal that the block is not wanted anymore\n     */\n    unwantBlock(cid) {\n        const event = unwantEvent(cid);\n        this._log(event);\n        this.emit(event);\n    }\n}\n//# sourceMappingURL=notifications.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/notifications.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/stats/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/stats/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stats: () => (/* binding */ Stats)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var _stat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stat.js */ \"./node_modules/ipfs-bitswap/dist/src/stats/stat.js\");\n\n\n\nconst defaultOptions = {\n    enabled: false,\n    computeThrottleTimeout: 1000,\n    computeThrottleMaxQueueSize: 1000,\n    movingAverageIntervals: [\n        60 * 1000, // 1 minute\n        5 * 60 * 1000, // 5 minutes\n        15 * 60 * 1000 // 15 minutes\n    ]\n};\nclass Stats extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    _initialCounters;\n    _options;\n    _enabled;\n    _global;\n    _peers;\n    constructor(libp2p, initialCounters = [], _options = defaultOptions) {\n        super();\n        const options = Object.assign({}, defaultOptions, _options);\n        if (typeof options.computeThrottleTimeout !== 'number') {\n            throw new Error('need computeThrottleTimeout');\n        }\n        if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n            throw new Error('need computeThrottleMaxQueueSize');\n        }\n        this._initialCounters = initialCounters;\n        this._options = options;\n        this._enabled = this._options.enabled;\n        this._global = new _stat_js__WEBPACK_IMPORTED_MODULE_1__.Stat(initialCounters, options);\n        this._global.on('update', (stats) => this.emit('update', stats));\n        this._peers = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_2__.trackedMap)({\n            name: 'ipfs_bitswap_stats_peers',\n            metrics: libp2p.metrics\n        });\n    }\n    enable() {\n        this._enabled = true;\n        this._options.enabled = true;\n        this._global.enable();\n    }\n    disable() {\n        this._enabled = false;\n        this._options.enabled = false;\n        this._global.disable();\n    }\n    stop() {\n        this._enabled = false;\n        this._global.stop();\n        for (const peerStat of this._peers) {\n            peerStat[1].stop();\n        }\n    }\n    get snapshot() {\n        return this._global.snapshot;\n    }\n    get movingAverages() {\n        return this._global.movingAverages;\n    }\n    forPeer(peerId) {\n        const peerIdStr = peerId.toString();\n        return this._peers.get(peerIdStr);\n    }\n    push(peer, counter, inc) {\n        if (this._enabled) {\n            this._global.push(counter, inc);\n            if (peer != null) {\n                let peerStats = this._peers.get(peer);\n                if (peerStats == null) {\n                    peerStats = new _stat_js__WEBPACK_IMPORTED_MODULE_1__.Stat(this._initialCounters, this._options);\n                    this._peers.set(peer, peerStats);\n                }\n                peerStats.push(counter, inc);\n            }\n        }\n    }\n    disconnected(peer) {\n        const peerId = peer.toString();\n        const peerStats = this._peers.get(peerId);\n        if (peerStats != null) {\n            peerStats.stop();\n            this._peers.delete(peerId);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/stats/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/stats/stat.js":
/*!**********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/stats/stat.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stat: () => (/* binding */ Stat)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var _vascosantos_moving_average__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vascosantos/moving-average */ \"./node_modules/@vascosantos/moving-average/index.js\");\n\n\nclass Stat extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    _options;\n    _queue;\n    _stats;\n    _frequencyLastTime;\n    _frequencyAccumulators;\n    _movingAverages;\n    _enabled;\n    _timeout;\n    constructor(initialCounters, options) {\n        super();\n        this._options = options;\n        this._queue = [];\n        this._stats = {};\n        this._frequencyLastTime = Date.now();\n        this._frequencyAccumulators = {};\n        this._movingAverages = {};\n        this._update = this._update.bind(this);\n        initialCounters.forEach((key) => {\n            this._stats[key] = BigInt(0);\n            this._movingAverages[key] = {};\n            this._options.movingAverageIntervals.forEach((interval) => {\n                const ma = this._movingAverages[key][interval] = _vascosantos_moving_average__WEBPACK_IMPORTED_MODULE_1__(interval);\n                ma.push(this._frequencyLastTime, 0);\n            });\n        });\n        this._enabled = this._options.enabled;\n    }\n    enable() {\n        this._enabled = true;\n    }\n    disable() {\n        this._enabled = false;\n    }\n    stop() {\n        if (this._timeout != null) {\n            clearTimeout(this._timeout);\n        }\n    }\n    get snapshot() {\n        return Object.assign({}, this._stats);\n    }\n    get movingAverages() {\n        return Object.assign({}, this._movingAverages);\n    }\n    push(counter, inc) {\n        if (this._enabled) {\n            this._queue.push([counter, inc, Date.now()]);\n            this._resetComputeTimeout();\n        }\n    }\n    _resetComputeTimeout() {\n        if (this._timeout != null) {\n            clearTimeout(this._timeout);\n        }\n        this._timeout = setTimeout(this._update, this._nextTimeout());\n    }\n    _nextTimeout() {\n        // calculate the need for an update, depending on the queue length\n        const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n        return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n    }\n    _update() {\n        this._timeout = undefined;\n        if (this._queue.length > 0) {\n            let last;\n            while (this._queue.length > 0) {\n                const op = last = this._queue.shift();\n                (op != null) && this._applyOp(op);\n            }\n            (last != null) && this._updateFrequency(last[2]); // contains timestamp of last op\n            this.emit('update', this._stats);\n        }\n    }\n    _updateFrequency(latestTime) {\n        const timeDiff = latestTime - this._frequencyLastTime;\n        if (timeDiff > 0) {\n            Object.keys(this._stats).forEach((key) => {\n                this._updateFrequencyFor(key, timeDiff, latestTime);\n            });\n        }\n        this._frequencyLastTime = latestTime;\n    }\n    _updateFrequencyFor(key, timeDiffMS, latestTime) {\n        const count = this._frequencyAccumulators[key] ?? 0;\n        this._frequencyAccumulators[key] = 0;\n        const hz = (count / timeDiffMS) * 1000;\n        let movingAverages = this._movingAverages[key];\n        if (movingAverages == null) {\n            movingAverages = this._movingAverages[key] = {};\n        }\n        this._options.movingAverageIntervals.forEach((movingAverageInterval) => {\n            let movingAverage = movingAverages[movingAverageInterval];\n            if (movingAverage == null) {\n                movingAverage = movingAverages[movingAverageInterval] = _vascosantos_moving_average__WEBPACK_IMPORTED_MODULE_1__(movingAverageInterval);\n            }\n            movingAverage.push(latestTime, hz);\n        });\n    }\n    _applyOp(op) {\n        const key = op[0];\n        const inc = op[1];\n        if (typeof inc !== 'number') {\n            throw new Error(`invalid increment number: ${inc}`);\n        }\n        if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n            this._stats[key] = BigInt(0);\n        }\n        this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);\n        if (this._frequencyAccumulators[key] == null) {\n            this._frequencyAccumulators[key] = 0;\n        }\n        this._frequencyAccumulators[key] += inc;\n    }\n}\n//# sourceMappingURL=stat.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/stats/stat.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   includesWith: () => (/* binding */ includesWith),\n/* harmony export */   isMapEqual: () => (/* binding */ isMapEqual),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   pullAllWith: () => (/* binding */ pullAllWith),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   uniqWith: () => (/* binding */ uniqWith)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var _message_entry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message/entry.js */ \"./node_modules/ipfs-bitswap/dist/src/message/entry.js\");\n\n\n\n/**\n * Creates a logger for the given subsystem\n */\nconst logger = (id, subsystem) => {\n    const name = ['bitswap'];\n    if (subsystem != null) {\n        name.push(subsystem);\n    }\n    if (id != null) {\n        name.push(`${id.toString().slice(0, 8)}`);\n    }\n    return (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_1__.logger)(name.join(':'));\n};\nconst includesWith = (pred, x, list) => {\n    let idx = 0;\n    const len = list.length;\n    while (idx < len) {\n        if (pred(x, list[idx])) {\n            return true;\n        }\n        idx += 1;\n    }\n    return false;\n};\nconst uniqWith = (pred, list) => {\n    let idx = 0;\n    const len = list.length;\n    const result = [];\n    let item;\n    while (idx < len) {\n        item = list[idx];\n        if (!includesWith(pred, item, result)) {\n            result[result.length] = item;\n        }\n        idx += 1;\n    }\n    return result;\n};\nconst groupBy = (pred, list) => {\n    // @ts-expect-error cannot use {} as record with these key types?\n    const output = {};\n    return list.reduce((acc, v) => {\n        const k = pred(v);\n        if (acc[k] != null) {\n            acc[k].push(v);\n        }\n        else {\n            acc[k] = [v];\n        }\n        return acc;\n    }, output);\n};\nconst pullAllWith = (pred, list, values) => {\n    return list.filter(i => {\n        return !includesWith(pred, i, values);\n    });\n};\nconst sortBy = (fn, list) => {\n    return Array.prototype.slice.call(list, 0).sort((a, b) => {\n        const aa = fn(a);\n        const bb = fn(b);\n        return aa < bb ? -1 : aa > bb ? 1 : 0;\n    });\n};\n/**\n * Is equal for Maps of BitswapMessageEntry or Uint8Arrays\n */\nconst isMapEqual = (a, b) => {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, valueA] of a) {\n        const valueB = b.get(key);\n        if (valueB === undefined) {\n            return false;\n        }\n        // TODO: revisit this\n        // Support Blocks\n        if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_0__.equals)(valueA, valueB)) {\n            return false;\n        }\n        // Support BitswapMessageEntry\n        if (valueA instanceof _message_entry_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessageEntry && valueB instanceof _message_entry_js__WEBPACK_IMPORTED_MODULE_2__.BitswapMessageEntry && !valueA.equals(valueB)) {\n            return false;\n        }\n    }\n    return true;\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/utils/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js":
/*!****************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SortedMap: () => (/* binding */ SortedMap)\n/* harmony export */ });\n/**\n * SortedMap is a Map whose iterator order can be defined by the user\n */\nclass SortedMap extends Map {\n    _cmp;\n    _keys;\n    constructor(entries, cmp) {\n        super();\n        this._cmp = cmp ?? this._defaultSort;\n        this._keys = [];\n        for (const [k, v] of entries ?? []) {\n            this.set(k, v);\n        }\n    }\n    /**\n     * Call update to update the position of the key when it should change.\n     * For example if the compare function sorts by the priority field, and the\n     * priority changes, call update.\n     * Call indexOf() to get the index _before_ the change happens.\n     */\n    update(i) {\n        if (i < 0 || i >= this._keys.length) {\n            return;\n        }\n        const k = this._keys[i];\n        this._keys.splice(i, 1);\n        const newIdx = this._find(k);\n        this._keys.splice(newIdx, 0, k);\n    }\n    set(k, v) {\n        // If the key is already in the map, remove it from the ordering and\n        // re-insert it below\n        if (this.has(k)) {\n            const i = this.indexOf(k);\n            this._keys.splice(i, 1);\n        }\n        // Update / insert the k/v into the map\n        super.set(k, v);\n        // Find the correct position of the newly inserted k/v in the order\n        const i = this._find(k);\n        this._keys.splice(i, 0, k);\n        return this;\n    }\n    clear() {\n        super.clear();\n        this._keys = [];\n    }\n    delete(k) {\n        if (!this.has(k)) {\n            return false;\n        }\n        const i = this.indexOf(k);\n        this._keys.splice(i, 1);\n        return super.delete(k);\n    }\n    indexOf(k) {\n        if (!this.has(k)) {\n            return -1;\n        }\n        const i = this._find(k);\n        if (this._keys[i] === k) {\n            return i;\n        }\n        // There may be more than one key with the same ordering\n        // eg { k1: <priority 5>, k2: <priority 5> }\n        // so scan outwards until the key matches\n        for (let j = 1; j < this._keys.length; j++) {\n            if (this._keys[i + j] === k)\n                return i + j;\n            if (this._keys[i - j] === k)\n                return i - j;\n        }\n        return -1; // should never happen for existing key\n    }\n    _find(k) {\n        let lower = 0;\n        let upper = this._keys.length;\n        while (lower < upper) {\n            const pivot = (lower + upper) >>> 1; // lower + (upper - lower) / 2\n            const cmp = this._kCmp(this._keys[pivot], k);\n            // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n            if (cmp < 0) { // pivot < k\n                lower = pivot + 1;\n            }\n            else if (cmp > 0) { // pivot > k\n                upper = pivot;\n            }\n            else { // pivot == k\n                return pivot;\n            }\n        }\n        return lower;\n    }\n    *keys() {\n        for (const k of this._keys) {\n            yield k;\n        }\n        return undefined;\n    }\n    *values() {\n        for (const k of this._keys) {\n            // @ts-expect-error - return of `this.get(k)` is `Value|undefined` which is\n            // incompatible with `Value`. Typechecker can't that this contains values\n            // for all the `_keys`. ts(2322)\n            yield this.get(k);\n        }\n        return undefined;\n    }\n    *entries() {\n        for (const k of this._keys) {\n            // @ts-expect-error - return of `this.get(k)` is `Value|undefined` which is\n            // incompatible with `Value`. Typechecker can't that this contains values\n            // for all the `_keys`. ts(2322)\n            yield [k, this.get(k)];\n        }\n        return undefined;\n    }\n    *[Symbol.iterator]() {\n        yield* this.entries();\n    }\n    // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void\n    forEach(cb, thisArg = this) {\n        if (cb == null) {\n            return;\n        }\n        for (const k of this._keys) {\n            const val = this.get(k);\n            if (val == null) {\n                throw new Error('Value cannot be undefined');\n            }\n            cb.apply(thisArg, [[k, val]]);\n        }\n    }\n    _defaultSort(a, b) {\n        if (a[0] < b[0])\n            return -1;\n        if (b[0] < a[0])\n            return 1;\n        return 0;\n    }\n    _kCmp(a, b) {\n        return this._cmp(\n        // @ts-expect-error - get may return undefined\n        [a, this.get(a)], [b, this.get(b)]);\n    }\n}\n//# sourceMappingURL=sorted-map.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/utils/sorted-map.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js":
/*!********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! varint */ \"./node_modules/varint/index.js\");\n\nfunction varintEncoder(buf) {\n    let out = new Uint8Array(buf.reduce((acc, curr) => {\n        // @ts-expect-error types are wrong\n        return acc + varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(curr); // eslint-disable-line @typescript-eslint/restrict-plus-operands\n    }, 0));\n    let offset = 0;\n    for (const num of buf) {\n        out = varint__WEBPACK_IMPORTED_MODULE_0__.encode(num, out, offset);\n        // @ts-expect-error types are wrong\n        offset += varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(num); // eslint-disable-line @typescript-eslint/restrict-plus-operands\n    }\n    return out;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (varintEncoder);\n//# sourceMappingURL=varint-encoder.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/utils/varint-encoder.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/want-manager/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/want-manager/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WantManager: () => (/* binding */ WantManager)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n/* harmony import */ var _wantlist_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wantlist/index.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/index.js\");\n/* harmony import */ var _msg_queue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./msg-queue.js */ \"./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js\");\n\n\n\n\n\n\n\nclass WantManager {\n    peers;\n    wantlist;\n    network;\n    _peerId;\n    _log;\n    constructor(peerId, network, stats, libp2p) {\n        this.peers = (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_1__.trackedMap)({\n            name: 'ipfs_bitswap_want_manager_peers',\n            metrics: libp2p.metrics\n        });\n        this.wantlist = new _wantlist_index_js__WEBPACK_IMPORTED_MODULE_2__.Wantlist(stats, libp2p);\n        this.network = network;\n        this._peerId = peerId;\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.logger)(peerId, 'want');\n    }\n    _addEntries(cids, cancel, force, options = {}) {\n        const entries = cids.map((cid, i) => {\n            return new _message_index_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessage.Entry(cid, _constants_js__WEBPACK_IMPORTED_MODULE_5__.kMaxPriority - i, _message_index_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessage.WantType.Block, cancel);\n        });\n        entries.forEach((e) => {\n            // add changes to our wantlist\n            if (e.cancel) {\n                if (force === true) {\n                    this.wantlist.removeForce(e.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc));\n                }\n                else {\n                    this.wantlist.remove(e.cid);\n                }\n            }\n            else {\n                this._log('adding to wantlist');\n                // TODO: Figure out the wantType\n                // @ts-expect-error - requires wantType\n                this.wantlist.add(e.cid, e.priority);\n            }\n        });\n        // broadcast changes\n        for (const p of this.peers.values()) {\n            p.addEntries(entries, options);\n        }\n    }\n    _startPeerHandler(peerId) {\n        let mq = this.peers.get(peerId.toString());\n        if (mq != null) {\n            mq.refcnt++;\n            return;\n        }\n        mq = new _msg_queue_js__WEBPACK_IMPORTED_MODULE_6__.MsgQueue(this._peerId, peerId, this.network);\n        // new peer, give them the full wantlist\n        const fullwantlist = new _message_index_js__WEBPACK_IMPORTED_MODULE_4__.BitswapMessage(true);\n        for (const entry of this.wantlist.entries()) {\n            fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n        }\n        mq.addMessage(fullwantlist);\n        this.peers.set(peerId.toString(), mq);\n        return mq;\n    }\n    _stopPeerHandler(peerId) {\n        const mq = this.peers.get(peerId.toString());\n        if (mq == null) {\n            return;\n        }\n        mq.refcnt--;\n        if (mq.refcnt > 0) {\n            return;\n        }\n        this.peers.delete(peerId.toString());\n    }\n    /**\n     * add all the cids to the wantlist\n     */\n    wantBlocks(cids, options = {}) {\n        this._addEntries(cids, false, false, options);\n        options.signal?.addEventListener('abort', () => {\n            this.cancelWants(cids);\n        });\n    }\n    /**\n     * Remove blocks of all the given keys without respecting refcounts\n     */\n    unwantBlocks(cids) {\n        this._log('unwant blocks: %s', cids.length);\n        this._addEntries(cids, true, true);\n    }\n    /**\n     * Cancel wanting all of the given keys\n     */\n    cancelWants(cids) {\n        this._log('cancel wants: %s', cids.length);\n        this._addEntries(cids, true);\n    }\n    /**\n     * Returns a list of all currently connected peers\n     */\n    connectedPeers() {\n        return Array.from(this.peers.keys());\n    }\n    connected(peerId) {\n        this._startPeerHandler(peerId);\n    }\n    disconnected(peerId) {\n        this._stopPeerHandler(peerId);\n    }\n    start() {\n    }\n    stop() {\n        this.peers.forEach((mq) => { this.disconnected(mq.peerId); });\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/want-manager/index.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MsgQueue: () => (/* binding */ MsgQueue)\n/* harmony export */ });\n/* harmony import */ var just_debounce_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! just-debounce-it */ \"./node_modules/just-debounce-it/index.mjs\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/ipfs-bitswap/dist/src/constants.js\");\n/* harmony import */ var _message_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../message/index.js */ \"./node_modules/ipfs-bitswap/dist/src/message/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/ipfs-bitswap/dist/src/utils/index.js\");\n\n\n\n\nclass MsgQueue {\n    peerId;\n    refcnt;\n    network;\n    _entries;\n    _log;\n    constructor(selfPeerId, otherPeerId, network) {\n        this.peerId = otherPeerId;\n        this.network = network;\n        this.refcnt = 1;\n        this._entries = [];\n        this._log = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.logger)(selfPeerId, 'msgqueue');\n        this.sendEntries = (0,just_debounce_it__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.sendEntries.bind(this), _constants_js__WEBPACK_IMPORTED_MODULE_2__.wantlistSendDebounceMs);\n    }\n    addMessage(msg, options = {}) {\n        if (msg.empty) {\n            return;\n        }\n        void this.send(msg, options);\n    }\n    addEntries(entries, options = {}) {\n        this._entries = this._entries.concat(entries);\n        this.sendEntries(options);\n    }\n    sendEntries(options = {}) {\n        if (this._entries.length === 0) {\n            return;\n        }\n        const msg = new _message_index_js__WEBPACK_IMPORTED_MODULE_3__.BitswapMessage(false);\n        this._entries.forEach((entry) => {\n            if (entry.cancel === true) {\n                msg.cancel(entry.cid);\n            }\n            else {\n                msg.addEntry(entry.cid, entry.priority);\n            }\n        });\n        this._entries = [];\n        this.addMessage(msg, options);\n    }\n    async send(msg, options = {}) {\n        try {\n            await this.network.connectTo(this.peerId, options);\n        }\n        catch (err) {\n            this._log.error('cant connect to peer %p: %s', this.peerId, err.message);\n            return;\n        }\n        this._log('sending message to peer %p', this.peerId);\n        // Note: Don't wait for sendMessage() to complete\n        this.network.sendMessage(this.peerId, msg, options).catch((err) => {\n            this._log.error('send error', err);\n        });\n    }\n}\n//# sourceMappingURL=msg-queue.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/want-manager/msg-queue.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WantListEntry: () => (/* binding */ WantListEntry)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n\nclass WantListEntry {\n    _refCounter;\n    cid;\n    priority;\n    wantType;\n    constructor(cid, priority, wantType) {\n        // Keep track of how many requests we have for this key\n        this._refCounter = 1;\n        this.cid = cid;\n        this.priority = priority ?? 1;\n        this.wantType = wantType;\n    }\n    inc() {\n        this._refCounter += 1;\n    }\n    dec() {\n        this._refCounter = Math.max(0, this._refCounter - 1);\n    }\n    hasRefs() {\n        return this._refCounter > 0;\n    }\n    // So that console.log prints a nice description of this object\n    get [Symbol.toStringTag]() {\n        const cidStr = this.cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;\n    }\n    equals(other) {\n        return (this._refCounter === other._refCounter) &&\n            this.cid.equals(other.cid) &&\n            this.priority === other.priority &&\n            this.wantType === other.wantType;\n    }\n}\n//# sourceMappingURL=entry.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js?");

/***/ }),

/***/ "./node_modules/ipfs-bitswap/dist/src/wantlist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/ipfs-bitswap/dist/src/wantlist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wantlist: () => (/* binding */ Wantlist)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/utils/tracked-map */ \"./node_modules/@libp2p/utils/dist/src/tracked-map.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _message_message_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../message/message.js */ \"./node_modules/ipfs-bitswap/dist/src/message/message.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entry.js */ \"./node_modules/ipfs-bitswap/dist/src/wantlist/entry.js\");\n\n\n\n\nconst WantType = {\n    Block: _message_message_js__WEBPACK_IMPORTED_MODULE_1__.Message.Wantlist.WantType.Block,\n    Have: _message_message_js__WEBPACK_IMPORTED_MODULE_1__.Message.Wantlist.WantType.Have\n};\nconst sortBy = (fn, list) => {\n    return Array.prototype.slice.call(list, 0).sort((a, b) => {\n        const aa = fn(a);\n        const bb = fn(b);\n        return aa < bb ? -1 : aa > bb ? 1 : 0;\n    });\n};\nclass Wantlist {\n    static Entry = _entry_js__WEBPACK_IMPORTED_MODULE_2__.WantListEntry;\n    set;\n    _stats;\n    constructor(stats, libp2p) {\n        this.set = (libp2p != null)\n            ? (0,_libp2p_utils_tracked_map__WEBPACK_IMPORTED_MODULE_3__.trackedMap)({\n                name: 'ipfs_bitswap_wantlist',\n                metrics: libp2p.metrics\n            })\n            : new Map();\n        this._stats = stats;\n    }\n    get length() {\n        return this.set.size;\n    }\n    add(cid, priority, wantType) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        const entry = this.set.get(cidStr);\n        if (entry != null) {\n            entry.inc();\n            entry.priority = priority;\n            // We can only overwrite want-have with want-block\n            if (entry.wantType === WantType.Have && wantType === WantType.Block) {\n                entry.wantType = wantType;\n            }\n        }\n        else {\n            this.set.set(cidStr, new _entry_js__WEBPACK_IMPORTED_MODULE_2__.WantListEntry(cid, priority, wantType));\n            if (this._stats != null) {\n                this._stats.push(undefined, 'wantListSize', 1);\n            }\n        }\n    }\n    remove(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        const entry = this.set.get(cidStr);\n        if (entry == null) {\n            return;\n        }\n        entry.dec();\n        // only delete when no refs are held\n        if (entry.hasRefs()) {\n            return;\n        }\n        this.set.delete(cidStr);\n        if (this._stats != null) {\n            this._stats.push(undefined, 'wantListSize', -1);\n        }\n    }\n    removeForce(cidStr) {\n        if (this.set.has(cidStr)) {\n            this.set.delete(cidStr);\n        }\n    }\n    forEach(fn) {\n        this.set.forEach(fn);\n    }\n    entries() {\n        return this.set.entries();\n    }\n    sortedEntries() {\n        // TODO: Figure out if this is an actual bug.\n        // @ts-expect-error - Property 'key' does not exist on type 'WantListEntry'\n        return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())));\n    }\n    contains(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return this.set.has(cidStr);\n    }\n    get(cid) {\n        const cidStr = cid.toString(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc);\n        return this.set.get(cidStr);\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipfs-bitswap/dist/src/wantlist/index.js?");

/***/ }),

/***/ "./node_modules/ipns/dist/src/errors.js":
/*!**********************************************!*\
  !*** ./node_modules/ipns/dist/src/errors.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERR_INVALID_EMBEDDED_KEY: () => (/* binding */ ERR_INVALID_EMBEDDED_KEY),\n/* harmony export */   ERR_INVALID_RECORD_DATA: () => (/* binding */ ERR_INVALID_RECORD_DATA),\n/* harmony export */   ERR_INVALID_VALUE: () => (/* binding */ ERR_INVALID_VALUE),\n/* harmony export */   ERR_IPNS_EXPIRED_RECORD: () => (/* binding */ ERR_IPNS_EXPIRED_RECORD),\n/* harmony export */   ERR_MISSING_PRIVATE_KEY: () => (/* binding */ ERR_MISSING_PRIVATE_KEY),\n/* harmony export */   ERR_PEER_ID_FROM_PUBLIC_KEY: () => (/* binding */ ERR_PEER_ID_FROM_PUBLIC_KEY),\n/* harmony export */   ERR_PUBLIC_KEY_FROM_ID: () => (/* binding */ ERR_PUBLIC_KEY_FROM_ID),\n/* harmony export */   ERR_RECORD_TOO_LARGE: () => (/* binding */ ERR_RECORD_TOO_LARGE),\n/* harmony export */   ERR_SIGNATURE_CREATION: () => (/* binding */ ERR_SIGNATURE_CREATION),\n/* harmony export */   ERR_SIGNATURE_VERIFICATION: () => (/* binding */ ERR_SIGNATURE_VERIFICATION),\n/* harmony export */   ERR_UNDEFINED_PARAMETER: () => (/* binding */ ERR_UNDEFINED_PARAMETER),\n/* harmony export */   ERR_UNRECOGNIZED_FORMAT: () => (/* binding */ ERR_UNRECOGNIZED_FORMAT),\n/* harmony export */   ERR_UNRECOGNIZED_VALIDITY: () => (/* binding */ ERR_UNRECOGNIZED_VALIDITY)\n/* harmony export */ });\nconst ERR_IPNS_EXPIRED_RECORD = 'ERR_IPNS_EXPIRED_RECORD';\nconst ERR_UNRECOGNIZED_VALIDITY = 'ERR_UNRECOGNIZED_VALIDITY';\nconst ERR_SIGNATURE_CREATION = 'ERR_SIGNATURE_CREATION';\nconst ERR_SIGNATURE_VERIFICATION = 'ERR_SIGNATURE_VERIFICATION';\nconst ERR_UNRECOGNIZED_FORMAT = 'ERR_UNRECOGNIZED_FORMAT';\nconst ERR_PEER_ID_FROM_PUBLIC_KEY = 'ERR_PEER_ID_FROM_PUBLIC_KEY';\nconst ERR_PUBLIC_KEY_FROM_ID = 'ERR_PUBLIC_KEY_FROM_ID';\nconst ERR_UNDEFINED_PARAMETER = 'ERR_UNDEFINED_PARAMETER';\nconst ERR_INVALID_RECORD_DATA = 'ERR_INVALID_RECORD_DATA';\nconst ERR_INVALID_VALUE = 'ERR_INVALID_VALUE';\nconst ERR_INVALID_EMBEDDED_KEY = 'ERR_INVALID_EMBEDDED_KEY';\nconst ERR_MISSING_PRIVATE_KEY = 'ERR_MISSING_PRIVATE_KEY';\nconst ERR_RECORD_TOO_LARGE = 'ERR_RECORD_TOO_LARGE';\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipns/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/ipns/dist/src/pb/ipns.js":
/*!***********************************************!*\
  !*** ./node_modules/ipns/dist/src/pb/ipns.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpnsEntry: () => (/* binding */ IpnsEntry)\n/* harmony export */ });\n/* harmony import */ var protons_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protons-runtime */ \"./node_modules/protons-runtime/dist/src/index.js\");\n/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nvar IpnsEntry;\n(function (IpnsEntry) {\n    let ValidityType;\n    (function (ValidityType) {\n        ValidityType[\"EOL\"] = \"EOL\";\n    })(ValidityType = IpnsEntry.ValidityType || (IpnsEntry.ValidityType = {}));\n    let __ValidityTypeValues;\n    (function (__ValidityTypeValues) {\n        __ValidityTypeValues[__ValidityTypeValues[\"EOL\"] = 0] = \"EOL\";\n    })(__ValidityTypeValues || (__ValidityTypeValues = {}));\n    (function (ValidityType) {\n        ValidityType.codec = () => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__ValidityTypeValues);\n        };\n    })(ValidityType = IpnsEntry.ValidityType || (IpnsEntry.ValidityType = {}));\n    let _codec;\n    IpnsEntry.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.value != null) {\n                    w.uint32(10);\n                    w.bytes(obj.value);\n                }\n                if (obj.signatureV1 != null) {\n                    w.uint32(18);\n                    w.bytes(obj.signatureV1);\n                }\n                if (obj.validityType != null) {\n                    w.uint32(24);\n                    IpnsEntry.ValidityType.codec().encode(obj.validityType, w);\n                }\n                if (obj.validity != null) {\n                    w.uint32(34);\n                    w.bytes(obj.validity);\n                }\n                if (obj.sequence != null) {\n                    w.uint32(40);\n                    w.uint64(obj.sequence);\n                }\n                if (obj.ttl != null) {\n                    w.uint32(48);\n                    w.uint64(obj.ttl);\n                }\n                if (obj.pubKey != null) {\n                    w.uint32(58);\n                    w.bytes(obj.pubKey);\n                }\n                if (obj.signatureV2 != null) {\n                    w.uint32(66);\n                    w.bytes(obj.signatureV2);\n                }\n                if (obj.data != null) {\n                    w.uint32(74);\n                    w.bytes(obj.data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.value = reader.bytes();\n                            break;\n                        case 2:\n                            obj.signatureV1 = reader.bytes();\n                            break;\n                        case 3:\n                            obj.validityType = IpnsEntry.ValidityType.codec().decode(reader);\n                            break;\n                        case 4:\n                            obj.validity = reader.bytes();\n                            break;\n                        case 5:\n                            obj.sequence = reader.uint64();\n                            break;\n                        case 6:\n                            obj.ttl = reader.uint64();\n                            break;\n                        case 7:\n                            obj.pubKey = reader.bytes();\n                            break;\n                        case 8:\n                            obj.signatureV2 = reader.bytes();\n                            break;\n                        case 9:\n                            obj.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    IpnsEntry.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, IpnsEntry.codec());\n    };\n    IpnsEntry.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, IpnsEntry.codec());\n    };\n})(IpnsEntry || (IpnsEntry = {}));\n//# sourceMappingURL=ipns.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipns/dist/src/pb/ipns.js?");

/***/ }),

/***/ "./node_modules/ipns/dist/src/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/ipns/dist/src/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCborData: () => (/* binding */ createCborData),\n/* harmony export */   extractPublicKey: () => (/* binding */ extractPublicKey),\n/* harmony export */   ipnsRecordDataForV1Sig: () => (/* binding */ ipnsRecordDataForV1Sig),\n/* harmony export */   ipnsRecordDataForV2Sig: () => (/* binding */ ipnsRecordDataForV2Sig),\n/* harmony export */   marshal: () => (/* binding */ marshal),\n/* harmony export */   normalizeValue: () => (/* binding */ normalizeValue),\n/* harmony export */   parseCborData: () => (/* binding */ parseCborData),\n/* harmony export */   peerIdFromRoutingKey: () => (/* binding */ peerIdFromRoutingKey),\n/* harmony export */   peerIdToRoutingKey: () => (/* binding */ peerIdToRoutingKey),\n/* harmony export */   unmarshal: () => (/* binding */ unmarshal)\n/* harmony export */ });\n/* harmony import */ var _libp2p_crypto_keys__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/crypto/keys */ \"./node_modules/@libp2p/crypto/dist/src/keys/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/peer-id/index.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @libp2p/peer-id */ \"./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base36 */ \"./node_modules/multiformats/dist/src/bases/base36.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/ipns/dist/src/errors.js\");\n/* harmony import */ var _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pb/ipns.js */ \"./node_modules/ipns/dist/src/pb/ipns.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_8__.logger)('ipns:utils');\nconst IPNS_PREFIX = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_6__.fromString)('/ipns/');\nconst LIBP2P_CID_CODEC = 114;\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record\n */\nconst extractPublicKey = async (peerId, record) => {\n    if (record == null || peerId == null) {\n        const error = new Error('one or more of the provided parameters are not defined');\n        log.error(error);\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(error, _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_UNDEFINED_PARAMETER);\n    }\n    let pubKey;\n    if (record.pubKey != null) {\n        try {\n            pubKey = (0,_libp2p_crypto_keys__WEBPACK_IMPORTED_MODULE_10__.unmarshalPublicKey)(record.pubKey);\n        }\n        catch (err) {\n            log.error(err);\n            throw err;\n        }\n        const otherId = await (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_11__.peerIdFromKeys)(record.pubKey);\n        if (!otherId.equals(peerId)) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Embedded public key did not match PeerID'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_INVALID_EMBEDDED_KEY);\n        }\n    }\n    else if (peerId.publicKey != null) {\n        pubKey = (0,_libp2p_crypto_keys__WEBPACK_IMPORTED_MODULE_10__.unmarshalPublicKey)(peerId.publicKey);\n    }\n    if (pubKey != null) {\n        return pubKey;\n    }\n    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('no public key is available'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_UNDEFINED_PARAMETER);\n};\n/**\n * Utility for creating the record data for being signed\n */\nconst ipnsRecordDataForV1Sig = (value, validityType, validity) => {\n    const validityTypeBuffer = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_6__.fromString)(validityType);\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_4__.concat)([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n */\nconst ipnsRecordDataForV2Sig = (data) => {\n    const entryData = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_6__.fromString)('ipns-signature:');\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_4__.concat)([entryData, data]);\n};\nconst marshal = (obj) => {\n    if ('signatureV1' in obj) {\n        return _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.encode({\n            value: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_6__.fromString)(obj.value),\n            signatureV1: obj.signatureV1,\n            validityType: obj.validityType,\n            validity: (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_6__.fromString)(obj.validity),\n            sequence: obj.sequence,\n            ttl: obj.ttl,\n            pubKey: obj.pubKey,\n            signatureV2: obj.signatureV2,\n            data: obj.data\n        });\n    }\n    else {\n        return _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.encode({\n            pubKey: obj.pubKey,\n            signatureV2: obj.signatureV2,\n            data: obj.data\n        });\n    }\n};\nfunction unmarshal(buf) {\n    const message = _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.decode(buf);\n    // protobufjs returns bigints as numbers\n    if (message.sequence != null) {\n        message.sequence = BigInt(message.sequence);\n    }\n    // protobufjs returns bigints as numbers\n    if (message.ttl != null) {\n        message.ttl = BigInt(message.ttl);\n    }\n    // Check if we have the data field. If we don't, we fail. We've been producing\n    // V1+V2 records for quite a while and we don't support V1-only records during\n    // validation any more\n    if (message.signatureV2 == null || message.data == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('missing data or signatureV2'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_SIGNATURE_VERIFICATION);\n    }\n    const data = parseCborData(message.data);\n    const value = normalizeValue(data.Value);\n    const validity = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__.toString)(data.Validity);\n    if (message.value != null && message.signatureV1 != null) {\n        // V1+V2\n        validateCborDataMatchesPbData(message);\n        return {\n            value,\n            validityType: _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.ValidityType.EOL,\n            validity,\n            sequence: data.Sequence,\n            ttl: data.TTL,\n            pubKey: message.pubKey,\n            signatureV1: message.signatureV1,\n            signatureV2: message.signatureV2,\n            data: message.data\n        };\n    }\n    else if (message.signatureV2 != null) {\n        // V2-only\n        return {\n            value,\n            validityType: _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.ValidityType.EOL,\n            validity,\n            sequence: data.Sequence,\n            ttl: data.TTL,\n            pubKey: message.pubKey,\n            signatureV2: message.signatureV2,\n            data: message.data\n        };\n    }\n    else {\n        throw new Error('invalid record: does not include signatureV1 or signatureV2');\n    }\n}\nconst peerIdToRoutingKey = (peerId) => {\n    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_4__.concat)([\n        IPNS_PREFIX,\n        peerId.toBytes()\n    ]);\n};\nconst peerIdFromRoutingKey = (key) => {\n    return (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_11__.peerIdFromBytes)(key.slice(IPNS_PREFIX.length));\n};\nconst createCborData = (value, validityType, validity, sequence, ttl) => {\n    let ValidityType;\n    if (validityType === _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.ValidityType.EOL) {\n        ValidityType = 0;\n    }\n    else {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Unknown validity type'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_UNRECOGNIZED_VALIDITY);\n    }\n    const data = {\n        Value: value,\n        Validity: validity,\n        ValidityType,\n        Sequence: sequence,\n        TTL: ttl\n    };\n    return cborg__WEBPACK_IMPORTED_MODULE_0__.encode(data);\n};\nconst parseCborData = (buf) => {\n    const data = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(buf);\n    if (data.ValidityType === 0) {\n        data.ValidityType = _pb_ipns_js__WEBPACK_IMPORTED_MODULE_12__.IpnsEntry.ValidityType.EOL;\n    }\n    else {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Unknown validity type'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_UNRECOGNIZED_VALIDITY);\n    }\n    if (Number.isInteger(data.Sequence)) {\n        // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n        data.Sequence = BigInt(data.Sequence);\n    }\n    if (Number.isInteger(data.TTL)) {\n        // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n        data.TTL = BigInt(data.TTL);\n    }\n    return data;\n};\n/**\n * Normalizes the given record value. It ensures it is a PeerID, a CID or a\n * string starting with '/'. PeerIDs become `/ipns/${cidV1Libp2pKey}`,\n * CIDs become `/ipfs/${cidAsV1}`.\n */\nconst normalizeValue = (value) => {\n    if (value != null) {\n        // if we have a PeerId, turn it into an ipns path\n        if ((0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_13__.isPeerId)(value)) {\n            return `/ipns/${value.toCID().toString(multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36)}`;\n        }\n        // if the value is bytes, stringify it and see if we have a path\n        if (value instanceof Uint8Array) {\n            const string = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__.toString)(value);\n            if (string.startsWith('/')) {\n                value = string;\n            }\n        }\n        // if we have a path, check it is a valid path\n        const string = value.toString().trim();\n        if (string.startsWith('/') && string.length > 1) {\n            return string;\n        }\n        // if we have a CID, turn it into an ipfs path\n        const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.asCID(value);\n        if (cid != null) {\n            // PeerID encoded as a CID\n            if (cid.code === LIBP2P_CID_CODEC) {\n                return `/ipns/${cid.toString(multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36)}`;\n            }\n            return `/ipfs/${cid.toV1().toString()}`;\n        }\n        // try parsing what we have as CID bytes or a CID string\n        try {\n            if (value instanceof Uint8Array) {\n                return `/ipfs/${multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.decode(value).toV1().toString()}`;\n            }\n            return `/ipfs/${multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.parse(string).toV1().toString()}`;\n        }\n        catch {\n            // fall through\n        }\n    }\n    throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Value must be a valid content path starting with /'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_INVALID_VALUE);\n};\nconst validateCborDataMatchesPbData = (entry) => {\n    if (entry.data == null) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Record data is missing'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_INVALID_RECORD_DATA);\n    }\n    const data = parseCborData(entry.data);\n    if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(data.Value, entry.value ?? new Uint8Array(0))) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Field \"value\" did not match between protobuf and CBOR'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(data.Validity, entry.validity ?? new Uint8Array(0))) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Field \"validity\" did not match between protobuf and CBOR'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (data.ValidityType !== entry.validityType) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Field \"validityType\" did not match between protobuf and CBOR'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (data.Sequence !== entry.sequence) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Field \"sequence\" did not match between protobuf and CBOR'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_SIGNATURE_VERIFICATION);\n    }\n    if (data.TTL !== entry.ttl) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_1__(new Error('Field \"ttl\" did not match between protobuf and CBOR'), _errors_js__WEBPACK_IMPORTED_MODULE_9__.ERR_SIGNATURE_VERIFICATION);\n    }\n};\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipns/dist/src/utils.js?");

/***/ }),

/***/ "./node_modules/ipns/dist/src/validator.js":
/*!*************************************************!*\
  !*** ./node_modules/ipns/dist/src/validator.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ipnsValidator: () => (/* binding */ ipnsValidator),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var timestamp_nano__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! timestamp-nano */ \"./node_modules/timestamp-nano/dist/timestamp.min.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/ipns/dist/src/errors.js\");\n/* harmony import */ var _pb_ipns_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pb/ipns.js */ \"./node_modules/ipns/dist/src/pb/ipns.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/ipns/dist/src/utils.js\");\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_2__.logger)('ipns:validator');\n/**\n * Limit valid IPNS record sizes to 10kb\n */\nconst MAX_RECORD_SIZE = 1024 * 10;\n/**\n * Validates the given IPNS Record against the given public key. We need a \"raw\"\n * record in order to be able to access to all of its fields.\n */\nconst validate = async (publicKey, buf) => {\n    // unmarshal ensures that (1) SignatureV2 and Data are present, (2) that ValidityType\n    // and Validity are of valid types and have a value, (3) that CBOR data matches protobuf\n    // if it's a V1+V2 record.\n    const record = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.unmarshal)(buf);\n    // Validate Signature V2\n    let isValid;\n    try {\n        const dataForSignature = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.ipnsRecordDataForV2Sig)(record.data);\n        isValid = await publicKey.verify(dataForSignature, record.signatureV2);\n    }\n    catch (err) {\n        isValid = false;\n    }\n    if (!isValid) {\n        log.error('record signature verification failed');\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('record signature verification failed'), _errors_js__WEBPACK_IMPORTED_MODULE_4__.ERR_SIGNATURE_VERIFICATION);\n    }\n    // Validate according to the validity type\n    if (record.validityType === _pb_ipns_js__WEBPACK_IMPORTED_MODULE_5__.IpnsEntry.ValidityType.EOL) {\n        if (timestamp_nano__WEBPACK_IMPORTED_MODULE_1__.fromString(record.validity).toDate().getTime() < Date.now()) {\n            log.error('record has expired');\n            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('record has expired'), _errors_js__WEBPACK_IMPORTED_MODULE_4__.ERR_IPNS_EXPIRED_RECORD);\n        }\n    }\n    else if (record.validityType != null) {\n        log.error('unrecognized validity type');\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('unrecognized validity type'), _errors_js__WEBPACK_IMPORTED_MODULE_4__.ERR_UNRECOGNIZED_VALIDITY);\n    }\n    log('ipns record for %s is valid', record.value);\n};\nasync function ipnsValidator(key, marshalledData) {\n    if (marshalledData.byteLength > MAX_RECORD_SIZE) {\n        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('record too large'), _errors_js__WEBPACK_IMPORTED_MODULE_4__.ERR_RECORD_TOO_LARGE);\n    }\n    const peerId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.peerIdFromRoutingKey)(key);\n    const receivedRecord = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.unmarshal)(marshalledData);\n    // extract public key\n    const pubKey = await (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.extractPublicKey)(peerId, receivedRecord);\n    // Record validation\n    await validate(pubKey, marshalledData);\n}\n//# sourceMappingURL=validator.js.map\n\n//# sourceURL=webpack://ems/./node_modules/ipns/dist/src/validator.js?");

/***/ }),

/***/ "./node_modules/it-drain/dist/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/it-drain/dist/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction drain(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n        })();\n    }\n    else {\n        for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drain);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-drain/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-foreach/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/it-foreach/dist/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var it_peekable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-peekable */ \"./node_modules/it-peekable/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Calls a function for each value in an (async)iterable.\n *\n * The function can be sync or async.\n *\n * Async functions can be awaited on so may slow down processing of the (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * // prints 0, 1, 2, 3, 4\n * const arr = drain(\n *   each(values, console.info)\n * )\n * ```\n *\n * Async sources and callbacks must be awaited:\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * // prints 0, 1, 2, 3, 4\n * const arr = await drain(\n *   each(values(), console.info)\n * )\n * ```\n */\n\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction isPromise(thing) {\n    return thing?.then != null;\n}\nfunction forEach(source, fn) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const val of source) {\n                const res = fn(val);\n                if (isPromise(res)) {\n                    await res;\n                }\n                yield val;\n            }\n        })();\n    }\n    // if fn function returns a promise we have to return an async generator\n    const peekable = (0,it_peekable__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source);\n    const { value, done } = peekable.next();\n    if (done === true) {\n        return (function* () { }());\n    }\n    const res = fn(value);\n    if (typeof res?.then === 'function') {\n        return (async function* () {\n            yield value;\n            for await (const val of peekable) {\n                const res = fn(val);\n                if (isPromise(res)) {\n                    await res;\n                }\n                yield val;\n            }\n        })();\n    }\n    const func = fn;\n    return (function* () {\n        yield value;\n        for (const val of peekable) {\n            func(val);\n            yield val;\n        }\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (forEach);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-foreach/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/decode.js":
/*!************************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/decode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_DATA_LENGTH: () => (/* binding */ MAX_DATA_LENGTH),\n/* harmony export */   MAX_LENGTH_LENGTH: () => (/* binding */ MAX_LENGTH_LENGTH),\n/* harmony export */   decode: () => (/* binding */ decode)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8-varint */ \"./node_modules/uint8-varint/dist/src/index.js\");\n/* harmony import */ var uint8arraylist__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arraylist */ \"./node_modules/uint8arraylist/dist/src/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/it-length-prefixed/dist/src/utils.js\");\n/* eslint max-depth: [\"error\", 6] */\n\n\n\n\n// Maximum length of the length section of the message\nconst MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n    ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = (buf) => {\n    const length = uint8_varint__WEBPACK_IMPORTED_MODULE_1__.decode(buf);\n    defaultDecoder.bytes = uint8_varint__WEBPACK_IMPORTED_MODULE_1__.encodingLength(length);\n    return length;\n};\ndefaultDecoder.bytes = 0;\nfunction decode(source, options) {\n    const buffer = new uint8arraylist__WEBPACK_IMPORTED_MODULE_2__.Uint8ArrayList();\n    let mode = ReadMode.LENGTH;\n    let dataLength = -1;\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n    function* maybeYield() {\n        while (buffer.byteLength > 0) {\n            if (mode === ReadMode.LENGTH) {\n                // read length, ignore errors for short reads\n                try {\n                    dataLength = lengthDecoder(buffer);\n                    if (dataLength < 0) {\n                        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n                    }\n                    if (dataLength > maxDataLength) {\n                        throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n                    }\n                    const dataLengthLength = lengthDecoder.bytes;\n                    buffer.consume(dataLengthLength);\n                    if (options?.onLength != null) {\n                        options.onLength(dataLength);\n                    }\n                    mode = ReadMode.DATA;\n                }\n                catch (err) {\n                    if (err instanceof RangeError) {\n                        if (buffer.byteLength > maxLengthLength) {\n                            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n                        }\n                        break;\n                    }\n                    throw err;\n                }\n            }\n            if (mode === ReadMode.DATA) {\n                if (buffer.byteLength < dataLength) {\n                    // not enough data, wait for more\n                    break;\n                }\n                const data = buffer.sublist(0, dataLength);\n                buffer.consume(dataLength);\n                if (options?.onData != null) {\n                    options.onData(data);\n                }\n                yield data;\n                mode = ReadMode.LENGTH;\n            }\n        }\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isAsyncIterable)(source)) {\n        return (async function* () {\n            for await (const buf of source) {\n                buffer.append(buf);\n                yield* maybeYield();\n            }\n            if (buffer.byteLength > 0) {\n                throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n            }\n        })();\n    }\n    return (function* () {\n        for (const buf of source) {\n            buffer.append(buf);\n            yield* maybeYield();\n        }\n        if (buffer.byteLength > 0) {\n            throw err_code__WEBPACK_IMPORTED_MODULE_0__(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n        }\n    })();\n}\ndecode.fromReader = (reader, options) => {\n    let byteLength = 1; // Read single byte chunks until the length is known\n    const varByteSource = (async function* () {\n        while (true) {\n            try {\n                const { done, value } = await reader.next(byteLength);\n                if (done === true) {\n                    return;\n                }\n                if (value != null) {\n                    yield value;\n                }\n            }\n            catch (err) {\n                if (err.code === 'ERR_UNDER_READ') {\n                    return { done: true, value: null };\n                }\n                throw err;\n            }\n            finally {\n                // Reset the byteLength so we continue to check for varints\n                byteLength = 1;\n            }\n        }\n    }());\n    /**\n     * Once the length has been parsed, read chunk for that length\n     */\n    const onLength = (l) => { byteLength = l; };\n    return decode(varByteSource, {\n        ...(options ?? {}),\n        onLength\n    });\n};\n//# sourceMappingURL=decode.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/decode.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/encode.js":
/*!************************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/encode.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8-varint */ \"./node_modules/uint8-varint/dist/src/index.js\");\n/* harmony import */ var uint8arraylist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arraylist */ \"./node_modules/uint8arraylist/dist/src/index.js\");\n/* harmony import */ var uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/alloc */ \"./node_modules/uint8arrays/dist/src/alloc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/it-length-prefixed/dist/src/utils.js\");\n\n\n\n\nconst defaultEncoder = (length) => {\n    const lengthLength = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(length);\n    const lengthBuf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_2__.allocUnsafe)(lengthLength);\n    uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encode(length, lengthBuf);\n    defaultEncoder.bytes = lengthLength;\n    return lengthBuf;\n};\ndefaultEncoder.bytes = 0;\nfunction encode(source, options) {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    function* maybeYield(chunk) {\n        // length + data\n        const length = encodeLength(chunk.byteLength);\n        // yield only Uint8Arrays\n        if (length instanceof Uint8Array) {\n            yield length;\n        }\n        else {\n            yield* length;\n        }\n        // yield only Uint8Arrays\n        if (chunk instanceof Uint8Array) {\n            yield chunk;\n        }\n        else {\n            yield* chunk;\n        }\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isAsyncIterable)(source)) {\n        return (async function* () {\n            for await (const chunk of source) {\n                yield* maybeYield(chunk);\n            }\n        })();\n    }\n    return (function* () {\n        for (const chunk of source) {\n            yield* maybeYield(chunk);\n        }\n    })();\n}\nencode.single = (chunk, options) => {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    return new uint8arraylist__WEBPACK_IMPORTED_MODULE_1__.Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};\n//# sourceMappingURL=encode.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/encode.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   encode: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_0__.encode)\n/* harmony export */ });\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode.js */ \"./node_modules/it-length-prefixed/dist/src/encode.js\");\n/* harmony import */ var _decode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode.js */ \"./node_modules/it-length-prefixed/dist/src/decode.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-length-prefixed/dist/src/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/it-length-prefixed/dist/src/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)\n/* harmony export */ });\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-length-prefixed/dist/src/utils.js?");

/***/ }),

/***/ "./node_modules/it-ndjson/dist/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/it-ndjson/dist/src/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/it-ndjson/dist/src/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/it-ndjson/dist/src/stringify.js\");\n/**\n * @packageDocumentation\n *\n * Turn (async)iterable values into JSON and back again.\n *\n * @example\n *\n * ```javascript\n * import ndjson from 'it-ndjson'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = await all(ndjson.stringify(values))\n *\n * console.info(arr) // '0\\n', '1\\n', '2\\n', '3\\n', '4\\n'\n *\n * const res = await all(ndjson.parse(arr))\n *\n * console.info(res) // [0, 1, 2, 3, 4]\n * ```\n */\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-ndjson/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-ndjson/dist/src/parse.js":
/*!**************************************************!*\
  !*** ./node_modules/it-ndjson/dist/src/parse.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ parse)\n/* harmony export */ });\nasync function* parse(source) {\n    const matcher = /\\r?\\n/;\n    const decoder = new TextDecoder('utf8');\n    let buffer = '';\n    for await (let chunk of source) {\n        if (typeof chunk === 'string') {\n            chunk = new TextEncoder().encode(chunk);\n        }\n        buffer += decoder.decode(chunk, { stream: true });\n        const parts = buffer.split(matcher);\n        buffer = parts.pop() ?? '';\n        for (let i = 0; i < parts.length; i++) {\n            yield JSON.parse(parts[i]);\n        }\n    }\n    buffer += decoder.decode();\n    if (buffer !== '') {\n        yield JSON.parse(buffer);\n    }\n}\n//# sourceMappingURL=parse.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-ndjson/dist/src/parse.js?");

/***/ }),

/***/ "./node_modules/it-ndjson/dist/src/stringify.js":
/*!******************************************************!*\
  !*** ./node_modules/it-ndjson/dist/src/stringify.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ stringify)\n/* harmony export */ });\nasync function* stringify(source) {\n    for await (const obj of source) {\n        yield JSON.stringify(obj) + '\\n';\n    }\n}\n//# sourceMappingURL=stringify.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-ndjson/dist/src/stringify.js?");

/***/ }),

/***/ "./node_modules/it-sort/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/it-sort/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var it_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-all */ \"./node_modules/it-all/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction sort(source, sorter) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            const arr = await (0,it_all__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source);\n            yield* arr.sort(sorter);\n        })();\n    }\n    return (function* () {\n        const arr = (0,it_all__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source);\n        yield* arr.sort(sorter);\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sort);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-sort/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-take/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/it-take/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction take(source, limit) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            let items = 0;\n            if (limit < 1) {\n                return;\n            }\n            for await (const entry of source) {\n                yield entry;\n                items++;\n                if (items === limit) {\n                    return;\n                }\n            }\n        })();\n    }\n    return (function* () {\n        let items = 0;\n        if (limit < 1) {\n            return;\n        }\n        for (const entry of source) {\n            yield entry;\n            items++;\n            if (items === limit) {\n                return;\n            }\n        }\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (take);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-take/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/just-debounce-it/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/just-debounce-it/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ functionDebounce)\n/* harmony export */ });\nvar functionDebounce = debounce;\n\nfunction debounce(fn, wait, callFirst) {\n  var timeout = null;\n  var debouncedFn = null;\n\n  var clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n\n      debouncedFn = null;\n      timeout = null;\n    }\n  };\n\n  var flush = function() {\n    var call = debouncedFn;\n    clear();\n\n    if (call) {\n      call();\n    }\n  };\n\n  var debounceWrapper = function() {\n    if (!wait) {\n      return fn.apply(this, arguments);\n    }\n\n    var context = this;\n    var args = arguments;\n    var callNow = callFirst && !timeout;\n    clear();\n\n    debouncedFn = function() {\n      fn.apply(context, args);\n    };\n\n    timeout = setTimeout(function() {\n      timeout = null;\n\n      if (!callNow) {\n        var call = debouncedFn;\n        debouncedFn = null;\n\n        return call();\n      }\n    }, wait);\n\n    if (callNow) {\n      return debouncedFn();\n    }\n  };\n\n  debounceWrapper.cancel = clear;\n  debounceWrapper.flush = flush;\n\n  return debounceWrapper;\n}\n\n\n\n\n//# sourceURL=webpack://ems/./node_modules/just-debounce-it/index.mjs?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/mortice/dist/src/browser.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var observable_webworkers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! observable-webworkers */ \"./node_modules/observable-webworkers/dist/src/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/mortice/dist/src/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/mortice/dist/src/utils.js\");\n\n\n\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n    return (worker, event) => {\n        if (event.data.type !== requestType) {\n            return;\n        }\n        const requestEvent = {\n            type: event.data.type,\n            name: event.data.name,\n            identifier: event.data.identifier\n        };\n        emitter.dispatchEvent(new MessageEvent(masterEvent, {\n            data: {\n                name: requestEvent.name,\n                handler: async () => {\n                    // grant lock to worker\n                    worker.postMessage({\n                        type: grantType,\n                        name: requestEvent.name,\n                        identifier: requestEvent.identifier\n                    });\n                    // wait for worker to finish\n                    await new Promise((resolve) => {\n                        const releaseEventListener = (event) => {\n                            if (event == null || event.data == null) {\n                                return;\n                            }\n                            const releaseEvent = {\n                                type: event.data.type,\n                                name: event.data.name,\n                                identifier: event.data.identifier\n                            };\n                            if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                                worker.removeEventListener('message', releaseEventListener);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener('message', releaseEventListener);\n                    });\n                }\n            }\n        }));\n    };\n};\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n    return async () => {\n        const id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.nanoid)();\n        globalThis.postMessage({\n            type: requestType,\n            identifier: id,\n            name\n        });\n        return new Promise((resolve) => {\n            const listener = (event) => {\n                if (event == null || event.data == null) {\n                    return;\n                }\n                const responseEvent = {\n                    type: event.data.type,\n                    identifier: event.data.identifier\n                };\n                if (responseEvent.type === grantType && responseEvent.identifier === id) {\n                    globalThis.removeEventListener('message', listener);\n                    // grant lock\n                    resolve(() => {\n                        // release lock\n                        globalThis.postMessage({\n                            type: releaseType,\n                            identifier: id,\n                            name\n                        });\n                    });\n                }\n            };\n            globalThis.addEventListener('message', listener);\n        });\n    };\n};\nconst defaultOptions = {\n    singleProcess: false\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((options) => {\n    options = Object.assign({}, defaultOptions, options);\n    const isPrimary = Boolean(globalThis.document) || options.singleProcess;\n    if (isPrimary) {\n        const emitter = new EventTarget();\n        observable_webworkers__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_READ_LOCK));\n        observable_webworkers__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_WRITE_LOCK));\n        return emitter;\n    }\n    return {\n        isWorker: true,\n        readLock: (name) => makeWorkerLockRequest(name, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_READ_LOCK),\n        writeLock: (name) => makeWorkerLockRequest(name, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_WRITE_LOCK)\n    };\n});\n//# sourceMappingURL=browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/browser.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/mortice/dist/src/constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MASTER_GRANT_READ_LOCK: () => (/* binding */ MASTER_GRANT_READ_LOCK),\n/* harmony export */   MASTER_GRANT_WRITE_LOCK: () => (/* binding */ MASTER_GRANT_WRITE_LOCK),\n/* harmony export */   WORKER_RELEASE_READ_LOCK: () => (/* binding */ WORKER_RELEASE_READ_LOCK),\n/* harmony export */   WORKER_RELEASE_WRITE_LOCK: () => (/* binding */ WORKER_RELEASE_WRITE_LOCK),\n/* harmony export */   WORKER_REQUEST_READ_LOCK: () => (/* binding */ WORKER_REQUEST_READ_LOCK),\n/* harmony export */   WORKER_REQUEST_WRITE_LOCK: () => (/* binding */ WORKER_REQUEST_WRITE_LOCK)\n/* harmony export */ });\nconst WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read';\nconst WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read';\nconst MASTER_GRANT_READ_LOCK = 'lock:master:grant-read';\nconst WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write';\nconst WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write';\nconst MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write';\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/constants.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/mortice/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createMortice)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var p_timeout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-timeout */ \"./node_modules/p-timeout/index.js\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.js */ \"./node_modules/mortice/dist/src/browser.js\");\n/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * ## Usage\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice('my-lock', {\n *\n *   // how long before write locks time out (default: 24 hours)\n *   timeout: 30000,\n *\n *    // control how many read operations are executed concurrently (default: Infinity)\n *   concurrency: 5,\n *\n *   // by default the the lock will be held on the main thread, set this to true if the\n *   // a lock should reside on each worker (default: false)\n *   singleProcess: false\n * })\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\n\n\n\nconst mutexes = {};\nlet implementation;\nasync function createReleaseable(queue, options) {\n    let res;\n    const p = new Promise((resolve) => {\n        res = resolve;\n    });\n    void queue.add(async () => (0,p_timeout__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((async () => {\n        await new Promise((resolve) => {\n            res(() => {\n                resolve();\n            });\n        });\n    })(), {\n        milliseconds: options.timeout\n    }));\n    return p;\n}\nconst createMutex = (name, options) => {\n    if (implementation.isWorker === true) {\n        return {\n            readLock: implementation.readLock(name, options),\n            writeLock: implementation.writeLock(name, options)\n        };\n    }\n    const masterQueue = new p_queue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({ concurrency: 1 });\n    let readQueue;\n    return {\n        async readLock() {\n            // If there's already a read queue, just add the task to it\n            if (readQueue != null) {\n                return createReleaseable(readQueue, options);\n            }\n            // Create a new read queue\n            readQueue = new p_queue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                concurrency: options.concurrency,\n                autoStart: false\n            });\n            const localReadQueue = readQueue;\n            // Add the task to the read queue\n            const readPromise = createReleaseable(readQueue, options);\n            void masterQueue.add(async () => {\n                // Start the task only once the master queue has completed processing\n                // any previous tasks\n                localReadQueue.start();\n                // Once all the tasks in the read queue have completed, remove it so\n                // that the next read lock will occur after any write locks that were\n                // started in the interim\n                await localReadQueue.onIdle()\n                    .then(() => {\n                    if (readQueue === localReadQueue) {\n                        readQueue = null;\n                    }\n                });\n            });\n            return readPromise;\n        },\n        async writeLock() {\n            // Remove the read queue reference, so that any later read locks will be\n            // added to a new queue that starts after this write lock has been\n            // released\n            readQueue = null;\n            return createReleaseable(masterQueue, options);\n        }\n    };\n};\nconst defaultOptions = {\n    name: 'lock',\n    concurrency: Infinity,\n    timeout: 84600000,\n    singleProcess: false\n};\nfunction createMortice(options) {\n    const opts = Object.assign({}, defaultOptions, options);\n    if (implementation == null) {\n        implementation = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(opts);\n        if (implementation.isWorker !== true) {\n            // we are master, set up worker requests\n            implementation.addEventListener('requestReadLock', (event) => {\n                if (mutexes[event.data.name] == null) {\n                    return;\n                }\n                void mutexes[event.data.name].readLock()\n                    .then(async (release) => event.data.handler().finally(() => { release(); }));\n            });\n            implementation.addEventListener('requestWriteLock', async (event) => {\n                if (mutexes[event.data.name] == null) {\n                    return;\n                }\n                void mutexes[event.data.name].writeLock()\n                    .then(async (release) => event.data.handler().finally(() => { release(); }));\n            });\n        }\n    }\n    if (mutexes[opts.name] == null) {\n        mutexes[opts.name] = createMutex(opts.name, opts);\n    }\n    return mutexes[opts.name];\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/utils.js":
/*!************************************************!*\
  !*** ./node_modules/mortice/dist/src/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nconst nanoid = (size = 21) => {\n    return Math.random().toString().substring(2);\n};\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/utils.js?");

/***/ }),

/***/ "./node_modules/observable-webworkers/dist/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/observable-webworkers/dist/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst events = {};\nconst observable = (worker) => {\n    worker.addEventListener('message', (event) => {\n        observable.dispatchEvent('message', worker, event);\n    });\n    if (worker.port != null) {\n        worker.port.addEventListener('message', (event) => {\n            observable.dispatchEvent('message', worker, event);\n        });\n    }\n};\nobservable.addEventListener = (type, fn) => {\n    if (events[type] == null) {\n        events[type] = [];\n    }\n    events[type].push(fn);\n};\nobservable.removeEventListener = (type, fn) => {\n    if (events[type] == null) {\n        return;\n    }\n    events[type] = events[type]\n        .filter(listener => listener === fn);\n};\nobservable.dispatchEvent = function (type, worker, event) {\n    if (events[type] == null) {\n        return;\n    }\n    events[type].forEach(fn => fn(worker, event));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (observable);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/observable-webworkers/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/race-event/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/race-event/dist/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   raceEvent: () => (/* binding */ raceEvent)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n/**\n * An abort error class that extends error\n */\nclass AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.name = 'AbortError';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n/**\n * Race a promise against an abort signal\n */\nasync function raceEvent(emitter, eventName, signal, opts) {\n    // create the error here so we have more context in the stack trace\n    const error = new AbortError(opts?.errorMessage, opts?.errorCode);\n    if (signal?.aborted === true) {\n        return Promise.reject(error);\n    }\n    return new Promise((resolve, reject) => {\n        const eventListener = (evt) => {\n            try {\n                if (opts?.filter?.(evt) === false) {\n                    return;\n                }\n            }\n            catch (err) {\n                emitter.removeEventListener(eventName, eventListener);\n                signal?.removeEventListener('abort', abortListener);\n                reject(err);\n                return;\n            }\n            emitter.removeEventListener(eventName, eventListener);\n            signal?.removeEventListener('abort', abortListener);\n            resolve(evt);\n        };\n        const abortListener = () => {\n            emitter.removeEventListener(eventName, eventListener);\n            signal?.removeEventListener('abort', abortListener);\n            reject(error);\n        };\n        emitter.addEventListener(eventName, eventListener);\n        signal?.addEventListener('abort', abortListener);\n    });\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/race-event/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/race-signal/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/race-signal/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   raceSignal: () => (/* binding */ raceSignal)\n/* harmony export */ });\n/**\n * An abort error class that extends error\n */\nclass AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.name = 'AbortError';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n/**\n * Race a promise against an abort signal\n */\nasync function raceSignal(promise, signal, opts) {\n    if (signal == null) {\n        return promise;\n    }\n    if (signal.aborted) {\n        return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode));\n    }\n    let listener;\n    // create the error here so we have more context in the stack trace\n    const error = new AbortError(opts?.errorMessage, opts?.errorCode);\n    try {\n        return await Promise.race([\n            promise,\n            new Promise((resolve, reject) => {\n                listener = () => {\n                    reject(error);\n                };\n                signal.addEventListener('abort', listener);\n            })\n        ]);\n    }\n    finally {\n        if (listener != null) {\n            signal.removeEventListener('abort', listener);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/race-signal/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/uint8arrays/dist/src/to-string.js":
/*!********************************************************!*\
  !*** ./node_modules/uint8arrays/dist/src/to-string.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ \"./node_modules/uint8arrays/dist/src/util/bases.js\");\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nfunction toString(array, encoding = 'utf8') {\n    const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n//# sourceMappingURL=to-string.js.map\n\n//# sourceURL=webpack://ems/./node_modules/uint8arrays/dist/src/to-string.js?");

/***/ })

}])