/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkems"] = self["webpackChunkems"] || []).push([["vendors-node_modules_helia_http_dist_src_index_js"],{

/***/ "./node_modules/hashlru/index.js":
/*!***************************************!*\
  !*** ./node_modules/hashlru/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ems/./node_modules/hashlru/index.js?");

/***/ }),

/***/ "./node_modules/@helia/http/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@helia/http/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHeliaHTTP: () => (/* binding */ createHeliaHTTP)\n/* harmony export */ });\n/* harmony import */ var _helia_block_brokers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @helia/block-brokers */ \"./node_modules/@helia/block-brokers/dist/src/index.js\");\n/* harmony import */ var _helia_routers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @helia/routers */ \"./node_modules/@helia/routers/dist/src/delegated-http-routing.js\");\n/* harmony import */ var _helia_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @helia/utils */ \"./node_modules/@helia/utils/dist/src/index.js\");\n/* harmony import */ var blockstore_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blockstore-core */ \"./node_modules/blockstore-core/dist/src/index.js\");\n/* harmony import */ var datastore_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! datastore-core */ \"./node_modules/datastore-core/dist/src/index.js\");\n/* harmony import */ var _helia_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @helia/interface */ \"./node_modules/@helia/interface/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Exports a `createHeliaHTTP` function that returns an object that implements a lightweight version of the {@link Helia} API that functions only over HTTP.\n *\n * By default, content and peer routing are requests are resolved using the [Delegated HTTP Routing API](https://specs.ipfs.tech/routing/http-routing-v1/) and blocks are fetched from [Trustless Gateways](https://specs.ipfs.tech/http-gateways/trustless-gateway/).\n *\n * Pass it to other modules like {@link https://www.npmjs.com/package/@helia/unixfs | @helia/unixfs} to fetch files from the distributed web.\n *\n * @example\n *\n * ```typescript\n * import { createHeliaHTTP } from '@helia/http'\n * import { unixfs } from '@helia/unixfs'\n * import { CID } from 'multiformats/cid'\n *\n * const helia = await createHeliaHTTP()\n *\n * const fs = unixfs(helia)\n * fs.cat(CID.parse('bafyFoo'))\n * ```\n * @example with custom gateways and delegated routing endpoints\n * ```typescript\n * import { createHeliaHTTP } from '@helia/http'\n * import { trustlessGateway } from '@helia/block-brokers'\n * import { delegatedHTTPRouting } from '@helia/routers'\n * import { unixfs } from '@helia/unixfs'\n * import { CID } from 'multiformats/cid'\n *\n * const helia = await createHeliaHTTP({\n *   blockBrokers: [\n *     trustlessGateway({\n *       gateways: ['https://cloudflare-ipfs.com', 'https://ipfs.io'],\n *     }),\n *   ],\n *   routers: [\n *     delegatedHTTPRouting('https://delegated-ipfs.dev')\n *   ]\n * })\n *\n * const fs = unixfs(helia)\n * fs.cat(CID.parse('bafyFoo'))\n * ```\n */\n\n\n\n\n\n// re-export interface types so people don't have to depend on @helia/interface\n// if they don't want to\n\n/**\n/**\n * Create and return a Helia node\n */\nasync function createHeliaHTTP(init = {}) {\n    const datastore = init.datastore ?? new datastore_core__WEBPACK_IMPORTED_MODULE_3__.MemoryDatastore();\n    const blockstore = init.blockstore ?? new blockstore_core__WEBPACK_IMPORTED_MODULE_2__.MemoryBlockstore();\n    const helia = new _helia_utils__WEBPACK_IMPORTED_MODULE_1__.Helia({\n        ...init,\n        datastore,\n        blockstore,\n        blockBrokers: init.blockBrokers ?? [\n            (0,_helia_block_brokers__WEBPACK_IMPORTED_MODULE_0__.trustlessGateway)()\n        ],\n        routers: init.routers ?? [\n            (0,_helia_routers__WEBPACK_IMPORTED_MODULE_5__.delegatedHTTPRouting)('https://delegated-ipfs.dev')\n        ]\n    });\n    if (init.start !== false) {\n        await helia.start();\n    }\n    return helia;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/http/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/blocks.js":
/*!**********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/blocks.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=blocks.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/blocks.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks.js */ \"./node_modules/@helia/interface/dist/src/blocks.js\");\n/* harmony import */ var _pins_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pins.js */ \"./node_modules/@helia/interface/dist/src/pins.js\");\n/* harmony import */ var _routing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./routing.js */ \"./node_modules/@helia/interface/dist/src/routing.js\");\n/**\n * @packageDocumentation\n *\n * The API defined by a {@link Helia} node\n *\n * @example\n *\n * ```typescript\n * import type { Helia } from '@helia/interface'\n *\n * export function doSomething(helia: Helia) {\n *   // use helia node functions here\n * }\n * ```\n */\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/pins.js":
/*!********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/pins.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=pins.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/pins.js?");

/***/ }),

/***/ "./node_modules/@helia/interface/dist/src/routing.js":
/*!***********************************************************!*\
  !*** ./node_modules/@helia/interface/dist/src/routing.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=routing.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/interface/dist/src/routing.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Helia: () => (/* binding */ Helia)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/content-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/peer-routing/index.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var _multiformats_dns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/dns */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _pins_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pins.js */ \"./node_modules/@helia/utils/dist/src/pins.js\");\n/* harmony import */ var _routing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./routing.js */ \"./node_modules/@helia/utils/dist/src/routing.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage.js */ \"./node_modules/@helia/utils/dist/src/storage.js\");\n/* harmony import */ var _utils_dag_walkers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/dag-walkers.js */ \"./node_modules/@helia/utils/dist/src/utils/dag-walkers.js\");\n/* harmony import */ var _utils_datastore_version_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/datastore-version.js */ \"./node_modules/@helia/utils/dist/src/utils/datastore-version.js\");\n/* harmony import */ var _utils_default_hashers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/default-hashers.js */ \"./node_modules/@helia/utils/dist/src/utils/default-hashers.js\");\n/* harmony import */ var _utils_networked_storage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/networked-storage.js */ \"./node_modules/@helia/utils/dist/src/utils/networked-storage.js\");\n/**\n * @packageDocumentation\n *\n * Exports a `Helia` class that implements the {@link HeliaInterface} API.\n *\n * In general you should use the `helia` or `@helia/http` modules instead which\n * pre-configure Helia for certain use-cases (p2p or pure-HTTP).\n *\n * @example\n *\n * ```typescript\n * import { Helia } from '@helia/utils'\n *\n * const node = new Helia({\n *   // ...options\n * })\n * ```\n */\n\n\n\n\n\n\n\n\n\n\n\n\nclass Helia {\n    blockstore;\n    datastore;\n    pins;\n    logger;\n    routing;\n    dagWalkers;\n    hashers;\n    dns;\n    log;\n    constructor(init) {\n        this.logger = init.logger ?? (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_10__.defaultLogger)();\n        this.log = this.logger.forComponent('helia');\n        this.hashers = (0,_utils_default_hashers_js__WEBPACK_IMPORTED_MODULE_8__.defaultHashers)(init.hashers);\n        this.dagWalkers = (0,_utils_dag_walkers_js__WEBPACK_IMPORTED_MODULE_6__.defaultDagWalkers)(init.dagWalkers);\n        this.dns = init.dns ?? (0,_multiformats_dns__WEBPACK_IMPORTED_MODULE_0__.dns)();\n        const components = {\n            blockstore: init.blockstore,\n            datastore: init.datastore,\n            hashers: this.hashers,\n            dagWalkers: this.dagWalkers,\n            logger: this.logger,\n            blockBrokers: [],\n            dns: this.dns,\n            ...(init.components ?? {})\n        };\n        components.blockBrokers = init.blockBrokers.map((fn) => {\n            return fn(components);\n        });\n        const networkedStorage = new _utils_networked_storage_js__WEBPACK_IMPORTED_MODULE_9__.NetworkedStorage(components);\n        this.pins = new _pins_js__WEBPACK_IMPORTED_MODULE_3__.PinsImpl(init.datastore, networkedStorage, this.dagWalkers);\n        this.blockstore = new _storage_js__WEBPACK_IMPORTED_MODULE_5__.BlockStorage(networkedStorage, this.pins, {\n            holdGcLock: init.holdGcLock ?? true\n        });\n        this.datastore = init.datastore;\n        this.routing = new _routing_js__WEBPACK_IMPORTED_MODULE_4__.Routing(components, {\n            routers: (init.routers ?? []).flatMap((router) => {\n                // if the router itself is a router\n                const routers = [\n                    router\n                ];\n                // if the router provides a libp2p-style ContentRouter\n                if (router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.contentRoutingSymbol] != null) {\n                    routers.push(router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_11__.contentRoutingSymbol]);\n                }\n                // if the router provides a libp2p-style PeerRouter\n                if (router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.peerRoutingSymbol] != null) {\n                    routers.push(router[_libp2p_interface__WEBPACK_IMPORTED_MODULE_12__.peerRoutingSymbol]);\n                }\n                return routers;\n            })\n        });\n    }\n    async start() {\n        await (0,_utils_datastore_version_js__WEBPACK_IMPORTED_MODULE_7__.assertDatastoreVersionIsCurrent)(this.datastore);\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_13__.start)(this.blockstore, this.datastore, this.routing);\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_13__.stop)(this.blockstore, this.datastore, this.routing);\n    }\n    async gc(options = {}) {\n        const releaseLock = await this.blockstore.lock.writeLock();\n        try {\n            const helia = this;\n            const blockstore = this.blockstore.unwrap();\n            this.log('gc start');\n            await (0,it_drain__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(blockstore.deleteMany((async function* () {\n                for await (const { cid } of blockstore.getAll()) {\n                    try {\n                        if (await helia.pins.isPinned(cid, options)) {\n                            continue;\n                        }\n                        yield cid;\n                        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_2__.CustomProgressEvent('helia:gc:deleted', cid));\n                    }\n                    catch (err) {\n                        helia.log.error('Error during gc', err);\n                        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_2__.CustomProgressEvent('helia:gc:error', err));\n                    }\n                }\n            }())));\n        }\n        finally {\n            releaseLock();\n        }\n        this.log('gc finished');\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/pins.js":
/*!****************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/pins.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PinsImpl: () => (/* binding */ PinsImpl)\n/* harmony export */ });\n/* harmony import */ var _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/utils/queue */ \"./node_modules/@libp2p/utils/dist/src/queue/index.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base36 */ \"./node_modules/multiformats/dist/src/bases/base36.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n\n\n\n\n\n\n\nconst DATASTORE_PIN_PREFIX = '/pin/';\nconst DATASTORE_BLOCK_PREFIX = '/pinned-block/';\nconst DATASTORE_ENCODING = multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36;\nconst DAG_WALK_QUEUE_CONCURRENCY = 1;\nfunction toDSKey(cid) {\n    if (cid.version === 0) {\n        cid = cid.toV1();\n    }\n    return new interface_datastore__WEBPACK_IMPORTED_MODULE_1__.Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);\n}\nclass PinsImpl {\n    datastore;\n    blockstore;\n    dagWalkers;\n    constructor(datastore, blockstore, dagWalkers) {\n        this.datastore = datastore;\n        this.blockstore = blockstore;\n        this.dagWalkers = dagWalkers;\n    }\n    async *add(cid, options = {}) {\n        const pinKey = toDSKey(cid);\n        if (await this.datastore.has(pinKey)) {\n            throw new Error('Already pinned');\n        }\n        const depth = Math.round(options.depth ?? Infinity);\n        if (depth < 0) {\n            throw new Error('Depth must be greater than or equal to 0');\n        }\n        // use a queue to walk the DAG instead of recursion so we can traverse very large DAGs\n        const queue = new _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_6__.Queue({\n            concurrency: DAG_WALK_QUEUE_CONCURRENCY\n        });\n        for await (const childCid of this.#walkDag(cid, queue, {\n            ...options,\n            depth\n        })) {\n            await this.#updatePinnedBlock(childCid, (pinnedBlock) => {\n                // do not update pinned block if this block is already pinned by this CID\n                if (pinnedBlock.pinnedBy.find(c => (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(c, cid.bytes)) != null) {\n                    return false;\n                }\n                pinnedBlock.pinCount++;\n                pinnedBlock.pinnedBy.push(cid.bytes);\n                return true;\n            }, options);\n            yield childCid;\n        }\n        const pin = {\n            depth,\n            metadata: options.metadata ?? {}\n        };\n        await this.datastore.put(pinKey, cborg__WEBPACK_IMPORTED_MODULE_0__.encode(pin), options);\n    }\n    /**\n     * Walk a DAG in an iterable fashion\n     */\n    async *#walkDag(cid, queue, options) {\n        if (options.depth === -1) {\n            return;\n        }\n        const dagWalker = this.dagWalkers[cid.code];\n        if (dagWalker == null) {\n            throw new Error(`No dag walker found for cid codec ${cid.code}`);\n        }\n        const block = await this.blockstore.get(cid, options);\n        yield cid;\n        // walk dag, ensure all blocks are present\n        for await (const cid of dagWalker.walk(block)) {\n            yield* await queue.add(async () => {\n                return this.#walkDag(cid, queue, {\n                    ...options,\n                    depth: options.depth - 1\n                });\n            });\n        }\n    }\n    /**\n     * Update the pin count for the CID\n     */\n    async #updatePinnedBlock(cid, withPinnedBlock, options) {\n        const blockKey = new interface_datastore__WEBPACK_IMPORTED_MODULE_1__.Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);\n        let pinnedBlock = {\n            pinCount: 0,\n            pinnedBy: []\n        };\n        try {\n            pinnedBlock = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(await this.datastore.get(blockKey, options));\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        const shouldContinue = withPinnedBlock(pinnedBlock);\n        if (!shouldContinue) {\n            return;\n        }\n        if (pinnedBlock.pinCount === 0) {\n            if (await this.datastore.has(blockKey)) {\n                await this.datastore.delete(blockKey);\n                return;\n            }\n        }\n        await this.datastore.put(blockKey, cborg__WEBPACK_IMPORTED_MODULE_0__.encode(pinnedBlock), options);\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_4__.CustomProgressEvent('helia:pin:add', cid));\n    }\n    async *rm(cid, options = {}) {\n        const pinKey = toDSKey(cid);\n        const buf = await this.datastore.get(pinKey, options);\n        const pin = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(buf);\n        await this.datastore.delete(pinKey, options);\n        // use a queue to walk the DAG instead of recursion so we can traverse very large DAGs\n        const queue = new _libp2p_utils_queue__WEBPACK_IMPORTED_MODULE_6__.Queue({\n            concurrency: DAG_WALK_QUEUE_CONCURRENCY\n        });\n        for await (const childCid of this.#walkDag(cid, queue, {\n            ...options,\n            depth: pin.depth\n        })) {\n            await this.#updatePinnedBlock(childCid, (pinnedBlock) => {\n                pinnedBlock.pinCount--;\n                pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter(c => (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_5__.equals)(c, cid.bytes));\n                return true;\n            }, {\n                ...options,\n                depth: pin.depth\n            });\n            yield childCid;\n        }\n    }\n    async *ls(options = {}) {\n        for await (const { key, value } of this.datastore.query({\n            prefix: DATASTORE_PIN_PREFIX + (options.cid != null ? `${options.cid.toString(multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36)}` : '')\n        }, options)) {\n            const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_3__.CID.parse(key.toString().substring(5), multiformats_bases_base36__WEBPACK_IMPORTED_MODULE_2__.base36);\n            const pin = cborg__WEBPACK_IMPORTED_MODULE_0__.decode(value);\n            yield {\n                cid,\n                ...pin\n            };\n        }\n    }\n    async isPinned(cid, options = {}) {\n        const blockKey = new interface_datastore__WEBPACK_IMPORTED_MODULE_1__.Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);\n        return this.datastore.has(blockKey, options);\n    }\n}\n//# sourceMappingURL=pins.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/pins.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/routing.js":
/*!*******************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/routing.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Routing: () => (/* binding */ Routing)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @libp2p/peer-collections */ \"./node_modules/@libp2p/peer-collections/dist/src/set.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n\n\n\nclass Routing {\n    log;\n    routers;\n    constructor(components, init) {\n        this.log = components.logger.forComponent('helia:routing');\n        this.routers = init.routers ?? [];\n    }\n    async start() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.start)(...this.routers);\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.stop)(...this.routers);\n    }\n    /**\n     * Iterates over all content routers in parallel to find providers of the given key\n     */\n    async *findProviders(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No content routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        const seen = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__.PeerSet();\n        for await (const peer of (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...supports(this.routers, 'findProviders')\n            .map(router => router.findProviders(key, options)))) {\n            // the peer was yielded by a content router without multiaddrs and we\n            // failed to load them\n            if (peer == null) {\n                continue;\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key\n     */\n    async provide(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No content routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        await Promise.all(supports(this.routers, 'provide')\n            .map(async (router) => {\n            await router.provide(key, options);\n        }));\n    }\n    /**\n     * Store the given key/value pair in the available content routings\n     */\n    async put(key, value, options) {\n        await Promise.all(supports(this.routers, 'put')\n            .map(async (router) => {\n            await router.put(key, value, options);\n        }));\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     */\n    async get(key, options) {\n        return Promise.any(supports(this.routers, 'get')\n            .map(async (router) => {\n            return router.get(key, options);\n        }));\n    }\n    /**\n     * Iterates over all peer routers in parallel to find the given peer\n     */\n    async findPeer(id, options) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No peer routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        const self = this;\n        const source = (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...supports(this.routers, 'findPeer')\n            .map(router => (async function* () {\n            try {\n                yield await router.findPeer(id, options);\n            }\n            catch (err) {\n                self.log.error(err);\n            }\n        })()));\n        for await (const peer of source) {\n            if (peer == null) {\n                continue;\n            }\n            return peer;\n        }\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('Could not find peer in routing', 'ERR_NOT_FOUND');\n    }\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     */\n    async *getClosestPeers(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.CodeError('No peer routers available', 'ERR_NO_ROUTERS_AVAILABLE');\n        }\n        const seen = new _libp2p_peer_collections__WEBPACK_IMPORTED_MODULE_3__.PeerSet();\n        for await (const peer of (0,it_merge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(...supports(this.routers, 'getClosestPeers')\n            .map(router => router.getClosestPeers(key, options)))) {\n            if (peer == null) {\n                continue;\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n}\nfunction supports(routers, key) {\n    return routers.filter(router => router[key] != null);\n}\n//# sourceMappingURL=routing.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/routing.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/storage.js":
/*!*******************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/storage.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockStorage: () => (/* binding */ BlockStorage)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var mortice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mortice */ \"./node_modules/mortice/dist/src/index.js\");\n\n\n/**\n * BlockStorage is a hybrid blockstore that puts/gets blocks from a configured\n * blockstore (that may be on disk, s3, or something else). If the blocks are\n * not present Bitswap will be used to fetch them from network peers.\n */\nclass BlockStorage {\n    lock;\n    child;\n    pins;\n    started;\n    /**\n     * Create a new BlockStorage\n     */\n    constructor(blockstore, pins, options = {}) {\n        this.child = blockstore;\n        this.pins = pins;\n        this.lock = (0,mortice__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            singleProcess: options.holdGcLock\n        });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.start)(this.child);\n        this.started = true;\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.stop)(this.child);\n        this.started = false;\n    }\n    unwrap() {\n        return this.child;\n    }\n    /**\n     * Put a block to the underlying datastore\n     */\n    async put(cid, block, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            return await this.child.put(cid, block, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore\n     */\n    async *putMany(blocks, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            yield* this.child.putMany(blocks, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Get a block by cid\n     */\n    async get(cid, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            return await this.child.get(cid, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Get multiple blocks back from an (async) iterable of cids\n     */\n    async *getMany(cids, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            yield* this.child.getMany(cids, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Delete a block from the blockstore\n     */\n    async delete(cid, options = {}) {\n        const releaseLock = await this.lock.writeLock();\n        try {\n            if (await this.pins.isPinned(cid)) {\n                throw new Error('CID was pinned');\n            }\n            await this.child.delete(cid, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    /**\n     * Delete multiple blocks from the blockstore\n     */\n    async *deleteMany(cids, options = {}) {\n        const releaseLock = await this.lock.writeLock();\n        try {\n            const storage = this;\n            yield* this.child.deleteMany((async function* () {\n                for await (const cid of cids) {\n                    if (await storage.pins.isPinned(cid)) {\n                        throw new Error('CID was pinned');\n                    }\n                    yield cid;\n                }\n            }()), options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    async has(cid, options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            return await this.child.has(cid, options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n    async *getAll(options = {}) {\n        const releaseLock = await this.lock.readLock();\n        try {\n            yield* this.child.getAll(options);\n        }\n        finally {\n            releaseLock();\n        }\n    }\n}\n//# sourceMappingURL=storage.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/storage.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/dag-walkers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/dag-walkers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dagCborWalker: () => (/* binding */ dagCborWalker),\n/* harmony export */   dagJsonWalker: () => (/* binding */ dagJsonWalker),\n/* harmony export */   dagPbWalker: () => (/* binding */ dagPbWalker),\n/* harmony export */   defaultDagWalkers: () => (/* binding */ defaultDagWalkers),\n/* harmony export */   jsonWalker: () => (/* binding */ jsonWalker),\n/* harmony export */   rawWalker: () => (/* binding */ rawWalker)\n/* harmony export */ });\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ipld/dag-cbor */ \"./node_modules/@ipld/dag-cbor/src/index.js\");\n/* harmony import */ var _ipld_dag_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ipld/dag-json */ \"./node_modules/@ipld/dag-json/src/index.js\");\n/* harmony import */ var _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ipld/dag-pb */ \"./node_modules/@ipld/dag-pb/src/index.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/* harmony import */ var cborg_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cborg/json */ \"./node_modules/cborg/lib/json/json.js\");\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats */ \"./node_modules/multiformats/dist/src/index.js\");\n/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/bases/base64 */ \"./node_modules/multiformats/dist/src/bases/base64.js\");\n/* harmony import */ var multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! multiformats/codecs/json */ \"./node_modules/multiformats/dist/src/codecs/json.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* eslint max-depth: [\"error\", 7] */\n\n\n\n\n\n\n\n\n\n\n/**\n * Dag walker for dag-pb CIDs\n */\nconst dagPbWalker = {\n    codec: _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__.code,\n    *walk(block) {\n        const node = _ipld_dag_pb__WEBPACK_IMPORTED_MODULE_2__.decode(block);\n        yield* node.Links.map(l => l.Hash);\n    }\n};\n/**\n * Dag walker for raw CIDs\n */\nconst rawWalker = {\n    codec: multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_8__.code,\n    *walk() {\n        // no embedded CIDs in a raw block\n    }\n};\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_TAG = 42;\n/**\n * Dag walker for dag-cbor CIDs. Does not actually use dag-cbor since\n * all we are interested in is extracting the the CIDs from the block\n * so we can just use cborg for that.\n */\nconst dagCborWalker = {\n    codec: _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_0__.code,\n    *walk(block) {\n        const cids = [];\n        const tags = [];\n        tags[CID_TAG] = (bytes) => {\n            if (bytes[0] !== 0) {\n                throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n            }\n            const cid = multiformats__WEBPACK_IMPORTED_MODULE_5__.CID.decode(bytes.subarray(1)); // ignore leading 0x00\n            cids.push(cid);\n            return cid;\n        };\n        cborg__WEBPACK_IMPORTED_MODULE_3__.decode(block, {\n            tags\n        });\n        yield* cids;\n    }\n};\n/**\n * Borrowed from @ipld/dag-json\n */\nclass DagJsonTokenizer extends cborg_json__WEBPACK_IMPORTED_MODULE_4__.Tokenizer {\n    tokenBuffer;\n    constructor(data, options) {\n        super(data, options);\n        this.tokenBuffer = [];\n    }\n    done() {\n        return this.tokenBuffer.length === 0 && super.done();\n    }\n    _next() {\n        if (this.tokenBuffer.length > 0) {\n            // @ts-expect-error https://github.com/Microsoft/TypeScript/issues/30406\n            return this.tokenBuffer.pop();\n        }\n        return super.next();\n    }\n    /**\n     * Implements rules outlined in https://github.com/ipld/specs/pull/356\n     */\n    next() {\n        const token = this._next();\n        if (token.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.map) {\n            const keyToken = this._next();\n            if (keyToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string && keyToken.value === '/') {\n                const valueToken = this._next();\n                if (valueToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string) { // *must* be a CID\n                    const breakToken = this._next(); // swallow the end-of-map token\n                    if (breakToken.type !== cborg__WEBPACK_IMPORTED_MODULE_3__.Type.break) {\n                        throw new Error('Invalid encoded CID form');\n                    }\n                    this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token\n                    return new cborg__WEBPACK_IMPORTED_MODULE_3__.Token(cborg__WEBPACK_IMPORTED_MODULE_3__.Type.tag, 42, 0);\n                }\n                if (valueToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.map) {\n                    const innerKeyToken = this._next();\n                    if (innerKeyToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string && innerKeyToken.value === 'bytes') {\n                        const innerValueToken = this._next();\n                        if (innerValueToken.type === cborg__WEBPACK_IMPORTED_MODULE_3__.Type.string) { // *must* be Bytes\n                            for (let i = 0; i < 2; i++) {\n                                const breakToken = this._next(); // swallow two end-of-map tokens\n                                if (breakToken.type !== cborg__WEBPACK_IMPORTED_MODULE_3__.Type.break) {\n                                    throw new Error('Invalid encoded Bytes form');\n                                }\n                            }\n                            const bytes = multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_6__.base64.decode(`m${innerValueToken.value}`);\n                            return new cborg__WEBPACK_IMPORTED_MODULE_3__.Token(cborg__WEBPACK_IMPORTED_MODULE_3__.Type.bytes, bytes, innerValueToken.value.length);\n                        }\n                        this.tokenBuffer.push(innerValueToken); // bail\n                    }\n                    this.tokenBuffer.push(innerKeyToken); // bail\n                }\n                this.tokenBuffer.push(valueToken); // bail\n            }\n            this.tokenBuffer.push(keyToken); // bail\n        }\n        return token;\n    }\n}\n/**\n * Dag walker for dag-json CIDs. Does not actually use dag-json since\n * all we are interested in is extracting the the CIDs from the block\n * so we can just use cborg/json for that.\n */\nconst dagJsonWalker = {\n    codec: _ipld_dag_json__WEBPACK_IMPORTED_MODULE_1__.code,\n    *walk(block) {\n        const cids = [];\n        const tags = [];\n        tags[CID_TAG] = (string) => {\n            const cid = multiformats__WEBPACK_IMPORTED_MODULE_5__.CID.parse(string);\n            cids.push(cid);\n            return cid;\n        };\n        cborg_json__WEBPACK_IMPORTED_MODULE_4__.decode(block, {\n            tags,\n            tokenizer: new DagJsonTokenizer(block, {\n                tags,\n                allowIndefinite: true,\n                allowUndefined: true,\n                allowNaN: true,\n                allowInfinity: true,\n                allowBigInt: true,\n                strict: false,\n                rejectDuplicateMapKeys: false\n            })\n        });\n        yield* cids;\n    }\n};\n/**\n * Dag walker for json CIDs. JSON has no facility for linking to\n * external blocks so the walker is a no-op.\n */\nconst jsonWalker = {\n    codec: multiformats_codecs_json__WEBPACK_IMPORTED_MODULE_7__.code,\n    *walk() { }\n};\nfunction defaultDagWalkers(walkers = []) {\n    const output = {};\n    [\n        dagPbWalker,\n        rawWalker,\n        dagCborWalker,\n        dagJsonWalker,\n        jsonWalker,\n        ...walkers\n    ].forEach(dagWalker => {\n        output[dagWalker.codec] = dagWalker;\n    });\n    return output;\n}\n//# sourceMappingURL=dag-walkers.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/dag-walkers.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/datastore-version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/datastore-version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertDatastoreVersionIsCurrent: () => (/* binding */ assertDatastoreVersionIsCurrent)\n/* harmony export */ });\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n\n\n\nconst DS_VERSION_KEY = new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key('/version');\nconst CURRENT_VERSION = 1;\nasync function assertDatastoreVersionIsCurrent(datastore) {\n    if (!(await datastore.has(DS_VERSION_KEY))) {\n        await datastore.put(DS_VERSION_KEY, (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_1__.fromString)(`${CURRENT_VERSION}`));\n        return;\n    }\n    const buf = await datastore.get(DS_VERSION_KEY);\n    const str = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(buf);\n    const version = parseInt(str, 10);\n    if (version !== CURRENT_VERSION) {\n        // TODO: write migrations when we break compatibility - for an example, see https://github.com/ipfs/js-ipfs-repo/tree/master/packages/ipfs-repo-migrations\n        throw new Error('Unknown datastore version, a datastore migration may be required');\n    }\n}\n//# sourceMappingURL=datastore-version.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/datastore-version.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/default-hashers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/default-hashers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultHashers: () => (/* binding */ defaultHashers)\n/* harmony export */ });\n/* harmony import */ var multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/hashes/identity */ \"./node_modules/multiformats/dist/src/hashes/identity.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"./node_modules/multiformats/dist/src/hashes/sha2-browser.js\");\n\n\nfunction defaultHashers(hashers = []) {\n    const output = {};\n    [\n        multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha256,\n        multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        multiformats_hashes_identity__WEBPACK_IMPORTED_MODULE_0__.identity,\n        ...hashers\n    ].forEach(hasher => {\n        output[hasher.code] = hasher;\n    });\n    return output;\n}\n//# sourceMappingURL=default-hashers.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/default-hashers.js?");

/***/ }),

/***/ "./node_modules/@helia/utils/dist/src/utils/networked-storage.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@helia/utils/dist/src/utils/networked-storage.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkedStorage: () => (/* binding */ NetworkedStorage),\n/* harmony export */   getCidBlockVerifierFunction: () => (/* binding */ getCidBlockVerifierFunction)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/startable.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var any_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! any-signal */ \"./node_modules/any-signal/dist/src/index.js\");\n/* harmony import */ var blockstore_core_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blockstore-core/identity */ \"./node_modules/blockstore-core/dist/src/identity.js\");\n/* harmony import */ var blockstore_core_tiered__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blockstore-core/tiered */ \"./node_modules/blockstore-core/dist/src/tiered.js\");\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_foreach__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-foreach */ \"./node_modules/it-foreach/dist/src/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n\n\n\n\n\n\n\n\nfunction isBlockRetriever(b) {\n    return typeof b.retrieve === 'function';\n}\nfunction isBlockAnnouncer(b) {\n    return typeof b.announce === 'function';\n}\n/**\n * Networked storage wraps a regular blockstore - when getting blocks if the\n * blocks are not present Bitswap will be used to fetch them from network peers.\n */\nclass NetworkedStorage {\n    child;\n    blockRetrievers;\n    blockAnnouncers;\n    hashers;\n    started;\n    log;\n    /**\n     * Create a new BlockStorage\n     */\n    constructor(components) {\n        this.log = components.logger.forComponent('helia:networked-storage');\n        this.child = new blockstore_core_tiered__WEBPACK_IMPORTED_MODULE_2__.TieredBlockstore([\n            new blockstore_core_identity__WEBPACK_IMPORTED_MODULE_1__.IdentityBlockstore(),\n            components.blockstore\n        ]);\n        this.blockRetrievers = (components.blockBrokers ?? []).filter(isBlockRetriever);\n        this.blockAnnouncers = (components.blockBrokers ?? []).filter(isBlockAnnouncer);\n        this.hashers = components.hashers ?? {};\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.start)(this.child, ...new Set([...this.blockRetrievers, ...this.blockAnnouncers]));\n        this.started = true;\n    }\n    async stop() {\n        await (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.stop)(this.child, ...new Set([...this.blockRetrievers, ...this.blockAnnouncers]));\n        this.started = false;\n    }\n    unwrap() {\n        return this.child;\n    }\n    /**\n     * Put a block to the underlying datastore\n     */\n    async put(cid, block, options = {}) {\n        if (await this.child.has(cid)) {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put:duplicate', cid));\n            return cid;\n        }\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put:providers:notify', cid));\n        this.blockAnnouncers.forEach(provider => {\n            provider.announce(cid, block, options);\n        });\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put:blockstore:put', cid));\n        return this.child.put(cid, block, options);\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore\n     */\n    async *putMany(blocks, options = {}) {\n        const missingBlocks = (0,it_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(blocks, async ({ cid }) => {\n            const has = await this.child.has(cid);\n            if (has) {\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put-many:duplicate', cid));\n            }\n            return !has;\n        });\n        const notifyEach = (0,it_foreach__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(missingBlocks, ({ cid, block }) => {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put-many:providers:notify', cid));\n            this.blockAnnouncers.forEach(provider => {\n                provider.announce(cid, block, options);\n            });\n        });\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:put-many:blockstore:put-many'));\n        yield* this.child.putMany(notifyEach, options);\n    }\n    /**\n     * Get a block by cid\n     */\n    async get(cid, options = {}) {\n        if (options.offline !== true && !(await this.child.has(cid))) {\n            // we do not have the block locally, get it from a block provider\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:providers:get', cid));\n            const block = await raceBlockRetrievers(cid, this.blockRetrievers, this.hashers[cid.multihash.code], {\n                ...options,\n                log: this.log\n            });\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:blockstore:put', cid));\n            await this.child.put(cid, block, options);\n            // notify other block providers of the new block\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:providers:notify', cid));\n            this.blockAnnouncers.forEach(provider => {\n                provider.announce(cid, block, options);\n            });\n            return block;\n        }\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get:blockstore:get', cid));\n        return this.child.get(cid, options);\n    }\n    /**\n     * Get multiple blocks back from an (async) iterable of cids\n     */\n    async *getMany(cids, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:blockstore:get-many'));\n        yield* this.child.getMany((0,it_foreach__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(cids, async (cid) => {\n            if (options.offline !== true && !(await this.child.has(cid))) {\n                // we do not have the block locally, get it from a block provider\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:providers:get', cid));\n                const block = await raceBlockRetrievers(cid, this.blockRetrievers, this.hashers[cid.multihash.code], {\n                    ...options,\n                    log: this.log\n                });\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:blockstore:put', cid));\n                await this.child.put(cid, block, options);\n                // notify other block providers of the new block\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-many:providers:notify', cid));\n                this.blockAnnouncers.forEach(provider => {\n                    provider.announce(cid, block, options);\n                });\n            }\n        }));\n    }\n    /**\n     * Delete a block from the blockstore\n     */\n    async delete(cid, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:delete:blockstore:delete', cid));\n        await this.child.delete(cid, options);\n    }\n    /**\n     * Delete multiple blocks from the blockstore\n     */\n    async *deleteMany(cids, options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:delete-many:blockstore:delete-many'));\n        yield* this.child.deleteMany((async function* () {\n            for await (const cid of cids) {\n                yield cid;\n            }\n        }()), options);\n    }\n    async has(cid, options = {}) {\n        return this.child.has(cid, options);\n    }\n    async *getAll(options = {}) {\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_5__.CustomProgressEvent('blocks:get-all:blockstore:get-many'));\n        yield* this.child.getAll(options);\n    }\n}\nconst getCidBlockVerifierFunction = (cid, hasher) => {\n    if (hasher == null) {\n        throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`, 'ERR_UNKNOWN_HASH_ALG');\n    }\n    return async (block) => {\n        // verify block\n        const hash = await hasher.digest(block);\n        if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_6__.equals)(hash.digest, cid.multihash.digest)) {\n            // if a hash mismatch occurs for a TrustlessGatewayBlockBroker, we should try another gateway\n            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_8__.CodeError('Hash of downloaded block did not match multihash from passed CID', 'ERR_HASH_MISMATCH');\n        }\n    };\n};\n/**\n * Race block providers cancelling any pending requests once the block has been\n * found.\n */\nasync function raceBlockRetrievers(cid, providers, hasher, options) {\n    const validateFn = getCidBlockVerifierFunction(cid, hasher);\n    const controller = new AbortController();\n    const signal = (0,any_signal__WEBPACK_IMPORTED_MODULE_0__.anySignal)([controller.signal, options.signal]);\n    try {\n        return await Promise.any(providers.map(async (provider) => {\n            try {\n                let blocksWereValidated = false;\n                const block = await provider.retrieve(cid, {\n                    ...options,\n                    signal,\n                    validateFn: async (block) => {\n                        await validateFn(block);\n                        blocksWereValidated = true;\n                    }\n                });\n                if (!blocksWereValidated) {\n                    // the blockBroker either did not throw an error when attempting to validate the block\n                    // or did not call the validateFn at all. We should validate the block ourselves\n                    await validateFn(block);\n                }\n                return block;\n            }\n            catch (err) {\n                options.log.error('could not retrieve verified block for %c', cid, err);\n                throw err;\n            }\n        }));\n    }\n    finally {\n        signal.clear();\n    }\n}\n//# sourceMappingURL=networked-storage.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@helia/utils/dist/src/utils/networked-storage.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/event-target.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/event-target.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomEvent: () => (/* binding */ CustomEvent),\n/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@libp2p/interface/dist/src/events.js\");\n\n/**\n * An implementation of a typed event target\n * etc\n */\nclass TypedEventEmitter extends EventTarget {\n    #listeners = new Map();\n    constructor() {\n        super();\n        // silence MaxListenersExceededWarning warning on Node.js, this is a red\n        // herring almost all of the time\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_0__.setMaxListeners)(Infinity, this);\n    }\n    listenerCount(type) {\n        const listeners = this.#listeners.get(type);\n        if (listeners == null) {\n            return 0;\n        }\n        return listeners.length;\n    }\n    addEventListener(type, listener, options) {\n        super.addEventListener(type, listener, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            list = [];\n            this.#listeners.set(type, list);\n        }\n        list.push({\n            callback: listener,\n            once: (options !== true && options !== false && options?.once) ?? false\n        });\n    }\n    removeEventListener(type, listener, options) {\n        super.removeEventListener(type.toString(), listener ?? null, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            return;\n        }\n        list = list.filter(({ callback }) => callback !== listener);\n        this.#listeners.set(type, list);\n    }\n    dispatchEvent(event) {\n        const result = super.dispatchEvent(event);\n        let list = this.#listeners.get(event.type);\n        if (list == null) {\n            return result;\n        }\n        list = list.filter(({ once }) => !once);\n        this.#listeners.set(event.type, list);\n        return result;\n    }\n    safeDispatchEvent(type, detail = {}) {\n        return this.dispatchEvent(new CustomEvent(type, detail));\n    }\n}\n/**\n * CustomEvent is a standard event but it's not supported by node.\n *\n * Remove this when https://github.com/nodejs/node/issues/40678 is closed.\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n */\nclass CustomEventPolyfill extends Event {\n    /** Returns any custom data event was created with. Typically used for synthetic events. */\n    detail;\n    constructor(message, data) {\n        super(message, data);\n        // @ts-expect-error could be undefined\n        this.detail = data?.detail;\n    }\n}\nconst CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;\n//# sourceMappingURL=event-target.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/event-target.js?");

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/startable.js":
/*!**************************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/startable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isStartable: () => (/* binding */ isStartable),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   stop: () => (/* binding */ stop)\n/* harmony export */ });\nfunction isStartable(obj) {\n    return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function';\n}\nasync function start(...objs) {\n    const startables = [];\n    for (const obj of objs) {\n        if (isStartable(obj)) {\n            startables.push(obj);\n        }\n    }\n    await Promise.all(startables.map(async (s) => {\n        if (s.beforeStart != null) {\n            await s.beforeStart();\n        }\n    }));\n    await Promise.all(startables.map(async (s) => {\n        await s.start();\n    }));\n    await Promise.all(startables.map(async (s) => {\n        if (s.afterStart != null) {\n            await s.afterStart();\n        }\n    }));\n}\nasync function stop(...objs) {\n    const startables = [];\n    for (const obj of objs) {\n        if (isStartable(obj)) {\n            startables.push(obj);\n        }\n    }\n    await Promise.all(startables.map(async (s) => {\n        if (s.beforeStop != null) {\n            await s.beforeStop();\n        }\n    }));\n    await Promise.all(startables.map(async (s) => {\n        await s.stop();\n    }));\n    await Promise.all(startables.map(async (s) => {\n        if (s.afterStop != null) {\n            await s.afterStop();\n        }\n    }));\n}\n//# sourceMappingURL=startable.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/interface/dist/src/startable.js?");

/***/ }),

/***/ "./node_modules/@libp2p/peer-collections/dist/src/set.js":
/*!***************************************************************!*\
  !*** ./node_modules/@libp2p/peer-collections/dist/src/set.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PeerSet: () => (/* binding */ PeerSet),\n/* harmony export */   peerSet: () => (/* binding */ peerSet)\n/* harmony export */ });\n/* harmony import */ var _libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/peer-id */ \"./node_modules/@libp2p/peer-id/dist/src/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@libp2p/peer-collections/dist/src/util.js\");\n\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nclass PeerSet {\n    set;\n    constructor(set) {\n        this.set = new Set();\n        if (set != null) {\n            for (const key of set) {\n                this.set.add(key.toString());\n            }\n        }\n    }\n    get size() {\n        return this.set.size;\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n    add(peer) {\n        this.set.add(peer.toString());\n    }\n    clear() {\n        this.set.clear();\n    }\n    delete(peer) {\n        this.set.delete(peer.toString());\n    }\n    entries() {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.mapIterable)(this.set.entries(), (val) => {\n            const peerId = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(val[0]);\n            return [peerId, peerId];\n        });\n    }\n    forEach(predicate) {\n        this.set.forEach((str) => {\n            const id = (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(str);\n            predicate(id, id, this);\n        });\n    }\n    has(peer) {\n        return this.set.has(peer.toString());\n    }\n    values() {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.mapIterable)(this.set.values(), (val) => {\n            return (0,_libp2p_peer_id__WEBPACK_IMPORTED_MODULE_1__.peerIdFromString)(val);\n        });\n    }\n    intersection(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            if (this.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    difference(other) {\n        const output = new PeerSet();\n        for (const peerId of this) {\n            if (!other.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    union(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            output.add(peerId);\n        }\n        for (const peerId of this) {\n            output.add(peerId);\n        }\n        return output;\n    }\n}\nfunction peerSet() {\n    return new PeerSet();\n}\n//# sourceMappingURL=set.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/peer-collections/dist/src/set.js?");

/***/ }),

/***/ "./node_modules/@libp2p/peer-collections/dist/src/util.js":
/*!****************************************************************!*\
  !*** ./node_modules/@libp2p/peer-collections/dist/src/util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapIterable: () => (/* binding */ mapIterable)\n/* harmony export */ });\n/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nfunction mapIterable(iter, map) {\n    const iterator = {\n        [Symbol.iterator]: () => {\n            return iterator;\n        },\n        next: () => {\n            const next = iter.next();\n            const val = next.value;\n            if (next.done === true || val == null) {\n                const result = {\n                    done: true,\n                    value: undefined\n                };\n                return result;\n            }\n            return {\n                done: false,\n                value: map(val)\n            };\n        }\n    };\n    return iterator;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/peer-collections/dist/src/util.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/queue/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/queue/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/event-target.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var race_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! race-event */ \"./node_modules/race-event/dist/src/index.js\");\n/* harmony import */ var _job_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job.js */ \"./node_modules/@libp2p/utils/dist/src/queue/job.js\");\n\n\n\n\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n */\nclass Queue extends _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.TypedEventEmitter {\n    concurrency;\n    queue;\n    pending;\n    constructor(init = {}) {\n        super();\n        this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;\n        this.pending = 0;\n        if (init.metricName != null) {\n            init.metrics?.registerMetricGroup(init.metricName, {\n                calculate: () => {\n                    return {\n                        size: this.queue.length,\n                        running: this.pending,\n                        queued: this.queue.length - this.pending\n                    };\n                }\n            });\n        }\n        this.queue = [];\n    }\n    tryToStartAnother() {\n        if (this.size === 0) {\n            // do this in the microtask queue so all job recipients receive the\n            // result before the \"empty\" event fires\n            queueMicrotask(() => {\n                this.safeDispatchEvent('empty');\n            });\n            if (this.running === 0) {\n                // do this in the microtask queue so all job recipients receive the\n                // result before the \"idle\" event fires\n                queueMicrotask(() => {\n                    this.safeDispatchEvent('idle');\n                });\n            }\n            return false;\n        }\n        if (this.pending < this.concurrency) {\n            let job;\n            for (const j of this.queue) {\n                if (j.status === 'queued') {\n                    job = j;\n                    break;\n                }\n            }\n            if (job == null) {\n                return false;\n            }\n            this.safeDispatchEvent('active');\n            this.pending++;\n            job.run()\n                .finally(() => {\n                // remove the job from the queue\n                for (let i = 0; i < this.queue.length; i++) {\n                    if (this.queue[i] === job) {\n                        this.queue.splice(i, 1);\n                        break;\n                    }\n                }\n                this.pending--;\n                this.tryToStartAnother();\n                this.safeDispatchEvent('next');\n            });\n            return true;\n        }\n        return false;\n    }\n    enqueue(job) {\n        if (this.queue[this.size - 1]?.priority >= job.priority) {\n            this.queue.push(job);\n            return;\n        }\n        const index = lowerBound(this.queue, job, (a, b) => b.priority - a.priority);\n        this.queue.splice(index, 0, job);\n    }\n    /**\n     * Adds a sync or async task to the queue. Always returns a promise.\n     */\n    async add(fn, options) {\n        options?.signal?.throwIfAborted();\n        const job = new _job_js__WEBPACK_IMPORTED_MODULE_3__.Job(fn, options, options?.priority);\n        const p = job.join(options)\n            .then(result => {\n            this.safeDispatchEvent('completed', { detail: result });\n            return result;\n        })\n            .catch(err => {\n            this.safeDispatchEvent('error', { detail: err });\n            throw err;\n        });\n        this.enqueue(job);\n        this.safeDispatchEvent('add');\n        this.tryToStartAnother();\n        return p;\n    }\n    /**\n     * Clear the queue\n     */\n    clear() {\n        this.queue.splice(0, this.queue.length);\n    }\n    /**\n     * Abort all jobs in the queue and clear it\n     */\n    abort() {\n        this.queue.forEach(job => {\n            job.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.AbortError());\n        });\n        this.clear();\n    }\n    /**\n     * Can be called multiple times. Useful if you for example add additional items at a later time.\n     *\n     * @returns A promise that settles when the queue becomes empty.\n     */\n    async onEmpty(options) {\n        // Instantly resolve if the queue is empty\n        if (this.size === 0) {\n            return;\n        }\n        await (0,race_event__WEBPACK_IMPORTED_MODULE_1__.raceEvent)(this, 'empty', options?.signal);\n    }\n    /**\n     * @returns A promise that settles when the queue size is less than the given\n     * limit: `queue.size < limit`.\n     *\n     * If you want to avoid having the queue grow beyond a certain size you can\n     * `await queue.onSizeLessThan()` before adding a new item.\n     *\n     * Note that this only limits the number of items waiting to start. There\n     * could still be up to `concurrency` jobs already running that this call does\n     * not include in its calculation.\n     */\n    async onSizeLessThan(limit, options) {\n        // Instantly resolve if the queue is empty.\n        if (this.size < limit) {\n            return;\n        }\n        await (0,race_event__WEBPACK_IMPORTED_MODULE_1__.raceEvent)(this, 'next', options?.signal, {\n            filter: () => this.size < limit\n        });\n    }\n    /**\n     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n     * from the queue has finished. `.onEmpty` merely signals that the queue is\n     * empty, but it could mean that some promises haven't completed yet.\n     *\n     * @returns A promise that settles when the queue becomes empty, and all\n     * promises have completed; `queue.size === 0 && queue.pending === 0`.\n     */\n    async onIdle(options) {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.pending === 0 && this.size === 0) {\n            return;\n        }\n        await (0,race_event__WEBPACK_IMPORTED_MODULE_1__.raceEvent)(this, 'idle', options?.signal);\n    }\n    /**\n     * Size of the queue including running items\n     */\n    get size() {\n        return this.queue.length;\n    }\n    /**\n     * The number of queued items waiting to run.\n     */\n    get queued() {\n        return this.queue.length - this.pending;\n    }\n    /**\n     * The number of items currently running.\n     */\n    get running() {\n        return this.pending;\n    }\n    /**\n     * Returns an async generator that makes it easy to iterate over the results\n     * of jobs added to the queue.\n     *\n     * The generator will end when the queue becomes idle, that is there are no\n     * jobs running and no jobs that have yet to run.\n     *\n     * If you need to keep the queue open indefinitely, consider using it-pushable\n     * instead.\n     */\n    async *toGenerator(options) {\n        options?.signal?.throwIfAborted();\n        const stream = (0,it_pushable__WEBPACK_IMPORTED_MODULE_0__.pushable)({\n            objectMode: true\n        });\n        const cleanup = (err) => {\n            if (err != null) {\n                this.abort();\n            }\n            else {\n                this.clear();\n            }\n            stream.end(err);\n        };\n        const onQueueJobComplete = (evt) => {\n            if (evt.detail != null) {\n                stream.push(evt.detail);\n            }\n        };\n        const onQueueError = (evt) => {\n            cleanup(evt.detail);\n        };\n        const onQueueIdle = () => {\n            cleanup();\n        };\n        // clear the queue and throw if the query is aborted\n        const onSignalAbort = () => {\n            cleanup(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_4__.CodeError('Queue aborted', 'ERR_QUEUE_ABORTED'));\n        };\n        // add listeners\n        this.addEventListener('completed', onQueueJobComplete);\n        this.addEventListener('error', onQueueError);\n        this.addEventListener('idle', onQueueIdle);\n        options?.signal?.addEventListener('abort', onSignalAbort);\n        try {\n            yield* stream;\n        }\n        finally {\n            // remove listeners\n            this.removeEventListener('completed', onQueueJobComplete);\n            this.removeEventListener('error', onQueueError);\n            this.removeEventListener('idle', onQueueIdle);\n            options?.signal?.removeEventListener('abort', onSignalAbort);\n            // empty the queue for when the user has broken out of a loop early\n            cleanup();\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/queue/index.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/queue/job.js":
/*!**********************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/queue/job.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Job: () => (/* binding */ Job)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/events.js\");\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var race_signal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! race-signal */ \"./node_modules/race-signal/dist/src/index.js\");\n/* harmony import */ var _recipient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recipient.js */ \"./node_modules/@libp2p/utils/dist/src/queue/recipient.js\");\n\n\n\n/**\n * Returns a random string\n */\nfunction randomId() {\n    return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`;\n}\nclass Job {\n    id;\n    fn;\n    options;\n    priority;\n    recipients;\n    status;\n    timeline;\n    controller;\n    constructor(fn, options, priority = 0) {\n        this.id = randomId();\n        this.status = 'queued';\n        this.fn = fn;\n        this.priority = priority;\n        this.options = options;\n        this.recipients = [];\n        this.timeline = {\n            created: Date.now()\n        };\n        this.controller = new AbortController();\n        (0,_libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.setMaxListeners)(Infinity, this.controller.signal);\n        this.onAbort = this.onAbort.bind(this);\n    }\n    abort(err) {\n        this.controller.abort(err);\n    }\n    onAbort() {\n        const allAborted = this.recipients.reduce((acc, curr) => {\n            return acc && (curr.signal?.aborted === true);\n        }, true);\n        // if all recipients have aborted the job, actually abort the job\n        if (allAborted) {\n            this.controller.abort(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_2__.AbortError());\n        }\n    }\n    async join(options = {}) {\n        const recipient = new _recipient_js__WEBPACK_IMPORTED_MODULE_3__.JobRecipient((new Error('where')).stack, options.signal);\n        this.recipients.push(recipient);\n        options.signal?.addEventListener('abort', this.onAbort);\n        return recipient.deferred.promise;\n    }\n    async run() {\n        this.status = 'running';\n        this.timeline.started = Date.now();\n        try {\n            this.controller.signal.throwIfAborted();\n            const result = await (0,race_signal__WEBPACK_IMPORTED_MODULE_0__.raceSignal)(this.fn({\n                ...(this.options ?? {}),\n                signal: this.controller.signal\n            }), this.controller.signal);\n            this.recipients.forEach(recipient => {\n                recipient.deferred.resolve(result);\n            });\n            this.status = 'complete';\n        }\n        catch (err) {\n            this.recipients.forEach(recipient => {\n                recipient.deferred.reject(err);\n            });\n            this.status = 'errored';\n        }\n        finally {\n            this.timeline.finished = Date.now();\n            this.cleanup();\n        }\n    }\n    cleanup() {\n        this.recipients.forEach(recipient => {\n            recipient.signal?.removeEventListener('abort', this.onAbort);\n        });\n    }\n}\n//# sourceMappingURL=job.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/queue/job.js?");

/***/ }),

/***/ "./node_modules/@libp2p/utils/dist/src/queue/recipient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@libp2p/utils/dist/src/queue/recipient.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobRecipient: () => (/* binding */ JobRecipient)\n/* harmony export */ });\n/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @libp2p/interface */ \"./node_modules/@libp2p/interface/dist/src/errors.js\");\n/* harmony import */ var p_defer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-defer */ \"./node_modules/p-defer/index.js\");\n\n\nclass JobRecipient {\n    deferred;\n    signal;\n    where;\n    constructor(where, signal) {\n        this.signal = signal;\n        this.deferred = (0,p_defer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        this.where = where;\n        this.onAbort = this.onAbort.bind(this);\n        this.signal?.addEventListener('abort', this.onAbort);\n    }\n    onAbort() {\n        this.deferred.reject(new _libp2p_interface__WEBPACK_IMPORTED_MODULE_1__.AbortError());\n    }\n    cleanup() {\n        this.signal?.removeEventListener('abort', this.onAbort);\n    }\n}\n//# sourceMappingURL=recipient.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@libp2p/utils/dist/src/queue/recipient.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/dns.js":
/*!********************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/dns.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS)\n/* harmony export */ });\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _resolvers_default_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolvers/default.js */ \"./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js\");\n/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/cache.js */ \"./node_modules/@multiformats/dns/dist/src/utils/cache.js\");\n/* harmony import */ var _utils_get_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/get-types.js */ \"./node_modules/@multiformats/dns/dist/src/utils/get-types.js\");\n\n\n\n\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000;\nclass DNS {\n    resolvers;\n    cache;\n    constructor(init) {\n        this.resolvers = {};\n        this.cache = (0,_utils_cache_js__WEBPACK_IMPORTED_MODULE_2__.cache)(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);\n        Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n            if (!Array.isArray(resolver)) {\n                resolver = [resolver];\n            }\n            // convert `com` -> `com.`\n            if (!tld.endsWith('.')) {\n                tld = `${tld}.`;\n            }\n            this.resolvers[tld] = resolver;\n        });\n        // configure default resolver if none specified\n        if (this.resolvers['.'] == null) {\n            this.resolvers['.'] = (0,_resolvers_default_js__WEBPACK_IMPORTED_MODULE_1__.defaultResolver)();\n        }\n    }\n    /**\n     * Queries DNS resolvers for the passed record types for the passed domain.\n     *\n     * If cached records exist for all desired types they will be returned\n     * instead.\n     *\n     * Any new responses will be added to the cache for subsequent requests.\n     */\n    async query(domain, options = {}) {\n        const types = (0,_utils_get_types_js__WEBPACK_IMPORTED_MODULE_3__.getTypes)(options.types);\n        const cached = options.cached !== false ? this.cache.get(domain, types) : undefined;\n        if (cached != null) {\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:cache', { detail: cached }));\n            return cached;\n        }\n        const tld = `${domain.split('.').pop()}.`;\n        const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n            return (Math.random() > 0.5) ? -1 : 1;\n        });\n        const errors = [];\n        for (const resolver of resolvers) {\n            // skip further resolutions if the user aborted the signal\n            if (options.signal?.aborted === true) {\n                break;\n            }\n            try {\n                const result = await resolver(domain, {\n                    ...options,\n                    types\n                });\n                for (const answer of result.Answer) {\n                    this.cache.add(domain, answer);\n                }\n                return result;\n            }\n            catch (err) {\n                errors.push(err);\n                options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:error', { detail: err }));\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);\n    }\n}\n//# sourceMappingURL=dns.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/dns.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_RECURSIVE_DEPTH: () => (/* binding */ MAX_RECURSIVE_DEPTH),\n/* harmony export */   RecordType: () => (/* binding */ RecordType),\n/* harmony export */   dns: () => (/* binding */ dns)\n/* harmony export */ });\n/* harmony import */ var _dns_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dns.js */ \"./node_modules/@multiformats/dns/dist/src/dns.js\");\n/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\n\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nvar RecordType;\n(function (RecordType) {\n    RecordType[RecordType[\"A\"] = 1] = \"A\";\n    RecordType[RecordType[\"CNAME\"] = 5] = \"CNAME\";\n    RecordType[RecordType[\"TXT\"] = 16] = \"TXT\";\n    RecordType[RecordType[\"AAAA\"] = 28] = \"AAAA\";\n})(RecordType || (RecordType = {}));\n/**\n * The default maximum amount of recursion allowed during a query\n */\nconst MAX_RECURSIVE_DEPTH = 32;\nfunction dns(init = {}) {\n    return new _dns_js__WEBPACK_IMPORTED_MODULE_0__.DNS(init);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultResolver: () => (/* binding */ defaultResolver)\n/* harmony export */ });\n/* harmony import */ var _dns_json_over_https_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dns-json-over-https.js */ \"./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js\");\n\nfunction defaultResolver() {\n    return [\n        (0,_dns_json_over_https_js__WEBPACK_IMPORTED_MODULE_0__.dnsJsonOverHttps)('https://cloudflare-dns.com/dns-query'),\n        (0,_dns_json_over_https_js__WEBPACK_IMPORTED_MODULE_0__.dnsJsonOverHttps)('https://dns.google/resolve')\n    ];\n}\n//# sourceMappingURL=default.browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_QUERY_CONCURRENCY: () => (/* binding */ DEFAULT_QUERY_CONCURRENCY),\n/* harmony export */   dnsJsonOverHttps: () => (/* binding */ dnsJsonOverHttps)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var progress_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! progress-events */ \"./node_modules/progress-events/dist/src/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n/* harmony import */ var _utils_get_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/get-types.js */ \"./node_modules/@multiformats/dns/dist/src/utils/get-types.js\");\n/* harmony import */ var _utils_to_dns_response_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/to-dns-response.js */ \"./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js\");\n/* eslint-env browser */\n\n\n\n\n\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nconst DEFAULT_QUERY_CONCURRENCY = 4;\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nfunction dnsJsonOverHttps(url, init = {}) {\n    const httpQueue = new p_queue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n        concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n    });\n    return async (fqdn, options = {}) => {\n        const searchParams = new URLSearchParams();\n        searchParams.set('name', fqdn);\n        (0,_utils_get_types_js__WEBPACK_IMPORTED_MODULE_2__.getTypes)(options.types).forEach(type => {\n            // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n            searchParams.append('type', _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[type]);\n        });\n        options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:query', { detail: fqdn }));\n        // query DNS-JSON over HTTPS server\n        const response = await httpQueue.add(async () => {\n            const res = await fetch(`${url}?${searchParams}`, {\n                headers: {\n                    accept: 'application/dns-json'\n                },\n                signal: options?.signal\n            });\n            if (res.status !== 200) {\n                throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);\n            }\n            const response = (0,_utils_to_dns_response_js__WEBPACK_IMPORTED_MODULE_3__.toDNSResponse)(await res.json());\n            options.onProgress?.(new progress_events__WEBPACK_IMPORTED_MODULE_0__.CustomProgressEvent('dns:response', { detail: response }));\n            return response;\n        }, {\n            signal: options.signal\n        });\n        if (response == null) {\n            throw new Error('No DNS response received');\n        }\n        return response;\n    };\n}\n//# sourceMappingURL=dns-json-over-https.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/utils/cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/utils/cache.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cache: () => (/* binding */ cache)\n/* harmony export */ });\n/* harmony import */ var hashlru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hashlru */ \"./node_modules/hashlru/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n/* harmony import */ var _to_dns_response_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./to-dns-response.js */ \"./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js\");\n\n\n\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n    lru;\n    constructor(maxSize) {\n        this.lru = hashlru__WEBPACK_IMPORTED_MODULE_0__(maxSize);\n    }\n    get(fqdn, types) {\n        let foundAllAnswers = true;\n        const answers = [];\n        for (const type of types) {\n            const cached = this.getAnswers(fqdn, type);\n            if (cached.length === 0) {\n                foundAllAnswers = false;\n                break;\n            }\n            answers.push(...cached);\n        }\n        if (foundAllAnswers) {\n            return (0,_to_dns_response_js__WEBPACK_IMPORTED_MODULE_2__.toDNSResponse)({ answers });\n        }\n    }\n    getAnswers(domain, type) {\n        const key = `${domain.toLowerCase()}-${type}`;\n        const answers = this.lru.get(key);\n        if (answers != null) {\n            const cachedAnswers = answers\n                .filter((entry) => {\n                return entry.expires > Date.now();\n            })\n                .map(({ expires, value }) => ({\n                ...value,\n                TTL: Math.round((expires - Date.now()) / 1000),\n                type: _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[value.type]\n            }));\n            if (cachedAnswers.length === 0) {\n                this.lru.remove(key);\n            }\n            // @ts-expect-error hashlru stringifies stored types which turns enums\n            // into strings, we convert back into enums above but tsc doesn't know\n            return cachedAnswers;\n        }\n        return [];\n    }\n    add(domain, answer) {\n        const key = `${domain.toLowerCase()}-${answer.type}`;\n        const answers = this.lru.get(key) ?? [];\n        answers.push({\n            expires: Date.now() + ((answer.TTL ?? _to_dns_response_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_TTL) * 1000),\n            value: answer\n        });\n        this.lru.set(key, answers);\n    }\n    remove(domain, type) {\n        const key = `${domain.toLowerCase()}-${type}`;\n        this.lru.remove(key);\n    }\n    clear() {\n        this.lru.clear();\n    }\n}\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nfunction cache(size) {\n    return new CachedAnswers(size);\n}\n//# sourceMappingURL=cache.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/utils/cache.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/utils/get-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/utils/get-types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTypes: () => (/* binding */ getTypes)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n\nfunction getTypes(types) {\n    const DEFAULT_TYPES = [\n        _index_js__WEBPACK_IMPORTED_MODULE_0__.RecordType.A\n    ];\n    if (types == null) {\n        return DEFAULT_TYPES;\n    }\n    if (Array.isArray(types)) {\n        if (types.length === 0) {\n            return DEFAULT_TYPES;\n        }\n        return types;\n    }\n    return [\n        types\n    ];\n}\n//# sourceMappingURL=get-types.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/utils/get-types.js?");

/***/ }),

/***/ "./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TTL: () => (/* binding */ DEFAULT_TTL),\n/* harmony export */   toDNSResponse: () => (/* binding */ toDNSResponse)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@multiformats/dns/dist/src/index.js\");\n\n\n/**\n * This TTL will be used if the remote service does not return one\n */\nconst DEFAULT_TTL = 60;\nfunction toDNSResponse(obj) {\n    return {\n        Status: obj.Status ?? 0,\n        TC: obj.TC ?? obj.flag_tc ?? false,\n        RD: obj.RD ?? obj.flag_rd ?? false,\n        RA: obj.RA ?? obj.flag_ra ?? false,\n        AD: obj.AD ?? obj.flag_ad ?? false,\n        CD: obj.CD ?? obj.flag_cd ?? false,\n        Question: (obj.Question ?? obj.questions ?? []).map((question) => {\n            return {\n                name: question.name,\n                type: _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[question.type]\n            };\n        }),\n        Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {\n            return {\n                name: answer.name,\n                type: _index_js__WEBPACK_IMPORTED_MODULE_1__.RecordType[answer.type],\n                TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n                data: answer.data instanceof Uint8Array ? (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_0__.toString)(answer.data) : answer.data\n            };\n        })\n    };\n}\n//# sourceMappingURL=to-dns-response.js.map\n\n//# sourceURL=webpack://ems/./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/base.js":
/*!*******************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/base.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseBlockstore: () => (/* binding */ BaseBlockstore)\n/* harmony export */ });\nclass BaseBlockstore {\n    has(key, options) {\n        return Promise.reject(new Error('.has is not implemented'));\n    }\n    put(key, val, options) {\n        return Promise.reject(new Error('.put is not implemented'));\n    }\n    async *putMany(source, options) {\n        for await (const { cid, block } of source) {\n            await this.put(cid, block, options);\n            yield cid;\n        }\n    }\n    get(key, options) {\n        return Promise.reject(new Error('.get is not implemented'));\n    }\n    async *getMany(source, options) {\n        for await (const key of source) {\n            yield {\n                cid: key,\n                block: await this.get(key, options)\n            };\n        }\n    }\n    delete(key, options) {\n        return Promise.reject(new Error('.delete is not implemented'));\n    }\n    async *deleteMany(source, options) {\n        for await (const key of source) {\n            await this.delete(key, options);\n            yield key;\n        }\n    }\n    /**\n     * Extending classes should override `query` or implement this method\n     */\n    async *getAll(options) {\n        throw new Error('.getAll is not implemented');\n    }\n}\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/base.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/black-hole.js":
/*!*************************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/black-hole.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlackHoleBlockstore: () => (/* binding */ BlackHoleBlockstore)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n\n\nclass BlackHoleBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseBlockstore {\n    put(key) {\n        return key;\n    }\n    get() {\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.notFoundError();\n    }\n    has() {\n        return false;\n    }\n    async delete() {\n    }\n    async *getAll() {\n    }\n}\n//# sourceMappingURL=black-hole.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/black-hole.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abortedError: () => (/* binding */ abortedError),\n/* harmony export */   closeFailedError: () => (/* binding */ closeFailedError),\n/* harmony export */   deleteFailedError: () => (/* binding */ deleteFailedError),\n/* harmony export */   getFailedError: () => (/* binding */ getFailedError),\n/* harmony export */   hasFailedError: () => (/* binding */ hasFailedError),\n/* harmony export */   notFoundError: () => (/* binding */ notFoundError),\n/* harmony export */   openFailedError: () => (/* binding */ openFailedError),\n/* harmony export */   putFailedError: () => (/* binding */ putFailedError)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n\nfunction openFailedError(err) {\n    err = err ?? new Error('Open failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_OPEN_FAILED');\n}\nfunction closeFailedError(err) {\n    err = err ?? new Error('Close failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_CLOSE_FAILED');\n}\nfunction putFailedError(err) {\n    err = err ?? new Error('Put failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_PUT_FAILED');\n}\nfunction getFailedError(err) {\n    err = err ?? new Error('Get failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_GET_FAILED');\n}\nfunction deleteFailedError(err) {\n    err = err ?? new Error('Delete failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DELETE_FAILED');\n}\nfunction hasFailedError(err) {\n    err = err ?? new Error('Has failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_HAS_FAILED');\n}\nfunction notFoundError(err) {\n    err = err ?? new Error('Not Found');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_NOT_FOUND');\n}\nfunction abortedError(err) {\n    err = err ?? new Error('Aborted');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_ABORTED');\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/identity.js":
/*!***********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/identity.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdentityBlockstore: () => (/* binding */ IdentityBlockstore)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./node_modules/blockstore-core/dist/src/index.js\");\n\n\n// https://github.com/multiformats/multicodec/blob/d06fc6194710e8909bac64273c43f16b56ca4c34/table.csv#L2\nconst IDENTITY_CODEC = 0x00;\nclass IdentityBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseBlockstore {\n    child;\n    constructor(child) {\n        super();\n        this.child = child;\n    }\n    put(key, block) {\n        if (key.multihash.code === IDENTITY_CODEC) {\n            return key;\n        }\n        if (this.child == null) {\n            return key;\n        }\n        return this.child.put(key, block);\n    }\n    get(key) {\n        if (key.multihash.code === IDENTITY_CODEC) {\n            return key.multihash.digest;\n        }\n        if (this.child == null) {\n            throw _index_js__WEBPACK_IMPORTED_MODULE_1__.Errors.notFoundError();\n        }\n        return this.child.get(key);\n    }\n    has(key) {\n        if (key.multihash.code === IDENTITY_CODEC) {\n            return true;\n        }\n        if (this.child == null) {\n            return false;\n        }\n        return this.child.has(key);\n    }\n    delete(key) {\n        if (key.code === IDENTITY_CODEC) {\n            return;\n        }\n        if (this.child != null) {\n            return this.child.delete(key);\n        }\n    }\n    getAll(options) {\n        if (this.child != null) {\n            return this.child.getAll(options);\n        }\n        return [];\n    }\n}\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/identity.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseBlockstore: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseBlockstore),\n/* harmony export */   BlackHoleBlockstore: () => (/* reexport safe */ _black_hole_js__WEBPACK_IMPORTED_MODULE_3__.BlackHoleBlockstore),\n/* harmony export */   Errors: () => (/* binding */ Errors),\n/* harmony export */   MemoryBlockstore: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_2__.MemoryBlockstore),\n/* harmony export */   TieredBlockstore: () => (/* reexport safe */ _tiered_js__WEBPACK_IMPORTED_MODULE_4__.TieredBlockstore)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory.js */ \"./node_modules/blockstore-core/dist/src/memory.js\");\n/* harmony import */ var _black_hole_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./black-hole.js */ \"./node_modules/blockstore-core/dist/src/black-hole.js\");\n/* harmony import */ var _tiered_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tiered.js */ \"./node_modules/blockstore-core/dist/src/tiered.js\");\n/**\n * @packageDocumentation\n *\n * Various Blockstore implementations are available.\n *\n * ## Implementations\n *\n * - Base: [`src/base`](src/base.ts)\n * - Memory: [`src/memory`](src/memory.ts)\n * - BlackHole: ['src/black-hole](src/black-hole.ts)\n * - Tiered: ['src/tiered](src/tiered.ts)\n *\n * @example BaseBlockstore\n *\n * Provides a complete implementation of the Blockstore interface.  You must implement `.get`, `.put`, etc.\n *\n * ```js\n * import { BaseBlockstore } from 'blockstore-core/base'\n *\n * class MyCustomBlockstore extends BaseBlockstore {\n *   put (key, val, options) {\n *     // store a block\n *   }\n *\n *   get (key, options) {\n *     // retrieve a block\n *   }\n *\n *   // ...etc\n * }\n * ```\n *\n * @example MemoryBlockstore\n *\n * A simple Blockstore that stores blocks in memory.\n *\n * ```js\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * const store = new MemoryBlockstore()\n * ```\n *\n * @example BlackHoleBlockstore\n *\n * A Blockstore that does not store any blocks.\n *\n * ```js\n * import { BlackHoleBlockstore } from 'blockstore-core/black-hole'\n *\n * const store = new BlackHoleBlockstore()\n * ```\n *\n * @example TieredBlockstore\n *\n * A tiered blockstore wraps one or more blockstores and will query each in parallel to retrieve a block - the operation will succeed if any wrapped store has the block.\n *\n * Writes are invoked on all wrapped blockstores.\n *\n * ```js\n * import { TieredBlockstore } from 'blockstore-core/tiered'\n *\n * const store = new TieredBlockstore([\n *   store1,\n *   store2,\n *   // ...etc\n * ])\n * ```\n *\n * @example IdentityBlockstore\n *\n * An identity blockstore is one that deals exclusively in Identity CIDs - this is a special CID with the codec [0x00](https://github.com/multiformats/multicodec/blob/d06fc6194710e8909bac64273c43f16b56ca4c34/table.csv#L2) where the multihash digest is the data that makes up the block.\n *\n * ```TypeScript\n * import { IdentityBlockstore } from 'blockstore-core/identity'\n * import { CID } from 'multiformats/cid'\n *\n * const blockstore = new IdentityBlockstore()\n *\n * blockstore.has(CID.parse('QmFoo')) // false\n *\n * blockstore.has(CID.parse('bafkqac3imvwgy3zao5xxe3de')) // true\n * ```\n */\n\n\n\n\n\nconst Errors = {\n    ..._errors_js__WEBPACK_IMPORTED_MODULE_0__\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/memory.js":
/*!*********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/memory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryBlockstore: () => (/* binding */ MemoryBlockstore)\n/* harmony export */ });\n/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base32 */ \"./node_modules/multiformats/dist/src/bases/base32.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"./node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/codecs/raw */ \"./node_modules/multiformats/dist/src/codecs/raw.js\");\n/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/digest */ \"./node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n\n\n\n\n\n\nclass MemoryBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseBlockstore {\n    data;\n    constructor() {\n        super();\n        this.data = new Map();\n    }\n    put(key, val) {\n        this.data.set(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes), val);\n        return key;\n    }\n    get(key) {\n        const buf = this.data.get(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes));\n        if (buf == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.notFoundError();\n        }\n        return buf;\n    }\n    has(key) {\n        return this.data.has(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes));\n    }\n    async delete(key) {\n        this.data.delete(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.encode(key.multihash.bytes));\n    }\n    async *getAll() {\n        for (const [key, value] of this.data.entries()) {\n            yield {\n                cid: multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.createV1(multiformats_codecs_raw__WEBPACK_IMPORTED_MODULE_2__.code, multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_3__.decode(multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_0__.base32.decode(key))),\n                block: value\n            };\n        }\n    }\n}\n//# sourceMappingURL=memory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/memory.js?");

/***/ }),

/***/ "./node_modules/blockstore-core/dist/src/tiered.js":
/*!*********************************************************!*\
  !*** ./node_modules/blockstore-core/dist/src/tiered.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TieredBlockstore: () => (/* binding */ TieredBlockstore)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"./node_modules/blockstore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/blockstore-core/dist/src/errors.js\");\n\n\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_6__.logger)('blockstore:core:tiered');\n/**\n * A blockstore that can combine multiple stores. Puts and deletes\n * will write through to all blockstores. Has and get will\n * try each store sequentially. getAll will use every store but also\n * deduplicate any yielded pairs.\n */\nclass TieredBlockstore extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseBlockstore {\n    stores;\n    constructor(stores) {\n        super();\n        this.stores = stores.slice();\n    }\n    async put(key, value, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.put(key, value, options); }));\n            return key;\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.putFailedError(err);\n        }\n    }\n    async get(key, options) {\n        for (const store of this.stores) {\n            try {\n                const res = await store.get(key, options);\n                if (res != null)\n                    return res;\n            }\n            catch (err) {\n                log.error(err);\n            }\n        }\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.notFoundError();\n    }\n    async has(key, options) {\n        for (const s of this.stores) {\n            if (await s.has(key, options)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async delete(key, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.delete(key, options); }));\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.deleteFailedError(err);\n        }\n    }\n    async *putMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_3__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.putMany(source, options))\n                .catch(err => {\n                // store threw while putting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const pair of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(pair));\n                yield pair.cid;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_3__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.deleteMany(source, options))\n                .catch(err => {\n                // store threw while deleting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const key of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(key));\n                yield key;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    async *getAll(options) {\n        // deduplicate yielded pairs\n        const seen = new Set();\n        yield* (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((0,it_merge__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(...this.stores.map(s => s.getAll(options))), (pair) => {\n            const cidStr = pair.cid.toString();\n            if (seen.has(cidStr)) {\n                return false;\n            }\n            seen.add(cidStr);\n            return true;\n        });\n    }\n}\n//# sourceMappingURL=tiered.js.map\n\n//# sourceURL=webpack://ems/./node_modules/blockstore-core/dist/src/tiered.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/base.js":
/*!******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/base.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDatastore: () => (/* binding */ BaseDatastore)\n/* harmony export */ });\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-sort */ \"./node_modules/it-sort/dist/src/index.js\");\n/* harmony import */ var it_take__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-take */ \"./node_modules/it-take/dist/src/index.js\");\n\n\n\n\nclass BaseDatastore {\n    put(key, val, options) {\n        return Promise.reject(new Error('.put is not implemented'));\n    }\n    get(key, options) {\n        return Promise.reject(new Error('.get is not implemented'));\n    }\n    has(key, options) {\n        return Promise.reject(new Error('.has is not implemented'));\n    }\n    delete(key, options) {\n        return Promise.reject(new Error('.delete is not implemented'));\n    }\n    async *putMany(source, options = {}) {\n        for await (const { key, value } of source) {\n            await this.put(key, value, options);\n            yield key;\n        }\n    }\n    async *getMany(source, options = {}) {\n        for await (const key of source) {\n            yield {\n                key,\n                value: await this.get(key, options)\n            };\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        for await (const key of source) {\n            await this.delete(key, options);\n            yield key;\n        }\n    }\n    batch() {\n        let puts = [];\n        let dels = [];\n        return {\n            put(key, value) {\n                puts.push({ key, value });\n            },\n            delete(key) {\n                dels.push(key);\n            },\n            commit: async (options) => {\n                await (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.putMany(puts, options));\n                puts = [];\n                await (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.deleteMany(dels, options));\n                dels = [];\n            }\n        };\n    }\n    /**\n     * Extending classes should override `query` or implement this method\n     */\n    // eslint-disable-next-line require-yield\n    async *_all(q, options) {\n        throw new Error('._all is not implemented');\n    }\n    /**\n     * Extending classes should override `queryKeys` or implement this method\n     */\n    // eslint-disable-next-line require-yield\n    async *_allKeys(q, options) {\n        throw new Error('._allKeys is not implemented');\n    }\n    query(q, options) {\n        let it = this._all(q, options);\n        if (q.prefix != null) {\n            const prefix = q.prefix;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, (e) => e.key.toString().startsWith(prefix));\n        }\n        if (Array.isArray(q.filters)) {\n            it = q.filters.reduce((it, f) => (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, f), it);\n        }\n        if (Array.isArray(q.orders)) {\n            it = q.orders.reduce((it, f) => (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, f), it);\n        }\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null) {\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        }\n        return it;\n    }\n    queryKeys(q, options) {\n        let it = this._allKeys(q, options);\n        if (q.prefix != null) {\n            const prefix = q.prefix;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, (key) => key.toString().startsWith(prefix));\n        }\n        if (Array.isArray(q.filters)) {\n            it = q.filters.reduce((it, f) => (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, f), it);\n        }\n        if (Array.isArray(q.orders)) {\n            it = q.orders.reduce((it, f) => (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, f), it);\n        }\n        if (q.offset != null) {\n            const offset = q.offset;\n            let i = 0;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null) {\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        }\n        return it;\n    }\n}\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/base.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abortedError: () => (/* binding */ abortedError),\n/* harmony export */   dbDeleteFailedError: () => (/* binding */ dbDeleteFailedError),\n/* harmony export */   dbOpenFailedError: () => (/* binding */ dbOpenFailedError),\n/* harmony export */   dbReadFailedError: () => (/* binding */ dbReadFailedError),\n/* harmony export */   dbWriteFailedError: () => (/* binding */ dbWriteFailedError),\n/* harmony export */   notFoundError: () => (/* binding */ notFoundError)\n/* harmony export */ });\n/* harmony import */ var err_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! err-code */ \"./node_modules/err-code/index.js\");\n\nfunction dbOpenFailedError(err) {\n    err = err ?? new Error('Cannot open database');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_OPEN_FAILED');\n}\nfunction dbDeleteFailedError(err) {\n    err = err ?? new Error('Delete failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_DELETE_FAILED');\n}\nfunction dbWriteFailedError(err) {\n    err = err ?? new Error('Write failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_WRITE_FAILED');\n}\nfunction dbReadFailedError(err) {\n    err = err ?? new Error('Read failed');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_DB_READ_FAILED');\n}\nfunction notFoundError(err) {\n    err = err ?? new Error('Not Found');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_NOT_FOUND');\n}\nfunction abortedError(err) {\n    err = err ?? new Error('Aborted');\n    return err_code__WEBPACK_IMPORTED_MODULE_0__(err, 'ERR_ABORTED');\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/errors.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDatastore: () => (/* reexport safe */ _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseDatastore),\n/* harmony export */   Errors: () => (/* reexport module object */ _errors_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   KeyTransformDatastore: () => (/* reexport safe */ _keytransform_js__WEBPACK_IMPORTED_MODULE_4__.KeyTransformDatastore),\n/* harmony export */   MemoryDatastore: () => (/* reexport safe */ _memory_js__WEBPACK_IMPORTED_MODULE_3__.MemoryDatastore),\n/* harmony export */   MountDatastore: () => (/* reexport safe */ _mount_js__WEBPACK_IMPORTED_MODULE_6__.MountDatastore),\n/* harmony export */   NamespaceDatastore: () => (/* reexport safe */ _namespace_js__WEBPACK_IMPORTED_MODULE_8__.NamespaceDatastore),\n/* harmony export */   ShardingDatastore: () => (/* reexport safe */ _sharding_js__WEBPACK_IMPORTED_MODULE_5__.ShardingDatastore),\n/* harmony export */   TieredDatastore: () => (/* reexport safe */ _tiered_js__WEBPACK_IMPORTED_MODULE_7__.TieredDatastore),\n/* harmony export */   shard: () => (/* reexport module object */ _shard_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n/* harmony import */ var _shard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shard.js */ \"./node_modules/datastore-core/dist/src/shard.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _memory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./memory.js */ \"./node_modules/datastore-core/dist/src/memory.js\");\n/* harmony import */ var _keytransform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keytransform.js */ \"./node_modules/datastore-core/dist/src/keytransform.js\");\n/* harmony import */ var _sharding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sharding.js */ \"./node_modules/datastore-core/dist/src/sharding.js\");\n/* harmony import */ var _mount_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mount.js */ \"./node_modules/datastore-core/dist/src/mount.js\");\n/* harmony import */ var _tiered_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tiered.js */ \"./node_modules/datastore-core/dist/src/tiered.js\");\n/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./namespace.js */ \"./node_modules/datastore-core/dist/src/namespace.js\");\n/**\n * @packageDocumentation\n *\n * Various Datastore implementations are available.\n *\n * ## Implementations\n *\n * - Mount: [`src/mount`](src/mount.ts)\n * - Keytransform: [`src/keytransform`](src/keytransform.ts)\n * - Sharding: [`src/sharding`](src/sharding.ts)\n * - Tiered: [`src/tiered`](src/tirered.ts)\n * - Namespace: [`src/namespace`](src/namespace.ts)\n * - BlackHole: [`src/black-hole`](src/black-hole.ts)\n *\n * @example BaseDatastore\n *\n * An base store is made available to make implementing your own datastore easier:\n *\n * ```javascript\n * import { BaseDatastore } from 'datastore-core'\n *\n * class MyDatastore extends BaseDatastore {\n *   constructor () {\n *     super()\n *   }\n *\n *   async put (key, val) {\n *     // your implementation here\n *   }\n *\n *   async get (key) {\n *     // your implementation here\n *   }\n *\n *   // etc...\n * }\n * ```\n *\n * See the [MemoryDatastore](./src/memory.js) for an example of how it is used.\n *\n * @example Wrapping Stores\n *\n * ```js\n * import { Key } from 'interface-datastore'\n * import {\n *   MemoryStore,\n *   MountStore\n * } from 'datastore-core'\n *\n * const store = new MountStore({prefix: new Key('/a'), datastore: new MemoryStore()})\n * ```\n *\n * @example BlackHoleDatastore\n *\n * A datastore that does not store any data.\n *\n * ```js\n * import { BlackHoleDatastore } from 'datastore-core/black-hole'\n *\n * const store = new BlackHoleDatastore()\n * ```\n */\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/keytransform.js":
/*!**************************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/keytransform.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyTransformDatastore: () => (/* binding */ KeyTransformDatastore)\n/* harmony export */ });\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-pipe */ \"./node_modules/it-pipe/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n\n\n\n/**\n * A datastore shim, that wraps around a given datastore, changing\n * the way keys look to the user, for example namespacing\n * keys, reversing them, etc.\n */\nclass KeyTransformDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseDatastore {\n    child;\n    transform;\n    constructor(child, transform) {\n        super();\n        this.child = child;\n        this.transform = transform;\n    }\n    async put(key, val, options) {\n        await this.child.put(this.transform.convert(key), val, options);\n        return key;\n    }\n    async get(key, options) {\n        return this.child.get(this.transform.convert(key), options);\n    }\n    async has(key, options) {\n        return this.child.has(this.transform.convert(key), options);\n    }\n    async delete(key, options) {\n        await this.child.delete(this.transform.convert(key), options);\n    }\n    async *putMany(source, options = {}) {\n        const transform = this.transform;\n        const child = this.child;\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_1__.pipe)(source, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, ({ key, value }) => ({\n                key: transform.convert(key),\n                value\n            }));\n        }, async function* (source) {\n            yield* child.putMany(source, options);\n        }, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.invert(key));\n        });\n    }\n    async *getMany(source, options = {}) {\n        const transform = this.transform;\n        const child = this.child;\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_1__.pipe)(source, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.convert(key));\n        }, async function* (source) {\n            yield* child.getMany(source, options);\n        }, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, ({ key, value }) => ({\n                key: transform.invert(key),\n                value\n            }));\n        });\n    }\n    async *deleteMany(source, options = {}) {\n        const transform = this.transform;\n        const child = this.child;\n        yield* (0,it_pipe__WEBPACK_IMPORTED_MODULE_1__.pipe)(source, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.convert(key));\n        }, async function* (source) {\n            yield* child.deleteMany(source, options);\n        }, async function* (source) {\n            yield* (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, key => transform.invert(key));\n        });\n    }\n    batch() {\n        const b = this.child.batch();\n        return {\n            put: (key, value) => {\n                b.put(this.transform.convert(key), value);\n            },\n            delete: (key) => {\n                b.delete(this.transform.convert(key));\n            },\n            commit: async (options) => {\n                await b.commit(options);\n            }\n        };\n    }\n    query(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return ({ key, value }) => filter({ key: this.transform.convert(key), value });\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push(({ key }) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order({ key: this.transform.invert(a.key), value: a.value }, { key: this.transform.invert(b.key), value: b.value });\n            });\n        }\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.child.query(query, options), ({ key, value }) => {\n            return {\n                key: this.transform.invert(key),\n                value\n            };\n        });\n    }\n    queryKeys(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return (key) => filter(this.transform.convert(key));\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push((key) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order(this.transform.invert(a), this.transform.invert(b));\n            });\n        }\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.child.queryKeys(query, options), key => {\n            return this.transform.invert(key);\n        });\n    }\n}\n//# sourceMappingURL=keytransform.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/keytransform.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/memory.js":
/*!********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/memory.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryDatastore: () => (/* binding */ MemoryDatastore)\n/* harmony export */ });\n/* harmony import */ var interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore/key */ \"./node_modules/interface-datastore/dist/src/key.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n\n\n\nclass MemoryDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseDatastore {\n    data;\n    constructor() {\n        super();\n        this.data = new Map();\n    }\n    put(key, val) {\n        this.data.set(key.toString(), val);\n        return key;\n    }\n    get(key) {\n        const result = this.data.get(key.toString());\n        if (result == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.notFoundError();\n        }\n        return result;\n    }\n    has(key) {\n        return this.data.has(key.toString());\n    }\n    delete(key) {\n        this.data.delete(key.toString());\n    }\n    *_all() {\n        for (const [key, value] of this.data.entries()) {\n            yield { key: new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(key), value };\n        }\n    }\n    *_allKeys() {\n        for (const key of this.data.keys()) {\n            yield new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(key);\n        }\n    }\n}\n//# sourceMappingURL=memory.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/memory.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/mount.js":
/*!*******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/mount.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MountDatastore: () => (/* binding */ MountDatastore)\n/* harmony export */ });\n/* harmony import */ var it_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-filter */ \"./node_modules/it-filter/dist/src/index.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n/* harmony import */ var it_sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! it-sort */ \"./node_modules/it-sort/dist/src/index.js\");\n/* harmony import */ var it_take__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! it-take */ \"./node_modules/it-take/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n\n\n\n\n\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n */\nclass MountDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_4__.BaseDatastore {\n    mounts;\n    constructor(mounts) {\n        super();\n        this.mounts = mounts.slice();\n    }\n    /**\n     * Lookup the matching datastore for the given key\n     */\n    _lookup(key) {\n        for (const mount of this.mounts) {\n            if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n                return {\n                    datastore: mount.datastore,\n                    mountpoint: mount.prefix\n                };\n            }\n        }\n    }\n    async put(key, value, options) {\n        const match = this._lookup(key);\n        if (match == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.dbWriteFailedError(new Error('No datastore mounted for this key'));\n        }\n        await match.datastore.put(key, value, options);\n        return key;\n    }\n    /**\n     * @param {Key} key\n     * @param {Options} [options]\n     */\n    async get(key, options = {}) {\n        const match = this._lookup(key);\n        if (match == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.notFoundError(new Error('No datastore mounted for this key'));\n        }\n        return match.datastore.get(key, options);\n    }\n    async has(key, options) {\n        const match = this._lookup(key);\n        if (match == null) {\n            return Promise.resolve(false);\n        }\n        return match.datastore.has(key, options);\n    }\n    async delete(key, options) {\n        const match = this._lookup(key);\n        if (match == null) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_5__.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n        }\n        await match.datastore.delete(key, options);\n    }\n    batch() {\n        const batchMounts = {};\n        const lookup = (key) => {\n            const match = this._lookup(key);\n            if (match == null) {\n                throw new Error('No datastore mounted for this key');\n            }\n            const m = match.mountpoint.toString();\n            if (batchMounts[m] == null) {\n                batchMounts[m] = match.datastore.batch();\n            }\n            return {\n                batch: batchMounts[m]\n            };\n        };\n        return {\n            put: (key, value) => {\n                const match = lookup(key);\n                match.batch.put(key, value);\n            },\n            delete: (key) => {\n                const match = lookup(key);\n                match.batch.delete(key);\n            },\n            commit: async (options) => {\n                await Promise.all(Object.keys(batchMounts).map(async (p) => { await batchMounts[p].commit(options); }));\n            }\n        };\n    }\n    query(q, options) {\n        const qs = this.mounts.map(m => {\n            return m.datastore.query({\n                prefix: q.prefix,\n                filters: q.filters\n            }, options);\n        });\n        let it = (0,it_merge__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(...qs);\n        if (q.filters != null)\n            q.filters.forEach(f => { it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, f); });\n        if (q.orders != null)\n            q.orders.forEach(o => { it = (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, o); });\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null)\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        return it;\n    }\n    queryKeys(q, options) {\n        const qs = this.mounts.map(m => {\n            return m.datastore.queryKeys({\n                prefix: q.prefix,\n                filters: q.filters\n            }, options);\n        });\n        /** @type AsyncIterable<Key> */\n        let it = (0,it_merge__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(...qs);\n        if (q.filters != null)\n            q.filters.forEach(f => { it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, f); });\n        if (q.orders != null)\n            q.orders.forEach(o => { it = (0,it_sort__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(it, o); });\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = (0,it_filter__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(it, () => i++ >= offset);\n        }\n        if (q.limit != null)\n            it = (0,it_take__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(it, q.limit);\n        return it;\n    }\n}\n//# sourceMappingURL=mount.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/mount.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/namespace.js":
/*!***********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/namespace.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NamespaceDatastore: () => (/* binding */ NamespaceDatastore)\n/* harmony export */ });\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var it_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-map */ \"./node_modules/it-map/dist/src/index.js\");\n/* harmony import */ var _keytransform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keytransform.js */ \"./node_modules/datastore-core/dist/src/keytransform.js\");\n\n\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n */\nclass NamespaceDatastore extends _keytransform_js__WEBPACK_IMPORTED_MODULE_2__.KeyTransformDatastore {\n    iChild;\n    iKey;\n    constructor(child, prefix) {\n        super(child, {\n            convert(key) {\n                return prefix.child(key);\n            },\n            invert(key) {\n                if (prefix.toString() === '/') {\n                    return key;\n                }\n                if (!prefix.isAncestorOf(key)) {\n                    throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);\n                }\n                return new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key(key.toString().slice(prefix.toString().length), false);\n            }\n        });\n        this.iChild = child;\n        this.iKey = prefix;\n    }\n    query(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return ({ key, value }) => filter({ key: this.transform.invert(key), value });\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push(({ key }) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order({ key: this.transform.invert(a.key), value: a.value }, { key: this.transform.invert(b.key), value: b.value });\n            });\n        }\n        query.filters.unshift(({ key }) => this.iKey.isAncestorOf(key));\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.iChild.query(query, options), ({ key, value }) => {\n            return {\n                key: this.transform.invert(key),\n                value\n            };\n        });\n    }\n    queryKeys(q, options) {\n        const query = {\n            ...q\n        };\n        query.filters = (query.filters ?? []).map(filter => {\n            return (key) => filter(this.transform.invert(key));\n        });\n        const { prefix } = q;\n        if (prefix != null && prefix !== '/') {\n            delete query.prefix;\n            query.filters.push((key) => {\n                return this.transform.invert(key).toString().startsWith(prefix);\n            });\n        }\n        if (query.orders != null) {\n            query.orders = query.orders.map(order => {\n                return (a, b) => order(this.transform.invert(a), this.transform.invert(b));\n            });\n        }\n        query.filters.unshift(key => this.iKey.isAncestorOf(key));\n        return (0,it_map__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.iChild.queryKeys(query, options), key => {\n            return this.transform.invert(key);\n        });\n    }\n}\n//# sourceMappingURL=namespace.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/namespace.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/shard.js":
/*!*******************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/shard.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NextToLast: () => (/* binding */ NextToLast),\n/* harmony export */   PREFIX: () => (/* binding */ PREFIX),\n/* harmony export */   Prefix: () => (/* binding */ Prefix),\n/* harmony export */   SHARDING_FN: () => (/* binding */ SHARDING_FN),\n/* harmony export */   ShardBase: () => (/* binding */ ShardBase),\n/* harmony export */   Suffix: () => (/* binding */ Suffix),\n/* harmony export */   parseShardFun: () => (/* binding */ parseShardFun),\n/* harmony export */   readShardFun: () => (/* binding */ readShardFun)\n/* harmony export */ });\n/* harmony import */ var interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore/key */ \"./node_modules/interface-datastore/dist/src/key.js\");\n\nconst PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = 'SHARDING';\nclass ShardBase {\n    param;\n    name;\n    _padding;\n    constructor(param) {\n        this.param = param;\n        this.name = 'base';\n        this._padding = '';\n    }\n    fun(s) {\n        return 'implement me';\n    }\n    toString() {\n        return `${PREFIX}v1/${this.name}/${this.param}`;\n    }\n}\nclass Prefix extends ShardBase {\n    constructor(prefixLen) {\n        super(prefixLen);\n        this._padding = ''.padStart(prefixLen, '_');\n        this.name = 'prefix';\n    }\n    fun(noslash) {\n        return (noslash + this._padding).slice(0, this.param);\n    }\n}\nclass Suffix extends ShardBase {\n    constructor(suffixLen) {\n        super(suffixLen);\n        this._padding = ''.padStart(suffixLen, '_');\n        this.name = 'suffix';\n    }\n    fun(noslash) {\n        const s = this._padding + noslash;\n        return s.slice(s.length - this.param);\n    }\n}\nclass NextToLast extends ShardBase {\n    constructor(suffixLen) {\n        super(suffixLen);\n        this._padding = ''.padStart(suffixLen + 1, '_');\n        this.name = 'next-to-last';\n    }\n    fun(noslash) {\n        const s = this._padding + noslash;\n        const offset = s.length - this.param - 1;\n        return s.slice(offset, offset + this.param);\n    }\n}\n/**\n * Convert a given string to the matching sharding function\n */\nfunction parseShardFun(str) {\n    str = str.trim();\n    if (str.length === 0) {\n        throw new Error('empty shard string');\n    }\n    if (!str.startsWith(PREFIX)) {\n        throw new Error(`invalid or no path prefix: ${str}`);\n    }\n    const parts = str.slice(PREFIX.length).split('/');\n    const version = parts[0];\n    if (version !== 'v1') {\n        throw new Error(`expect 'v1' version, got '${version}'`);\n    }\n    const name = parts[1];\n    if (parts[2] == null || parts[2] === '') {\n        throw new Error('missing param');\n    }\n    const param = parseInt(parts[2], 10);\n    switch (name) {\n        case 'prefix':\n            return new Prefix(param);\n        case 'suffix':\n            return new Suffix(param);\n        case 'next-to-last':\n            return new NextToLast(param);\n        default:\n            throw new Error(`unkown sharding function: ${name}`);\n    }\n}\nconst readShardFun = async (path, store) => {\n    const key = new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(path).child(new interface_datastore_key__WEBPACK_IMPORTED_MODULE_0__.Key(SHARDING_FN));\n    // @ts-expect-error not all stores have this\n    const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n    const res = await get(key);\n    return parseShardFun(new TextDecoder().decode(res ?? '').trim());\n};\n//# sourceMappingURL=shard.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/shard.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/sharding.js":
/*!**********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/sharding.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShardingDatastore: () => (/* binding */ ShardingDatastore)\n/* harmony export */ });\n/* harmony import */ var interface_datastore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! interface-datastore */ \"./node_modules/interface-datastore/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n/* harmony import */ var _keytransform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keytransform.js */ \"./node_modules/datastore-core/dist/src/keytransform.js\");\n/* harmony import */ var _shard_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shard.js */ \"./node_modules/datastore-core/dist/src/shard.js\");\n\n\n\n\n\nconst shardKey = new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key(_shard_js__WEBPACK_IMPORTED_MODULE_4__.SHARDING_FN);\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseDatastore {\n    child;\n    shard;\n    constructor(store, shard) {\n        super();\n        this.child = new _keytransform_js__WEBPACK_IMPORTED_MODULE_3__.KeyTransformDatastore(store, {\n            convert: this._convertKey.bind(this),\n            invert: this._invertKey.bind(this)\n        });\n        this.shard = shard;\n    }\n    async open() {\n        this.shard = await ShardingDatastore.create(this.child, this.shard);\n    }\n    _convertKey(key) {\n        const s = key.toString();\n        if (s === shardKey.toString()) {\n            return key;\n        }\n        const parent = new interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key(this.shard.fun(s));\n        return parent.child(key);\n    }\n    _invertKey(key) {\n        const s = key.toString();\n        if (s === shardKey.toString()) {\n            return key;\n        }\n        return interface_datastore__WEBPACK_IMPORTED_MODULE_0__.Key.withNamespaces(key.list().slice(1));\n    }\n    static async create(store, shard) {\n        const hasShard = await store.has(shardKey);\n        if (!hasShard) {\n            if (shard == null) {\n                throw _errors_js__WEBPACK_IMPORTED_MODULE_2__.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n            }\n            await store.put(shardKey, new TextEncoder().encode(shard.toString() + '\\n'));\n        }\n        if (shard == null) {\n            shard = await (0,_shard_js__WEBPACK_IMPORTED_MODULE_4__.readShardFun)('/', store);\n        }\n        // test shards\n        const diskShard = await (0,_shard_js__WEBPACK_IMPORTED_MODULE_4__.readShardFun)('/', store);\n        const a = diskShard.toString();\n        const b = shard.toString();\n        if (a !== b) {\n            throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n        }\n        return diskShard;\n    }\n    async put(key, val, options) {\n        await this.child.put(key, val, options);\n        return key;\n    }\n    async get(key, options) {\n        return this.child.get(key, options);\n    }\n    async has(key, options) {\n        return this.child.has(key, options);\n    }\n    async delete(key, options) {\n        await this.child.delete(key, options);\n    }\n    async *putMany(source, options = {}) {\n        yield* this.child.putMany(source, options);\n    }\n    async *getMany(source, options = {}) {\n        yield* this.child.getMany(source, options);\n    }\n    async *deleteMany(source, options = {}) {\n        yield* this.child.deleteMany(source, options);\n    }\n    batch() {\n        return this.child.batch();\n    }\n    query(q, options) {\n        const omitShard = ({ key }) => key.toString() !== shardKey.toString();\n        const tq = {\n            ...q,\n            filters: [\n                omitShard\n            ].concat(q.filters ?? [])\n        };\n        return this.child.query(tq, options);\n    }\n    queryKeys(q, options) {\n        const omitShard = (key) => key.toString() !== shardKey.toString();\n        const tq = {\n            ...q,\n            filters: [\n                omitShard\n            ].concat(q.filters ?? [])\n        };\n        return this.child.queryKeys(tq, options);\n    }\n}\n//# sourceMappingURL=sharding.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/sharding.js?");

/***/ }),

/***/ "./node_modules/datastore-core/dist/src/tiered.js":
/*!********************************************************!*\
  !*** ./node_modules/datastore-core/dist/src/tiered.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TieredDatastore: () => (/* binding */ TieredDatastore)\n/* harmony export */ });\n/* harmony import */ var _libp2p_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @libp2p/logger */ \"./node_modules/@libp2p/logger/dist/src/index.js\");\n/* harmony import */ var it_drain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-drain */ \"./node_modules/it-drain/dist/src/index.js\");\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base.js */ \"./node_modules/datastore-core/dist/src/base.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/datastore-core/dist/src/errors.js\");\n\n\n\n\n\nconst log = (0,_libp2p_logger__WEBPACK_IMPORTED_MODULE_4__.logger)('datastore:core:tiered');\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore extends _base_js__WEBPACK_IMPORTED_MODULE_2__.BaseDatastore {\n    stores;\n    constructor(stores) {\n        super();\n        this.stores = stores.slice();\n    }\n    async put(key, value, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.put(key, value, options); }));\n            return key;\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.dbWriteFailedError(err);\n        }\n    }\n    async get(key, options) {\n        for (const store of this.stores) {\n            try {\n                const res = await store.get(key, options);\n                if (res != null)\n                    return res;\n            }\n            catch (err) {\n                log.error(err);\n            }\n        }\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.notFoundError();\n    }\n    async has(key, options) {\n        for (const s of this.stores) {\n            if (await s.has(key, options)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async delete(key, options) {\n        try {\n            await Promise.all(this.stores.map(async (store) => { await store.delete(key, options); }));\n        }\n        catch (err) {\n            throw _errors_js__WEBPACK_IMPORTED_MODULE_3__.dbDeleteFailedError(err);\n        }\n    }\n    async *putMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_1__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.putMany(source, options))\n                .catch(err => {\n                // store threw while putting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const pair of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(pair));\n                yield pair.key;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        let error;\n        const pushables = this.stores.map(store => {\n            const source = (0,it_pushable__WEBPACK_IMPORTED_MODULE_1__.pushable)({\n                objectMode: true\n            });\n            (0,it_drain__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(store.deleteMany(source, options))\n                .catch(err => {\n                // store threw while deleting, make sure we bubble the error up\n                error = err;\n            });\n            return source;\n        });\n        try {\n            for await (const key of source) {\n                if (error != null) {\n                    throw error;\n                }\n                pushables.forEach(p => p.push(key));\n                yield key;\n            }\n        }\n        finally {\n            pushables.forEach(p => p.end());\n        }\n    }\n    batch() {\n        const batches = this.stores.map(store => store.batch());\n        return {\n            put: (key, value) => {\n                batches.forEach(b => { b.put(key, value); });\n            },\n            delete: (key) => {\n                batches.forEach(b => { b.delete(key); });\n            },\n            commit: async (options) => {\n                for (const batch of batches) {\n                    await batch.commit(options);\n                }\n            }\n        };\n    }\n    query(q, options) {\n        return this.stores[this.stores.length - 1].query(q, options);\n    }\n    queryKeys(q, options) {\n        return this.stores[this.stores.length - 1].queryKeys(q, options);\n    }\n}\n//# sourceMappingURL=tiered.js.map\n\n//# sourceURL=webpack://ems/./node_modules/datastore-core/dist/src/tiered.js?");

/***/ }),

/***/ "./node_modules/interface-datastore/dist/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/interface-datastore/dist/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Key: () => (/* reexport safe */ _key_js__WEBPACK_IMPORTED_MODULE_0__.Key)\n/* harmony export */ });\n/* harmony import */ var _key_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./key.js */ \"./node_modules/interface-datastore/dist/src/key.js\");\n/* eslint-disable @typescript-eslint/ban-types */\n// this ignore is so we can use {} as the default value for the options\n// extensions below - it normally means \"any non-nullish value\" but here\n// we are using it as an intersection type - see the aside at the bottom:\n// https://github.com/typescript-eslint/typescript-eslint/issues/2063#issuecomment-675156492\n/**\n * @packageDocumentation\n *\n * A Datastore is a key/value database that lets store/retrieve binary blobs using namespaced Keys.\n *\n * It is used by IPFS to store/retrieve arbitrary metadata needed to run the node - DHT provider records, signed peer records, etc.\n *\n * ## Backed Implementations\n *\n * - File System: [`datastore-fs`](https://github.com/ipfs/js-stores/tree/main/packages/datastore-fs)\n * - IndexedDB: [`datastore-idb`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-idb)\n * - level: [`datastore-level`](https://github.com/ipfs/js-stores/tree/main/packages/datastore-level) (supports any levelup compatible backend)\n * - Memory: [`datastore-core/memory`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/memory.ts)\n * - S3: [`datastore-s3`](https://github.com/ipfs/js-stores/tree/main/packages/datastore-s3)\n *\n * ## Wrapper Implementations\n *\n * - Keytransform: [`datstore-core/src/keytransform`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/keytransform.ts)\n * - Mount: [`datastore-core/src/mount`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/mount.ts)\n * - Namespace: [`datastore-core/src/namespace`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/namespace.ts)\n * - Sharding: [`datastore-core/src/sharding`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/sharding.ts)\n * - Tiered: [`datstore-core/src/tiered`](https://github.com/ipfs/js-stores/blob/main/packages/datastore-core/src/tiered.ts)\n *\n * If you want the same functionality as [go-ds-flatfs](https://github.com/ipfs/go-ds-flatfs), use sharding with fs.\n *\n * @example\n *\n * ```js\n * import FsStore from 'datastore-fs'\n * import { ShardingDataStore, shard } from 'datastore-core'\n *\n * const fs = new FsStore('path/to/store')\n *\n * // flatfs now works like go-flatfs\n * const flatfs = await ShardingStore.createOrOpen(fs, new shard.NextToLast(2))\n * ```\n *\n * ### Test suite\n *\n * Available via the [`interface-datastore-tests`](https://npmjs.com/package/interface-datastore-tests) module\n *\n * ```js\n * import { interfaceDatastoreTests } from 'interface-datastore-tests'\n *\n * describe('mystore', () => {\n *   interfaceDatastoreTests({\n *     async setup () {\n *       return instanceOfMyStore\n *     },\n *     async teardown () {\n *       // cleanup resources\n *     }\n *   })\n * })\n * ```\n *\n * ### Aborting requests\n *\n * Most API methods accept an \\[AbortSignal]\\[] as part of an options object.  Implementations may listen for an `abort` event emitted by this object, or test the `signal.aborted` property. When received implementations should tear down any long-lived requests or resources created.\n *\n * ### Concurrency\n *\n * The streaming `(put|get|delete)Many` methods are intended to be used with modules such as [it-parallel-batch](https://www.npmjs.com/package/it-parallel-batch) to allow calling code to control levels of parallelisation.  The batching method ensures results are returned in the correct order, but interface implementations should be thread safe.\n *\n * ```js\n * import batch from 'it-parallel-batch'\n * const source = [{\n *   key: ..,\n *   value: ..\n * }]\n *\n * // put values into the datastore concurrently, max 10 at a time\n * for await (const { key, data } of batch(store.putMany(source), 10)) {\n *   console.info(`Put ${key}`)\n * }\n * ```\n *\n * ### Keys\n *\n * To allow a better abstraction on how to address values, there is a `Key` class which is used as identifier. It's easy to create a key from a `Uint8Array` or a `string`.\n *\n * ```js\n * const a = new Key('a')\n * const b = new Key(new Uint8Array([0, 1, 2, 3]))\n * ```\n *\n * The key scheme is inspired by file systems and Google App Engine key model. Keys are meant to be unique across a system. They are typically hierarchical, incorporating more and more specific namespaces. Thus keys can be deemed 'children' or 'ancestors' of other keys:\n *\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n *\n * Also, every namespace can be parameterized to embed relevant object information. For example, the Key `name` (most specific namespace) could include the object type:\n *\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n */\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/interface-datastore/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/interface-datastore/dist/src/key.js":
/*!**********************************************************!*\
  !*** ./node_modules/interface-datastore/dist/src/key.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Key: () => (/* binding */ Key)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/from-string */ \"./node_modules/uint8arrays/dist/src/from-string.js\");\n/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ \"./node_modules/uint8arrays/dist/src/to-string.js\");\n\n\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nclass Key {\n    _buf;\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */\n    constructor(s, clean) {\n        if (typeof s === 'string') {\n            this._buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_0__.fromString)(s);\n        }\n        else if (s instanceof Uint8Array) {\n            this._buf = s;\n        }\n        else {\n            throw new Error('Invalid key, should be String of Uint8Array');\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error('Invalid key');\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */\n    toString(encoding = 'utf8') {\n        return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */\n    uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */\n    static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/344502982398')\n     * ```\n     */\n    static random() {\n        return new Key(Math.random().toString().substring(2));\n    }\n    /**\n     * @param {*} other\n     */\n    static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === 'string') {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === 'function') {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */\n    less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for (let i = 0; i < list1.length; i++) {\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            }\n            else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */\n    reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n    namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */\n    baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */\n    list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */\n    type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */\n    name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    instance(s) {\n        return new Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */\n    path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */\n    parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        }\n        else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */\n    isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */\n    isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */\n    isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */\n    concat(...keys) {\n        return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType(ns) {\n    const parts = ns.split(':');\n    if (parts.length < 2) {\n        return '';\n    }\n    return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue(ns) {\n    const parts = ns.split(':');\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten(arr) {\n    return ([]).concat(...arr);\n}\n//# sourceMappingURL=key.js.map\n\n//# sourceURL=webpack://ems/./node_modules/interface-datastore/dist/src/key.js?");

/***/ }),

/***/ "./node_modules/it-sort/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/it-sort/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var it_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-all */ \"./node_modules/it-all/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction sort(source, sorter) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            const arr = await (0,it_all__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source);\n            yield* arr.sort(sorter);\n        })();\n    }\n    return (function* () {\n        const arr = (0,it_all__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source);\n        yield* arr.sort(sorter);\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sort);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-sort/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/mortice/dist/src/browser.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var observable_webworkers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! observable-webworkers */ \"./node_modules/observable-webworkers/dist/src/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/mortice/dist/src/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/mortice/dist/src/utils.js\");\n\n\n\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n    return (worker, event) => {\n        if (event.data.type !== requestType) {\n            return;\n        }\n        const requestEvent = {\n            type: event.data.type,\n            name: event.data.name,\n            identifier: event.data.identifier\n        };\n        emitter.dispatchEvent(new MessageEvent(masterEvent, {\n            data: {\n                name: requestEvent.name,\n                handler: async () => {\n                    // grant lock to worker\n                    worker.postMessage({\n                        type: grantType,\n                        name: requestEvent.name,\n                        identifier: requestEvent.identifier\n                    });\n                    // wait for worker to finish\n                    await new Promise((resolve) => {\n                        const releaseEventListener = (event) => {\n                            if (event == null || event.data == null) {\n                                return;\n                            }\n                            const releaseEvent = {\n                                type: event.data.type,\n                                name: event.data.name,\n                                identifier: event.data.identifier\n                            };\n                            if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                                worker.removeEventListener('message', releaseEventListener);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener('message', releaseEventListener);\n                    });\n                }\n            }\n        }));\n    };\n};\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n    return async () => {\n        const id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.nanoid)();\n        globalThis.postMessage({\n            type: requestType,\n            identifier: id,\n            name\n        });\n        return new Promise((resolve) => {\n            const listener = (event) => {\n                if (event == null || event.data == null) {\n                    return;\n                }\n                const responseEvent = {\n                    type: event.data.type,\n                    identifier: event.data.identifier\n                };\n                if (responseEvent.type === grantType && responseEvent.identifier === id) {\n                    globalThis.removeEventListener('message', listener);\n                    // grant lock\n                    resolve(() => {\n                        // release lock\n                        globalThis.postMessage({\n                            type: releaseType,\n                            identifier: id,\n                            name\n                        });\n                    });\n                }\n            };\n            globalThis.addEventListener('message', listener);\n        });\n    };\n};\nconst defaultOptions = {\n    singleProcess: false\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((options) => {\n    options = Object.assign({}, defaultOptions, options);\n    const isPrimary = Boolean(globalThis.document) || options.singleProcess;\n    if (isPrimary) {\n        const emitter = new EventTarget();\n        observable_webworkers__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_READ_LOCK));\n        observable_webworkers__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_WRITE_LOCK));\n        return emitter;\n    }\n    return {\n        isWorker: true,\n        readLock: (name) => makeWorkerLockRequest(name, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_READ_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_READ_LOCK),\n        writeLock: (name) => makeWorkerLockRequest(name, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_REQUEST_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.MASTER_GRANT_WRITE_LOCK, _constants_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_RELEASE_WRITE_LOCK)\n    };\n});\n//# sourceMappingURL=browser.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/browser.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/mortice/dist/src/constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MASTER_GRANT_READ_LOCK: () => (/* binding */ MASTER_GRANT_READ_LOCK),\n/* harmony export */   MASTER_GRANT_WRITE_LOCK: () => (/* binding */ MASTER_GRANT_WRITE_LOCK),\n/* harmony export */   WORKER_RELEASE_READ_LOCK: () => (/* binding */ WORKER_RELEASE_READ_LOCK),\n/* harmony export */   WORKER_RELEASE_WRITE_LOCK: () => (/* binding */ WORKER_RELEASE_WRITE_LOCK),\n/* harmony export */   WORKER_REQUEST_READ_LOCK: () => (/* binding */ WORKER_REQUEST_READ_LOCK),\n/* harmony export */   WORKER_REQUEST_WRITE_LOCK: () => (/* binding */ WORKER_REQUEST_WRITE_LOCK)\n/* harmony export */ });\nconst WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read';\nconst WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read';\nconst MASTER_GRANT_READ_LOCK = 'lock:master:grant-read';\nconst WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write';\nconst WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write';\nconst MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write';\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/constants.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/mortice/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createMortice)\n/* harmony export */ });\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var p_timeout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-timeout */ \"./node_modules/p-timeout/index.js\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.js */ \"./node_modules/mortice/dist/src/browser.js\");\n/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * ## Usage\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice('my-lock', {\n *\n *   // how long before write locks time out (default: 24 hours)\n *   timeout: 30000,\n *\n *    // control how many read operations are executed concurrently (default: Infinity)\n *   concurrency: 5,\n *\n *   // by default the the lock will be held on the main thread, set this to true if the\n *   // a lock should reside on each worker (default: false)\n *   singleProcess: false\n * })\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\n\n\n\nconst mutexes = {};\nlet implementation;\nasync function createReleaseable(queue, options) {\n    let res;\n    const p = new Promise((resolve) => {\n        res = resolve;\n    });\n    void queue.add(async () => (0,p_timeout__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((async () => {\n        await new Promise((resolve) => {\n            res(() => {\n                resolve();\n            });\n        });\n    })(), {\n        milliseconds: options.timeout\n    }));\n    return p;\n}\nconst createMutex = (name, options) => {\n    if (implementation.isWorker === true) {\n        return {\n            readLock: implementation.readLock(name, options),\n            writeLock: implementation.writeLock(name, options)\n        };\n    }\n    const masterQueue = new p_queue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({ concurrency: 1 });\n    let readQueue;\n    return {\n        async readLock() {\n            // If there's already a read queue, just add the task to it\n            if (readQueue != null) {\n                return createReleaseable(readQueue, options);\n            }\n            // Create a new read queue\n            readQueue = new p_queue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                concurrency: options.concurrency,\n                autoStart: false\n            });\n            const localReadQueue = readQueue;\n            // Add the task to the read queue\n            const readPromise = createReleaseable(readQueue, options);\n            void masterQueue.add(async () => {\n                // Start the task only once the master queue has completed processing\n                // any previous tasks\n                localReadQueue.start();\n                // Once all the tasks in the read queue have completed, remove it so\n                // that the next read lock will occur after any write locks that were\n                // started in the interim\n                await localReadQueue.onIdle()\n                    .then(() => {\n                    if (readQueue === localReadQueue) {\n                        readQueue = null;\n                    }\n                });\n            });\n            return readPromise;\n        },\n        async writeLock() {\n            // Remove the read queue reference, so that any later read locks will be\n            // added to a new queue that starts after this write lock has been\n            // released\n            readQueue = null;\n            return createReleaseable(masterQueue, options);\n        }\n    };\n};\nconst defaultOptions = {\n    name: 'lock',\n    concurrency: Infinity,\n    timeout: 84600000,\n    singleProcess: false\n};\nfunction createMortice(options) {\n    const opts = Object.assign({}, defaultOptions, options);\n    if (implementation == null) {\n        implementation = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(opts);\n        if (implementation.isWorker !== true) {\n            // we are master, set up worker requests\n            implementation.addEventListener('requestReadLock', (event) => {\n                if (mutexes[event.data.name] == null) {\n                    return;\n                }\n                void mutexes[event.data.name].readLock()\n                    .then(async (release) => event.data.handler().finally(() => { release(); }));\n            });\n            implementation.addEventListener('requestWriteLock', async (event) => {\n                if (mutexes[event.data.name] == null) {\n                    return;\n                }\n                void mutexes[event.data.name].writeLock()\n                    .then(async (release) => event.data.handler().finally(() => { release(); }));\n            });\n        }\n    }\n    if (mutexes[opts.name] == null) {\n        mutexes[opts.name] = createMutex(opts.name, opts);\n    }\n    return mutexes[opts.name];\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/mortice/dist/src/utils.js":
/*!************************************************!*\
  !*** ./node_modules/mortice/dist/src/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nconst nanoid = (size = 21) => {\n    return Math.random().toString().substring(2);\n};\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ems/./node_modules/mortice/dist/src/utils.js?");

/***/ }),

/***/ "./node_modules/observable-webworkers/dist/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/observable-webworkers/dist/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst events = {};\nconst observable = (worker) => {\n    worker.addEventListener('message', (event) => {\n        observable.dispatchEvent('message', worker, event);\n    });\n    if (worker.port != null) {\n        worker.port.addEventListener('message', (event) => {\n            observable.dispatchEvent('message', worker, event);\n        });\n    }\n};\nobservable.addEventListener = (type, fn) => {\n    if (events[type] == null) {\n        events[type] = [];\n    }\n    events[type].push(fn);\n};\nobservable.removeEventListener = (type, fn) => {\n    if (events[type] == null) {\n        return;\n    }\n    events[type] = events[type]\n        .filter(listener => listener === fn);\n};\nobservable.dispatchEvent = function (type, worker, event) {\n    if (events[type] == null) {\n        return;\n    }\n    events[type].forEach(fn => fn(worker, event));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (observable);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/observable-webworkers/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/race-event/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/race-event/dist/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   raceEvent: () => (/* binding */ raceEvent)\n/* harmony export */ });\n/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n/**\n * An abort error class that extends error\n */\nclass AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.name = 'AbortError';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n/**\n * Race a promise against an abort signal\n */\nasync function raceEvent(emitter, eventName, signal, opts) {\n    // create the error here so we have more context in the stack trace\n    const error = new AbortError(opts?.errorMessage, opts?.errorCode);\n    if (signal?.aborted === true) {\n        return Promise.reject(error);\n    }\n    return new Promise((resolve, reject) => {\n        const eventListener = (evt) => {\n            try {\n                if (opts?.filter?.(evt) === false) {\n                    return;\n                }\n            }\n            catch (err) {\n                emitter.removeEventListener(eventName, eventListener);\n                signal?.removeEventListener('abort', abortListener);\n                reject(err);\n                return;\n            }\n            emitter.removeEventListener(eventName, eventListener);\n            signal?.removeEventListener('abort', abortListener);\n            resolve(evt);\n        };\n        const abortListener = () => {\n            emitter.removeEventListener(eventName, eventListener);\n            signal?.removeEventListener('abort', abortListener);\n            reject(error);\n        };\n        emitter.addEventListener(eventName, eventListener);\n        signal?.addEventListener('abort', abortListener);\n    });\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/race-event/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/race-signal/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/race-signal/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   raceSignal: () => (/* binding */ raceSignal)\n/* harmony export */ });\n/**\n * An abort error class that extends error\n */\nclass AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.name = 'AbortError';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n/**\n * Race a promise against an abort signal\n */\nasync function raceSignal(promise, signal, opts) {\n    if (signal == null) {\n        return promise;\n    }\n    if (signal.aborted) {\n        return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode));\n    }\n    let listener;\n    // create the error here so we have more context in the stack trace\n    const error = new AbortError(opts?.errorMessage, opts?.errorCode);\n    try {\n        return await Promise.race([\n            promise,\n            new Promise((resolve, reject) => {\n                listener = () => {\n                    reject(error);\n                };\n                signal.addEventListener('abort', listener);\n            })\n        ]);\n    }\n    finally {\n        if (listener != null) {\n            signal.removeEventListener('abort', listener);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/race-signal/dist/src/index.js?");

/***/ })

}])