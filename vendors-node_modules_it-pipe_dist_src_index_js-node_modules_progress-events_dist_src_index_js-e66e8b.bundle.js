/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkems"] = self["webpackChunkems"] || []).push([["vendors-node_modules_it-pipe_dist_src_index_js-node_modules_progress-events_dist_src_index_js-e66e8b"],{

/***/ "./node_modules/it-merge/dist/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/it-merge/dist/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction merge(...sources) {\n    const syncSources = [];\n    for (const source of sources) {\n        if (!isAsyncIterable(source)) {\n            syncSources.push(source);\n        }\n    }\n    if (syncSources.length === sources.length) {\n        // all sources are synchronous\n        return (function* () {\n            for (const source of syncSources) {\n                yield* source;\n            }\n        })();\n    }\n    return (async function* () {\n        const output = (0,it_pushable__WEBPACK_IMPORTED_MODULE_0__.pushable)({\n            objectMode: true\n        });\n        void Promise.resolve().then(async () => {\n            try {\n                await Promise.all(sources.map(async (source) => {\n                    for await (const item of source) {\n                        output.push(item);\n                    }\n                }));\n                output.end();\n            }\n            catch (err) {\n                output.end(err);\n            }\n        });\n        yield* output;\n    })();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (merge);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-merge/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-pipe/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/it-pipe/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   rawPipe: () => (/* binding */ rawPipe)\n/* harmony export */ });\n/* harmony import */ var it_pushable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-pushable */ \"./node_modules/it-pushable/dist/src/index.js\");\n/* harmony import */ var it_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-merge */ \"./node_modules/it-merge/dist/src/index.js\");\n\n\nfunction pipe(first, ...rest) {\n    if (first == null) {\n        throw new Error('Empty pipeline');\n    }\n    // Duplex at start: wrap in function and return duplex source\n    if (isDuplex(first)) {\n        const duplex = first;\n        first = () => duplex.source;\n        // Iterable at start: wrap in function\n    }\n    else if (isIterable(first) || isAsyncIterable(first)) {\n        const source = first;\n        first = () => source;\n    }\n    const fns = [first, ...rest];\n    if (fns.length > 1) {\n        // Duplex at end: use duplex sink\n        if (isDuplex(fns[fns.length - 1])) {\n            fns[fns.length - 1] = fns[fns.length - 1].sink;\n        }\n    }\n    if (fns.length > 2) {\n        // Duplex in the middle, consume source with duplex sink and return duplex source\n        for (let i = 1; i < fns.length - 1; i++) {\n            if (isDuplex(fns[i])) {\n                fns[i] = duplexPipelineFn(fns[i]);\n            }\n        }\n    }\n    return rawPipe(...fns);\n}\nconst rawPipe = (...fns) => {\n    let res;\n    while (fns.length > 0) {\n        res = fns.shift()(res);\n    }\n    return res;\n};\nconst isAsyncIterable = (obj) => {\n    return obj?.[Symbol.asyncIterator] != null;\n};\nconst isIterable = (obj) => {\n    return obj?.[Symbol.iterator] != null;\n};\nconst isDuplex = (obj) => {\n    if (obj == null) {\n        return false;\n    }\n    return obj.sink != null && obj.source != null;\n};\nconst duplexPipelineFn = (duplex) => {\n    return (source) => {\n        const p = duplex.sink(source);\n        if (p?.then != null) {\n            const stream = (0,it_pushable__WEBPACK_IMPORTED_MODULE_0__.pushable)({\n                objectMode: true\n            });\n            p.then(() => {\n                stream.end();\n            }, (err) => {\n                stream.end(err);\n            });\n            let sourceWrap;\n            const source = duplex.source;\n            if (isAsyncIterable(source)) {\n                sourceWrap = async function* () {\n                    yield* source;\n                    stream.end();\n                };\n            }\n            else if (isIterable(source)) {\n                sourceWrap = function* () {\n                    yield* source;\n                    stream.end();\n                };\n            }\n            else {\n                throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable');\n            }\n            return (0,it_merge__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(stream, sourceWrap());\n        }\n        return duplex.source;\n    };\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-pipe/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/it-pushable/dist/src/fifo.js":
/*!***************************************************!*\
  !*** ./node_modules/it-pushable/dist/src/fifo.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FIFO: () => (/* binding */ FIFO)\n/* harmony export */ });\n// ported from https://www.npmjs.com/package/fast-fifo\nclass FixedFIFO {\n    buffer;\n    mask;\n    top;\n    btm;\n    next;\n    constructor(hwm) {\n        if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n            throw new Error('Max size for a FixedFIFO should be a power of two');\n        }\n        this.buffer = new Array(hwm);\n        this.mask = hwm - 1;\n        this.top = 0;\n        this.btm = 0;\n        this.next = null;\n    }\n    push(data) {\n        if (this.buffer[this.top] !== undefined) {\n            return false;\n        }\n        this.buffer[this.top] = data;\n        this.top = (this.top + 1) & this.mask;\n        return true;\n    }\n    shift() {\n        const last = this.buffer[this.btm];\n        if (last === undefined) {\n            return undefined;\n        }\n        this.buffer[this.btm] = undefined;\n        this.btm = (this.btm + 1) & this.mask;\n        return last;\n    }\n    isEmpty() {\n        return this.buffer[this.btm] === undefined;\n    }\n}\nclass FIFO {\n    size;\n    hwm;\n    head;\n    tail;\n    constructor(options = {}) {\n        this.hwm = options.splitLimit ?? 16;\n        this.head = new FixedFIFO(this.hwm);\n        this.tail = this.head;\n        this.size = 0;\n    }\n    calculateSize(obj) {\n        if (obj?.byteLength != null) {\n            return obj.byteLength;\n        }\n        return 1;\n    }\n    push(val) {\n        if (val?.value != null) {\n            this.size += this.calculateSize(val.value);\n        }\n        if (!this.head.push(val)) {\n            const prev = this.head;\n            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);\n            this.head.push(val);\n        }\n    }\n    shift() {\n        let val = this.tail.shift();\n        if (val === undefined && (this.tail.next != null)) {\n            const next = this.tail.next;\n            this.tail.next = null;\n            this.tail = next;\n            val = this.tail.shift();\n        }\n        if (val?.value != null) {\n            this.size -= this.calculateSize(val.value);\n        }\n        return val;\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n}\n//# sourceMappingURL=fifo.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-pushable/dist/src/fifo.js?");

/***/ }),

/***/ "./node_modules/it-pushable/dist/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/it-pushable/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   pushable: () => (/* binding */ pushable),\n/* harmony export */   pushableV: () => (/* binding */ pushableV)\n/* harmony export */ });\n/* harmony import */ var p_defer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-defer */ \"./node_modules/p-defer/index.js\");\n/* harmony import */ var _fifo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fifo.js */ \"./node_modules/it-pushable/dist/src/fifo.js\");\n/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\n\nclass AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nfunction pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new _fifo_js__WEBPACK_IMPORTED_MODULE_0__.FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = (0,p_defer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = (0,p_defer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new _fifo_js__WEBPACK_IMPORTED_MODULE_0__.FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new _fifo_js__WEBPACK_IMPORTED_MODULE_0__.FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        },\n        onEmpty: (opts) => {\n            return _pushable.onEmpty(opts);\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/it-pushable/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/progress-events/dist/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/progress-events/dist/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomProgressEvent: () => (/* binding */ CustomProgressEvent)\n/* harmony export */ });\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nclass CustomProgressEvent extends Event {\n    constructor(type, detail) {\n        super(type);\n        this.detail = detail;\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/progress-events/dist/src/index.js?");

/***/ }),

/***/ "./node_modules/uint8arraylist/dist/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/uint8arraylist/dist/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Uint8ArrayList: () => (/* binding */ Uint8ArrayList),\n/* harmony export */   isUint8ArrayList: () => (/* binding */ isUint8ArrayList)\n/* harmony export */ });\n/* harmony import */ var uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/alloc */ \"./node_modules/uint8arrays/dist/src/alloc.js\");\n/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/concat */ \"./node_modules/uint8arrays/dist/src/concat.js\");\n/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/equals */ \"./node_modules/uint8arrays/dist/src/equals.js\");\n/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\n\n\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n    if (index == null || index < 0) {\n        throw new RangeError('index is out of bounds');\n    }\n    let offset = 0;\n    for (const buf of bufs) {\n        const bufEnd = offset + buf.byteLength;\n        if (index < bufEnd) {\n            return {\n                buf,\n                index: index - offset\n            };\n        }\n        offset = bufEnd;\n    }\n    throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nfunction isUint8ArrayList(value) {\n    return Boolean(value?.[symbol]);\n}\nclass Uint8ArrayList {\n    bufs;\n    length;\n    [symbol] = true;\n    constructor(...data) {\n        this.bufs = [];\n        this.length = 0;\n        if (data.length > 0) {\n            this.appendAll(data);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.bufs;\n    }\n    get byteLength() {\n        return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */\n    append(...bufs) {\n        this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */\n    appendAll(bufs) {\n        let length = 0;\n        for (const buf of bufs) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.push(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.push(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */\n    prepend(...bufs) {\n        this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */\n    prependAll(bufs) {\n        let length = 0;\n        for (const buf of bufs.reverse()) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.unshift(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.unshift(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */\n    get(index) {\n        const res = findBufAndOffset(this.bufs, index);\n        return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */\n    set(index, value) {\n        const res = findBufAndOffset(this.bufs, index);\n        res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */\n    write(buf, offset = 0) {\n        if (buf instanceof Uint8Array) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf[i]);\n            }\n        }\n        else if (isUint8ArrayList(buf)) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf.get(i));\n            }\n        }\n        else {\n            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n        }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */\n    consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes);\n        // do nothing if not a positive number\n        if (Number.isNaN(bytes) || bytes <= 0) {\n            return;\n        }\n        // if consuming all bytes, skip iterating\n        if (bytes === this.byteLength) {\n            this.bufs = [];\n            this.length = 0;\n            return;\n        }\n        while (this.bufs.length > 0) {\n            if (bytes >= this.bufs[0].byteLength) {\n                bytes -= this.bufs[0].byteLength;\n                this.length -= this.bufs[0].byteLength;\n                this.bufs.shift();\n            }\n            else {\n                this.bufs[0] = this.bufs[0].subarray(bytes);\n                this.length -= bytes;\n                break;\n            }\n        }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */\n    slice(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */\n    subarray(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        if (bufs.length === 1) {\n            return bufs[0];\n        }\n        return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */\n    sublist(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        const list = new Uint8ArrayList();\n        list.length = length;\n        // don't loop, just set the bufs\n        list.bufs = [...bufs];\n        return list;\n    }\n    _subList(beginInclusive, endExclusive) {\n        beginInclusive = beginInclusive ?? 0;\n        endExclusive = endExclusive ?? this.length;\n        if (beginInclusive < 0) {\n            beginInclusive = this.length + beginInclusive;\n        }\n        if (endExclusive < 0) {\n            endExclusive = this.length + endExclusive;\n        }\n        if (beginInclusive < 0 || endExclusive > this.length) {\n            throw new RangeError('index is out of bounds');\n        }\n        if (beginInclusive === endExclusive) {\n            return { bufs: [], length: 0 };\n        }\n        if (beginInclusive === 0 && endExclusive === this.length) {\n            return { bufs: this.bufs, length: this.length };\n        }\n        const bufs = [];\n        let offset = 0;\n        for (let i = 0; i < this.bufs.length; i++) {\n            const buf = this.bufs[i];\n            const bufStart = offset;\n            const bufEnd = bufStart + buf.byteLength;\n            // for next loop\n            offset = bufEnd;\n            if (beginInclusive >= bufEnd) {\n                // start after this buf\n                continue;\n            }\n            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n            if (sliceStartInBuf && sliceEndsInBuf) {\n                // slice is wholly contained within this buffer\n                if (beginInclusive === bufStart && endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                const start = beginInclusive - bufStart;\n                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n                break;\n            }\n            if (sliceStartInBuf) {\n                // slice starts in this buffer\n                if (beginInclusive === 0) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    continue;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(beginInclusive - bufStart));\n                continue;\n            }\n            if (sliceEndsInBuf) {\n                if (endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(0, endExclusive - bufStart));\n                break;\n            }\n            // slice started before this buffer and ends after it\n            bufs.push(buf);\n        }\n        return { bufs, length: endExclusive - beginInclusive };\n    }\n    indexOf(search, offset = 0) {\n        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n            throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n        }\n        const needle = search instanceof Uint8Array ? search : search.subarray();\n        offset = Number(offset ?? 0);\n        if (isNaN(offset)) {\n            offset = 0;\n        }\n        if (offset < 0) {\n            offset = this.length + offset;\n        }\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (search.length === 0) {\n            return offset > this.length ? this.length : offset;\n        }\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n        const M = needle.byteLength;\n        if (M === 0) {\n            throw new TypeError('search must be at least 1 byte long');\n        }\n        // radix\n        const radix = 256;\n        const rightmostPositions = new Int32Array(radix);\n        // position of the rightmost occurrence of the byte c in the pattern\n        for (let c = 0; c < radix; c++) {\n            // -1 for bytes not in pattern\n            rightmostPositions[c] = -1;\n        }\n        for (let j = 0; j < M; j++) {\n            // rightmost position for bytes in pattern\n            rightmostPositions[needle[j]] = j;\n        }\n        // Return offset of first match, -1 if no match\n        const right = rightmostPositions;\n        const lastIndex = this.byteLength - needle.byteLength;\n        const lastPatIndex = needle.byteLength - 1;\n        let skip;\n        for (let i = offset; i <= lastIndex; i += skip) {\n            skip = 0;\n            for (let j = lastPatIndex; j >= 0; j--) {\n                const char = this.get(i + j);\n                if (needle[j] !== char) {\n                    skip = Math.max(1, j - right[char]);\n                    break;\n                }\n            }\n            if (skip === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getInt8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt8(0);\n    }\n    setInt8(byteOffset, value) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getInt16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt16(0, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getInt32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt32(0, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigInt64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigInt64(0, littleEndian);\n    }\n    setBigInt64(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigInt64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint8(0);\n    }\n    setUint8(byteOffset, value) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getUint16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint16(0, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint32(0, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigUint64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigUint64(0, littleEndian);\n    }\n    setBigUint64(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigUint64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat32(0, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat64(0, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n        const buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.alloc)(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof Uint8ArrayList)) {\n            return false;\n        }\n        if (other.bufs.length !== this.bufs.length) {\n            return false;\n        }\n        for (let i = 0; i < this.bufs.length; i++) {\n            if (!(0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__.equals)(this.bufs[i], other.bufs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */\n    static fromUint8Arrays(bufs, length) {\n        const list = new Uint8ArrayList();\n        list.bufs = bufs;\n        if (length == null) {\n            length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n        }\n        list.length = length;\n        return list;\n    }\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ems/./node_modules/uint8arraylist/dist/src/index.js?");

/***/ })

}])